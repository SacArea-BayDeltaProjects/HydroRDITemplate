'CR1000 or CR6 Series Datalogger
'Program Authors
'Michael R. Simpson, HydroInterface
'Trevor Violette, Mark Inc, and Jim DeRose, USGS
'Program Version Date
Const ProgramVersionDate = 20201102
Const ProgramVersion = "5.12"
'Last Modified by: Trevor Violette

'UNIVERSAL PROGRAM -- May need some trimming!!! NOTE! THIS PROGRAM WILL NOT COMPILE ON CR1000 OS 28 or EARLIER!

'-----------------IMPORTANT IMPORTANT-----------------------------------------------
'BEFORE COMPILING:
' 1 SET DLD DATALOGGER TYPE IN TOOLS MENU FOR THE TARGET DATALOGGER
' 2 CHOOSE CUSTOMIZE CONSTANTS IN TOOLS MENU, SELECT PROPER CONSTANTS FOR THE TARGET STATION
' 3 CHOOSE CONDITIONAL COMPILE AND SAVE IN THE COMPILE MENU. RENAME THE FILE WITH STATION ID AND DATE IN FILENAME USING CR6 or CR1 file extension
' 4 LOAD THE SAVED FILE INTO THE STATION DATALOGGER OR YOU CAN LOAD THE ORIGINAL DLD FILE IF SPACE PERMITS.
' 5 DO NOT USE A MAX232 ADAPTER ON THE CSI/0 (ComME) port

'Note: Pos Flow angle can only be used on 4 beam uplookers using EARTH coordinate transformation.
'its use in any other configuration is disabled after the first ensemble.
'If using BEAM coordinate transformation on a Channel Master, You MUST obtain an external HEADING determination as there is NO internal compass!
'If using a Bi-directional rating (Ebb/Flood) with different bins for each direction you must be using a channel master with insturment coordinates, you must set Birating to true in the startup parameters.
'You also must set StartBin, EndBin, StartEbbBin, EndEbbBin, StartFldBin, and EbbFldBin to appropriate values (ebb = pos) (Fld = neg)  Startbin and Endbin should include all the bins used
'for both ebb and flood calculations. You also have to set BiRatTran to the velocity That you wish calculations to switch from Ebb bins to Flood Bins. The program will make sure you are using
'a Channel Master with instrument coords before applying the Ebb/Flood bin differences. If you are using any other VM or coord system, it will use the standard method to calculate iVel.
'You can include V2 (Y velocity) in the IndexVel calculation if you wish to use it. Just make sure UseV2 is True.

'=============================================================================================================
'--------------------------------------- PROGRAM CHANGE LOG --------------------------------------------------
'=============================================================================================================
' 20201001 - TAV 5.00 Major overhaul of system. Rearranged subroutines, order of operations, tweaked sampling methodology, now allows for 2 EXOs and SUNA to
'                     be sampled at the same time. New averaging set to go into place at given date. Old averaging used mins 0-14, new uses 8-22.
'                     Added MRI's "Hail-Mary Switch" to catch catastrophic failures/reboot entire system using an Arduino UNO. Old change log will be stored
'                     as .txt file on the GitLab repository for referencing. Note: Focus was put on to CR6 loggers, there are likely problems with CR1000 code.
'                     Likely to eliminate CR1000 code in future releases.
' 20201014 - TAV 5.10 Added flags to indicate an NAN in stage values to prevent it from being averaged in using the DisableVariable in the Average function
'                     Added VMElevation and WQElevation. These are based on StagePrime and Raw depth values from each sensor
' 20201019 - TAV/MRI 5.11 Added OneMinCounter to Debugger Table for easy reference. MRI: Created "OneMinCounterReset" Flag to act as redundant switch for techs to reset 1min counter if another visit was carried out the day before per recomendation by JH.
'                    Added Std. Dev. for SUNA' Nitrate mgL to AQ table
' 20201102 - TAV 5.12 Changed "CardOut" instruction to "TableFile" instruction. This allows use of more than 2GB of card memory. Adjusted SunaWarning string to be larger. (Was 30 characters, increased to 200. Noticed we were cutting the string off at CM72.)

SequentialMode 'We need to use Sequential mode

'Start of Constants Customization Section
Const WqSonde = "WQ_SERIAL_BURST"
'Value = "WQ_SERIAL"
'Value = "WQ_SERIAL_BURST"
'Value = "NONE"
Const DWRSonde = False
'value = True
'value = False
Const TopBottom = False  'Is there a second EXO in the system
'value = True
'value = False
Const HasIridium = False
'value = True
'value = False
Const HasSuna = False 'THIS WILL ONLY COMPILE ON A CR6!
'value = True
'value = False
Const MaxSunaBurst = 40 'Increased to account for bad data and DarkFrames so we don't get variables out of bounds.
'Min = 10
'Max = 40
'Inc = 1
Const WqBaud = 38400
'value = 9600
'value = 38400
Const VmBaud = 38400
'value = 9600
'value = 19200
'value = 38400
'value = 57600
'value = 115200
Const IsWqMax232 = False 'If using a CR1000 and collecting serial burst water quality data this should be true
'value = True
'value = False
Const IsBtmWqMax232 = False
'value = True
'value = False
Const MaxBurstCnt = 30
'Min = 1
'Max = 30
'Inc = 1
Const MinBurstVals = 4
'Min = 1
'Max = 30
'Inc = 1
Const IsVmMax232 = False
'value = True
'value = False
Const IsSpecStudy = False
'value = True
'value = False
Const HasGPS = False '***THIS WILL ONLY COMPILE ON CR6!***
'value = True
'value = False
Const HasModem = True
'value = True
'value = False
Const GetNoiseFloor = False
'value = True
'value = False
Const HasSlave = False
'value = True
'value = False
Const HasVM = True
'value = True
'value = False
Const MaxBins = 27
'Min = 1
'Max = 100
'Inc = 1
'Const VMStartSec = 15 'seconds into minute for ensemble to start
''Min = 0
''Max = 59
''Inc = 1
Const UseAutoRange = False
'value = True
'value = False
Const WQDeadCntMax = 20
'Min = 5
'Max = 120
'Inc = 5
Const VMDeadCntMax = 20
'Min = 5
'Max = 120
'Inc = 5
Const RadioNetwork = False 'Is the datalogger part of a radio network NOTE: IF TRUE THIS WILL ONLY COMPILE ON CR6-RF451!!
'value = True
'value = False
Const IsMaster = False  'Is the datalogger the Master in a radio network?
'value = True
'value = False
Const StoreAllToCard = True 'set to true if you want VM spike data
'value = True
'value = False
Const VMHasVertical = False
'value = True
'value = False
Const VMHasBottomTrack = False
'value = True
'value = False
Const Debugging = False
'Value = True
'Value = False
Const SeeAllVel = False
'Value = True
'Value = False
Const SeeRawWQ = False
'Value = True
'Value = False
Const HasHMS = True 'ONLY COMPILES ON CR6!
'Value = True
'Value = False
Const ReadExtPwr = False
'Value = True
'Value = False
'End of Constants Customization Section

ConstTable (DLDSettings,1)
  Const = VMStartSec = 20 'Used to define the exact sec to start pinging. Testing ConstTable
  #If RadioNetwork = True Then
    #If IsMaster = True Then
      Const NetworkSlaves = 2 'How many nodes are in the system
    #EndIf
  #EndIf
EndConstTable

'------------------------------------------------------------------------------------------
'Constants to allow program to be used on CR1000 OR CR6 datalogger.
'in this preliminary version it's assumed that the CDMA uses SW12 no 1 on both dataloggers
'IMPORTANT! if using CR6 ports ComC1 or ComC3 use the device configuration utility to configure these ports for RS-232 (not TTL or other)
'-------------------------------------------------------------------------------------------------------------------------------------------
#If LoggerType = CR1000 Then
  #If HasVM = True Then 'If VM/PS on board, establish ports
    Const AdcpPort = Com1
    Const VMSwitchPort = 4 'only used if not using sw12
    Const PS1Com3 = 3
    Const PS1Com5 = 5
    Const PS2Com3 = 3
    Const PS2Com5 = 5
  #EndIf
  #If WqSonde <> "NONE" Then 'We have a sonde, set up ports
    Const WqSwitchPort = 6
    Const WqSerialPort = Com4
    #If TopBottom = True Then
      Const BtmWqSerialPort = Com4
      Const BtmWqSwitchPort = 6
    #EndIf
  #EndIf 'If we have a sonde
  #If HasSlave = True Then 'If needing to send data to second logger
    Const SlaveCom = Com4
  #EndIf 'if sending data to second logger
  #If ReadExtPwr = True Then 'if using 10:1 voltage reducer to measure high voltage
    Const ExtPwrCom = 1
    Const ExtSolarCom = 2
  #EndIf 'high voltage
  #If HasIridium = True Then 'if using iridium as backup to cell
    Const IridiumCom = 5
  #EndIf 'if using iridium
#ElseIf LoggerType = CR6 Then
  #If HasVM = True Then 'if we have a VM or Pressure sensors
    Const AdcpPort = ComU1
    Const VMSwitchPort = U4
    Const PS1Com3 = U3
    Const PS1Com5 = U5
    Const PS2Com3 = U3
    Const PS2Com5 = U5
  #EndIf 'if VM or pressure sensors present
  #If WqSonde <> "NONE" Then 'If sonde present
    Const WqSerialPort = ComC1 'WQ must use a C port
    Const WqSwitchPort = U6 'establish switch ports
    Const UseSW12_2_forWQ = False
    #If TopBottom = True Then 'if redundant, top/bottom setup
      Const BtmWqSerialPort = ComRS232 'WQ must use a C port
      Const BtmWqSwitchPort = U8 'set up second switch port
    #EndIf 'Sonde determination
  #EndIf 'If sonde present
  #If HasSuna = True Then 'if SUNA present
    Const SunaPort = ComC3
    Const SunaWipeSwitch = U9
    Const SunaSwitch = U10
  #EndIf 'if suna present
  #If HasSlave = True Then 'if sending data to another logger
    Const SlaveCom = ComU7 'can't use ComU7 if TopBottom, maybe RS232?
  #EndIf 'if sending data to another logger
  #If HasIridium = True Then 'If using iridium as backup to cell
    Const IridiumSwitchPort = U10 'set power cycle port
    Const IridiumCom = U7 'set SDI port
  #EndIf 'if has iridium
  #If RadioNetwork Then 'Only used if using CR6-RF451
    Const DefRadOn = 0
    Const DefOpMode = 2
    Const DefFreqKey = 0
    Const DefMaxPacket = 8
    Const DefMinPacket = 9
    Const DefDataRate = 3 'Normal
    Const DefTxPwr = 10 'Max
    Const DefRetryTO = 255 'Max
    Const DefLowPwr = 2
    Const DefRepeaters = 0 'No repeaters
    Const DefPacketRepeat = 2
    Const DefSlaveRetry = 9
    Const DefFreqRepeat = 0
    Const DefSlaveRepeat = 0
    Const DefTxSubID = 15
    Const DefRxSubID = 15
    Const DefNetID = 1234
  #EndIf 'if radio network
  #If HasHMS = True Then
    Const HMS_ErrPort = U11
    Const HMS_OkPort = U12
  #EndIf
  #If ReadExtPwr = True Then 'if needing to read high external voltage
    Const ExtPwrCom = U11
    Const ExtSolarCom = U9
  #EndIf 'if external voltage
#EndIf 'Logger type determination

'Constants for selecting different scan rates, if wanted. Standard is 1min scans
Const ScanRate = 60
Const ScanUnit = 2
Const FastScanRate = 15 'used in modem check, but should be done a different way
Const FastScanUnit = 2

'Constants to define numeric values to stage sensors
#If HasVM = True Then 'we have vm or pressure sensors
  Const UPbeam = 1
  Const VMpress = 2
  Const PSpress = 3
  Const PSpress2 = 4
#EndIf 'we have vm or pressure sensors
#If WqSonde <> "NONE" Then 'we have a sonde
  Const WqPress = 5
#EndIf 'we have a sonde



'==============================================
'-------------STANDARD CONSTANTS---------------
'==============================================
Const BadDataIndicator = NAN

'==============================================
'---------STANDARD TABLE FLAGS/TRIGGERS--------
'==============================================
Dim Rec1MinFlag As Boolean 'Trigger to store 1min data
Dim Rec15MinFlag As Boolean 'Trigger to store 15min data tables
Dim Rec24HrFlag As Boolean 'Trigger for daily (QAQC) table

'==============================================
'----------STANDARD TIMING VARIABLES-----------
'==============================================
Dim TimeStamp15Min As String * 20 'Create timestamp to be used for data reporting
Dim FSplitTime(6) 'for FTime function
Dim rTime(9) As Float: Alias rTime = Year, Month, DOM, Hour, Minute, Second, MicroSecond, DOW, DOY 'this array holds time values returned from the realtime statement
Dim RealSeconds As Long
Dim Mod5Minutes As Long
Dim Mod15Minutes As Long
Dim Mod60Minutes As Long
Dim ModDay As Long

'==============================================
'--------- EXO AND SUNA START TIMER -----------
'==============================================
#If WqSonde <> "NONE" OR HasSuna = True Then
  Public SampleTime
#EndIf

'-----------------Standard Debugging Timers -------------
Dim DebugTimer As Float 'Timer name for the following scan timing variables
Dim ProcTimer(3): Alias ProcTimer = ScanStart, ScanEnd, ProcessTime 'Full process time
Dim DataTabsTimer(3): Alias DataTabsTimer = DataTabsStart, DataTabsEnd, DataTabsTotTime 'Timing for all data tables called at end of scan (does not include burst tables for suna/EXO
Dim AQTabTimer(3): Alias AQTabTimer = AQTabStart, AQTabEnd, AQTabTotTime 'Time of calling/outputting AQ Table
'Dim Data1mTimer(3): Alias Data1mTimer = Data1mStart, Data1mEnd, Data1mTotTime 'Calling 1min data table
'Dim DataOutTimer(3): Alias DataOutTimer = DataOutStart, DataOutEnd, DataOutTotTime 'Calling "DataOut" Table
#If HasModem = True Then
  Dim ModemChkTimer(3): Alias ModemChkTimer = ModemChkStart, ModemChkEnd, ModemChkTotTime 'Checking on Modem status
#EndIf

'==============================================
'-------------DECLARE VM CONSTANTS-------------
'==============================================
#If HasVM = True Then
  '==============================================
  '---------STANDARD PD0 DATA IDs----------------
  '==============================================
  Const FixedLeaderID = 0
  Const VariableLeaderID = 128
  Const CorrelationProfileID = 512
  Const RSSIProfileID = 768
  Const PGoodProfileID = 1024
  Const VelocityProfileID = 256
  Const VMStageID = 16384
  Const BottomID = 1536

  '=================================================
  '--------------VERTICAL PROFILE IDs---------------
  '=================================================
  #If VMHasVertical Then
    Const VertLeaderID = 3841
    Const VertVelocityID = 2560
    Const VertRSSIID = 3072
    Const VertCorrID = 2816
  #EndIf

  '=================================================
  '---------------BOTTOM TRACK ID-------------------
  '=================================================
  #If VMHasBottomTrack Then
    Const BottomTrackID = 1536
  #EndIf

  '===============================================
  '---------------CALCULATIONS--------------------
  '===============================================
  Const MaxBeams = 4
  Const BadVel = -32768 'bad velocity indicator from adcp
  Const Meters_to_Feet = 3.280839895 'Calculate meters to feet
  Const DegToRad = (3.14159265358979323846/180) 'degrees to radians
  Const VelocityScaleWater = 1/304.8 'convert mm/sec to ft/sec
  Const rad = 3.14159/180
  Const deg = 180/3.14159
#EndIf 'If we have a velocity meter
'===============================================
'--------- STANDARD PUBLIC VARIABLES -----------
'===============================================
'******LET'S EXPLORE REMOVING STATUS BASED VARIABLES,
'      NO SENSE IN DUPLICATING WHAT'S ALREADY BEING PRODUCED
Public SiteID As String * 6 'Acronym for station identification
Public SiteNum As String * 16 'USGS Station number
Public LastScan As String * 6 'Time of last successful scan
Public ScanNum As Long 'Total number of scans program has been running for. Changed from "ScanNo" for easier understanding
Public StationVolts As Float 'Station voltage <- Changed from CR1Volts
Public Low12Volts As Long 'from "status" table, how many times has there been low voltage (based on CR1000 threshold of 9.6v when the CR1000 goes into a lower power
'mode and discontinues it's measurement tasks until power is restored)
Public LithBat As Float 'voltage of the internal lithium battery. (this battery keeps memory in case of external power issues)
Public PTempC As Float 'Temp of Datalogger Panel, degC
Public PTempF As Float 'Temp of Datalogger Panel, degF <- do we really need this?
Public SerNum As Long 'Logger serial number, can we sample this from Status table instead?
Public OSVers As String * 18 'This is available in Status table, explore sampling Status.OSVersion to QAQC table directly rather than separate variable
Public Program As String * 25 'Program version
Public ProgVersDate As String * 8 'date of the program version, based on the constant "ProgramVersionDate"
Public ProgVersion As String * 5 'program version number, based on constant "ProgramVersion"
Public LastRecompile As String * 25 'hold last recompile date/time from status table
Public ProgErrors As Long 'from "Status" table, The number of compile or runtime errors for the current program.
Public Tech As String * 3 'user initials so we know who was there for a visit
Public VisitReason As String *100 'what is the purpose of the visit
Public SkipScans As Long 'number of times a complete scan has been skipped (with the exception of intentionally skipped scans based on ExitScan and Do/Loops
Public FreeCFMem As Float 'how much memory does the external CF card have remaining
Public ErrorEvent As String * 100 'what caused the automated "SiteVisit" table to be written?
Public RecCalibData As Boolean 'Flag to store 1min data for 24hr
Public OneMinCounterReset As Boolean 'Redundant flag to force the 1min counter to reset to zero and turn RecCabliData to true in the event a site visit occured the day before current visit
Public OneMinConsistent As Boolean 'Flag to store 1min data for prolonged periods. Needs manual shut-off
#If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then
  Public SetEXOTimeFlg As Boolean 'Trigger to set EXO clock if we have Serial communication
  #If WqSonde = "WQ_SERIAL_BURST" Then
    Public BurstPeriod As Float 'time between samples for EXO Burst routine
  #EndIf 'if burst
#EndIf 'if sonde is serial mode
#If HasSuna = True Then
  Public ManualSunaOn As Boolean
  Public ManSunaWiper As Boolean
#EndIf
#If HasModem = True Then
  Public IsModemOn As Boolean
  Public KeepModemOn As Boolean 'keep the modem on 24/7 (True), or only turn on at the top of the hour for 10min to save battery (False)
  Public CycleModemPwr As Boolean 'manual power cycle for modem
  Public ModemHrsOff As Float 'number of hours allowed to pass before trying to restart modem if there are connection problems
  Public IsModemNClosed As Boolean 'is the modem on a normally closed relay
#EndIf
#If HasIridium = True Then
  Public IridiumManualCycle As Boolean
#EndIf
#If HasHMS = True Then
  Public HMS_Disable As Boolean
  Public HMS_Manual As Boolean
#EndIf
Public StoreVariablesFlg As Boolean 'Used to trigger variable storage to USR drive
Public GetVariablesFlg As Boolean 'Used to trigger variable retrieval from USR drive
Public PreserveFile As String * 500 'THIS CAN BE LOCALIZED WITHIN READ/STORE VARIABLES SUBS
Public IsSubmersed As Boolean '****LETS THINK ABOUT THIS: originally, used to switch the function of the SW12V port so it's used for ADCP if the datalogger is in a submersible enclosure (with no relays, CDMA, etc.)
Public FTimeIn 'Argument for which time format to use based on instrument/file

'===============================================
'--------------- STANDARD DIMS -----------------
'===============================================
Dim OneMinCount As Long 'Used to turn off 1min data after 24hr (if not OneMinConsistent)
Dim SiteVisTrig As Boolean 'Trigger for SiteVisit table
'===============================================
'--------DECLARE PUBLICS AND DIMS FOR VM--------
'===============================================
#If HasVM = True Then
  '------------ VM STATUS/RATING RELATED PUBLICS ------------
  ' Maybe move Booleans that need user input to be together with all others (WQ, RecCalib, etc)
  Public VMPower As Boolean 'Manually turn VM on or off
  Public IsVMNClosed As Boolean 'Is VM powered on Normally Closed Relay
  Public CalcQ As Boolean
  Public SendFlowData As Boolean 'Used to trigger Flow related data to be sent out a serial port, mainly for FPT/SWWTP, Conditional?
  Public UseV2 As Boolean
  Public RecordAll As Boolean 'ONLY PUT THIS IN FOR EASE OF SUBS, LOOK INTO, CAN BE REMOVED BY USING CONDITIONAL AROUND VELDATA TABLE
  Public VMdataIn As Boolean
  Public IsCM As Boolean 'System IDs, sensed by number of beams/if vertical beam. These are autoset, decodes adjusted accordingly
  Public IsVADCP As Boolean
  Public IsWorkHorse As Boolean
  Public VMTime As String * 25 'Timestamp from VM clock
  Public SetVMTimeFlg As Boolean 'Used to set VM clock from logger clock. Automatic at midnight, but user can set as well
  Public SendTF As Boolean 'Used to set the exact start time for ensemble
  '  Public TFBuffer <------ Currently hard coded at 13s for plenty of time Used to set buffer (in seconds) between issuance of TF and start of pinging
  Public AdcpSN As Long
  Public NewADCP As Boolean 'Auto Trigger to identify if a new instrument was installed
  Public PS1SN As String * 40 'used to get pressure sensor brand, model, and serial number
  Public NewPS1 As Boolean 'is it a new pressure sensor?
  Public PS2SN As String * 40 'used to get pressure sensor brand, model, and serial number
  Public NewPS2 As Boolean 'is it a new pressure sensor?
  Public BinSize As Long 'Bin size in cm
  '-------Vert Conditional ------
  #If VMHasVertical Then
    Public VerticalBinSize As Long 'Bin Size of 5th beam bins
    Public VerticalBin1Center As Float 'Center of 1st vertical bin
  #EndIf
  '------------------------------
  Public BlankDist As Long
  Public NumADCPBins As Long 'number of bins ADCP is outputting
  Public Numbins As Long 'number of bins user sets to use
  '--------Vert Conditional ------
  #If VMHasVertical Then
    Public VerticalBinNum As Long 'Number of bins for 5th beam
  #EndIf
  '--------------------------------
  '---------Bottom Track Conditional ---------
  #If VMHasBottomTrack Then
    Public BtmTrackPings As Long 'Number of pings for bottom tracking
    Public BtmTrackMode As Long 'Mode for bottom tracking
  #EndIf
  '------------------------------------------
  Public EnsPings As Long 'number of pings per ensemble
  '--------Vert Conditional -------
  #If VMHasVertical Then
    Public VerticalPings As Long 'Number of pings per ensemble for 5th beam
  #EndIf
  '--------------------------------
  Public NumBeams As Long 'number of beams on instrument
  Public EX As Long 'Coordinate transformation
  Public ES As Long 'salinity setting in ADCP
  Public BIT As Long 'Built in tests, see manual. if 0, no tests failures
  Public EnsembleNo As Long 'ADCP's internal Ensemble count
  Public EnsembleLen As Long 'ADCP's ensemble length, (LongArray(3) + (LongArray(4)*256))
  Public Decode As String * 70 'how is the dat abeing decoded
  Public Coord As String * 20 'which coordinate system is the ADCP using?
  Public FramingError As Long
  Public EnsBytes As Long 'Number of bytes PD0 says are in ensemble
  Public NumBytes As Float 'Datalogger calculated number of bytes in ensemble
  Public CalcCheckSum As Float
  Public EnsCheckSum As Float
  Public BadCheckSum As Long
  Public HeaderMismatch
  Public BadEnsemble
  Public MissedEns 'Number of missed ensembles
  Public BadEnsCount As Float
  Public BadQCount As Long 'how many times has the datalogger been unable to calculate discharge? (either bad stage value or bad velocity value)
  Public MinExpVel As Long 'minimum velocity expected at site
  Public MaxExpVel As Long 'maximum velocity expected at site
  Public VelCount As Long '*****INVESTIGATE NEED FOR THIS FURTHER
  Public BadBinCount As Long '*********INVESTIGATE NEED FOR THIS FURTHER
  Public BadBinCnt As Long '***********INVESTIGATE NEED FOR THIS FURTHER
  Public BadVelCount As Long 'how many times has there been bad velocity?
  Public BadVelFlag As Boolean 'indicates there was a data punch with invalid velocity
  Public BadQFlag As Boolean 'indicates there was a data punch with invalid discharge
  Public VMDeadCount As Float 'Number of times VM had bad data
  Public VMRestartAttempts As Long 'how many times has the ADCP tried to restart
  #If UseAutoRange = True Then
    Public RangedBin As Long = 0 'Start point for last bin before surface
    Public DucerDepthOffset As Float 'Difference between depth sensor and transducer face. (Pos/Neg) + if Sensor is higher than ducer, - if lower than ducer
    Public RangeSource As Long 'Sensor Source for ducer depth calculation
    Public CutOffBins As Float 'Number of bins to cut off. Ex. If large bins, may only need to cut off 1, if small bins, may need to cut of multiple
  #EndIf
  Public FlowSign As Long 'Multiplier for velocity depending on which side of the channel instrument is on
  Public UseDir As Boolean 'should user use compass flow direction to indicate flood vs. ebb
  Public PosFlowDir As Float 'compass direction of positive flow (outgoing/ebb)
  Public BinDist(6) As Float: Alias BinDist = StartBin, EndBin, StartEbbBin, EndEbbBin, StartFldBin, EndFldBin 'Bin Distribution
  Public BiRating As Boolean = False 'Use this flag if using Ebb/Flood rating
  Public BiRatOK As Boolean = False 'Used by program to determin if BiRating can be done
  Public UseBiRat As Boolean = False 'flag set if both the above are true
  Public BiRatTran As Float  'Transition velocity for ebb/flood Rating
  #If StoreAllToCard = True Then '**LEFT HEADERS AND NAMES AS PUBLIC UNTIL USAGE VERIFICATION
    Public QueueDQI As Float 'data quality indicator for Queue
    Public RSSIStdNo As Long = 2  ' standard deviations from mean to be counted as spike
    Public CorrStdNo As Long = 2 'These are set to 2 as a start point, PlanCV should help with Vel stddev
    Public VelStdNo As Long = 2
    Public SpikeFileName As String * 64
    Public FileHeader As String * 500
    Public SpikeCounter As Long
    Public SendHeader As Boolean = True
    Public TestTime As String * 20
    Public CardError As String * 25
  #EndIf

  '=============RATING VALUES, MEAN CHANNEL/AREA RATINGS===============================
  '         Made as Arrays in order to more easily call into QAQC table
  Public RatArray(15) As Float: Alias RatArray = StgOffset, StgCoef, StgCoef2, VelOffset, VelCoef, VelCoef2, VelCoef3, UpVelOffset, UpVelCoef, UpVelCoef2, UpVelCoef3, LowVelOffset, LowVelCoef, LowVelCoef2, LowVelCoef3
  'All rating values in single line, Call in table like this: Sample(15,RatArray(),IEEE4)
  Public Trans As String * 4 'Transition point in velocity where iVel calulation decides to use upper or lower rating equation
  '                           Float was used, changed to a 3 character string in case someone accidentally types a number in, this will allow user to revert back to "NAN" -TAV 20141208

  '================== PRESSURE SENSOR/UPBEAM STAGE RELATED ====================
  '        Assume Pressure sensors present with VM, Conditional differently later
  '============================================================================
  Public PSPressPort As Long 'port Pressure sensor 1 is plugged into (3 or 5)
  Public PSPressAddr As Long 'SDI12 address for Pressure sensor 1
  Public PSPressDataIn As Boolean 'are there data from Pressure sensor 1?
  Public PsPress1Stg(2) As Float: Alias PsPress1Stg = PS1RawDepthFt, PS1TempC 'array to hold the values pressure sensor 1 is outputting (temp and feet)
  Public PSpress2Stg(2) As Float: Alias PSpress2Stg = PS2RawDepthFt, PS2TempC 'array to hold values pressure sensor 2 is outputting
  Public PSpress2Port As Long 'port pressure sensor 2 is plugged into (3 or 5)
  Public PSpress2Addr As Long 'SDI12 address for pressure sensor 2
  Public PSpress2DataIn As Boolean 'are there data from pressure sensor 2?
  Public StagePrime As Float 'stage value used in calculating discharge
  Public StageSecnd As Float 'stage value used in calculating stage difference
  Public StgDiff As Float 'absolute value of difference between StagePrime and the user selected instrument stage
  Public UpBeamStg As Float 'stage value (after offset applied) for ADCP vertical beam
  Public VMPressStg As Float 'stage value (after offset applied) for ADCP pressure sensor
  Public PS1Stg As Float 'stage value (after offset applied) for pressure sensor 1
  Public PS2Stg As Float 'stage value (after offset applied) for pressure sensor 2
  '-----WQ Sonde Conditional------
  #If WqSonde <> "NONE" Then
    Public SondeStg As Float 'stage value (after offset applied) for YSI or EXO sonde
  #EndIf
  '-------------------------------
  Public TrueUpBeamStg As Float 'user input stage reference to calculate (and apply) offset to raw upbeam data to output "UpBeamStg"
  Public TrueVMPressStg As Float 'user input stage reference to calculate (and apply) offset to raw ADCP pressure sensor data to output "VMPressStg"
  Public TruePS1Stg As Float 'user input stage reference to calculate (and apply) offset to raw Pressure sensor 1 data to output "PS1Stg"
  Public TruePS2Stg As Float 'user input stage reference to calculate (and apply) offset to raw pressure sensor 2 data to output "PS2Stg"
  '-----WQ Sonde Conditional------
  #If WqSonde <> "NONE" Then
    Public TrueSondeStg As Float 'user input stage reference to calculate (and apply) offset to raw YSI data to output "YsiStg"
  #EndIf
  '--------------------------------
  Dim SelStgPrime As String 'which of the 5 stage options is used to calculate discharge
  Public SelStgSecnd As String 'Which of the 5 stage options is used to calculate stage difference
  Public StgOffsets(4) As Float: Alias StgOffsets = UpBeamOffset, VMPressOffset,PS1Offset,PS2Offset 'Only define 4 in array, do 5th independent if WQ present
  '-----WQ Sonde Conditional---------
  #If WqSonde <> "NONE" Then
    Public SondeOffset As Float'offset applied to raw data to get stage value
  #EndIf
  '----------------------------------
  Public StgSelect As String 'numerical indicator of which instrument is being used to calculate discharge within the datalogger
  Public Area As Float 'calculated channel area based on stage-area rating
  Public StageFlags(6) As Boolean: Alias StageFlags = BadStgFlag, BadStg2Flag, BadPS1Flg, BadPS2Flg, BadUpbeamFlg, BadVMPressFlg
  Public BadStageCounters(12) As Float: Alias BadStageCounters = BadStgCount, BadStg2Cnt, BadPS1Cnt, BadPS2Cnt, BadUpbeamCnt, BadVMPressCnt, BadStgCountTot, BadStg2CntTot, BadPS1CntTot, BadPS2CntTot, BadUpbeamCntTot, BadVMPressCntTot
  Public StgOutOfBndCnt, StgOutOfBndCntTot, Stg2OutOfBndCnt, Stg2OutOfBndCntTot
  Public MaxExpStg As Long 'maximum expected stage <---- GET RID OF THIS, ONLY FILTER IN AQ
  Public MinExpStg As Long 'minimum expected stage <---- GET RID OF THIS, ONLY FILTER IN AQ

  '================== VM COMMAND RELATED ====================================
  Public SentBreak As Boolean 'Testing, Dim when verified. Used to acknowledge a break was sent to make better use of subs
  Public Banner As String * 200 'ADCP response from sending a break
  Public Warning As String * 2000 'echo of ADCP response for anything other than a break
  Public TFEcho As String * 30 'Echo of TF command
  Public TSEcho As String * 30 'Echo of TS command
  Public CSCmd As String * 10 'echo of CS (deploy command) to ensure ADCP deployed properly
  Public CMD As String 'user entered command for the ADCP, ex: make bin size 250cm = "ws250"
  Public SendCMD As Boolean 'after command is input in "CMD" user must turn this to "true" to actually send the command to ADCP
  Public WakeUpVM As Boolean 'send a break/cycle power to ADCP in case it went to sleep. manual switch
  #If GetNoiseFloor = True Then
    Public SendPT3 As Boolean
    Public PT3Time As Float
  #EndIf
  Public VMMemString As String * 200 'response for "get free memory" command
  Public VMLowMem As Boolean 'indicator if ADCP internal  memory is below user threshold
  Public VMLowMemCount As Float 'how many times ADCP internal memory is below user threshold
  Public VMMemFree As Float 'how much internal memory does the ADCP have remaining
  Public VMLowMemVal As Float 'user threshold for "low internal memory"
  Public VMNoMem As Boolean 'flag indicating no internal memory remaining
  Public VMNoMemCount As Float 'how many times has the ADCP had no internal memory remaining
  Public RecErased As Boolean 'flag indicating the internal memory was erased
  Public RecEraseString As String * 200 'echo of response from ADCP when internal memory is erased (also acts as indicator to trigger "RecErased" flag)

  '=================== VARIABLES FOR DATA STORAGE =========================================
  Public IndexVel As Float 'index velocity based on rating, put these in SVMAQ table
  Public MeanVel As Float 'average channel velocity based on all bin data
  Public Qcfs As Float 'total discharge
  Public VMVolts As Float
  Public VMtempC As Float
  Public VMtempF As Float
  Public VMpitch As Float
  Public VMroll As Float
  Public VMupBeam As Float
  Public VMElevation As Float
  Dim VMHeading As Float
  Dim VMpressure As Float
  Dim WHpressure As Float
  Dim V1Avg As Float
  Dim V2Avg As Float
  Dim V3Avg As Float
  Dim V4Avg As Float
  Dim AvgRSSIStartBin As Long
  Dim AvgRSSIEndBin As Long
  Dim AvgSwathRSSI As Float

  '=================== VM TIME RELATED ============================
  Dim ADCPCenterTime As String * 20 'Create timestamp for center of ADCP sample period
  Dim VMTimeString As String * 25 'Used in FTime function to set times for TS and TF as well as spike data
  Dim VMClock(6) As Long: Alias VMClock = VMYear, VMMonth, VMDay, VMHour, VMMinute, VMSecond  'VM Realtime Clock

  '=================================================================
  '---------------- VM DECODING VARIABLES --------------------------
  '=================================================================

  '=================Data Location Offsets ============================
  Dim FixedLeadOffset As Long 'Offset to Fixed Leader
  Dim VarLeadOffset As Long 'Offset to the Variable Leader
  Dim RSSIDatOffset As Long 'Offset to RSSI Data
  Dim CorrDatOffset As Long 'Offset to Correlation Data
  Dim VMStageDatOffset As Long 'Offset to Stage Data
  Dim VelDatOffset As Long 'Offset to Velocity data

  #If VMHasVertical = True Then 'Dim these when we verify they're working properly
    Public VerticalLeadOffset As Long
    Public VerticalVelocityOffset As Long
    Public VerticalRSSIOffset As Long
    Public VerticalCorrOffset As Long
  #EndIf
  #If VMHasBottomTrack = True Then
    Public BtmTrackOffset As Long
  #EndIf

  '====== Placeholders for Processing and Offset Determination ==========
  Dim LongArray(2000) As Long 'Array to hold raw ensemble bytes
  Dim Nums(2) As Long
  Dim DataTypes As Long
  Dim IDWords(14) As Long
  Dim Offsets(40) As Long 'Offsets for start of each data type location
  Dim NumbytesZero As Long
  Dim TempL As Long
  Dim MSB As Long
  Dim MSB1 As Long
  Dim LSB As Long
  Dim ReceivedBytes As Long
  Dim TempID As Long 'Testing
  Dim Bin As Long 'Bins Counters
  Dim Beam As Long 'Beams counter
  Dim Temp As Long
  Dim Index As Long
  Dim BinVel As Float
  Dim Binstep As Long
  Dim EnsBin As Long

  '============= VARIABLES USE FOR LOOP TO PULL DATA FROM ADCP SERIAL PORT =============
  Dim ADCPLoop As Float 'Counter for looping attempts, localize to sub?
  Dim ADCPDone As Boolean 'Flag to indicate we have all data, localize to sub?
  Dim InCount As Long 'Dim in ADCP Loop Sub? This will make it local to that sub, not used anywhere else
  Dim SubScans As Long 'Number of loop attempts to get serial data from ADCP, Sample this?

  '========================= BIN VELOCITY ARRAYS =============================
  Dim EnsVelocity (MaxBins,4) As Float 'Velocity for Max bins defined in custom constants, 4 beams
  Dim V1(MaxBins) As Float 'Beam 1, X, or East Velocity, depending on coodinate system
  Dim V2(MaxBins) As Float 'Beam 2, Y, or North Velocity, depending on coordinate system
  Dim V3(MaxBins) As Float 'Beam 3, Z, or UP velocity, depending on coordinate system
  Dim V4(MaxBins) As Float 'Beam 4, or Error velocity, depending on coordinate system
  Dim VMBinVel(MaxBins) As Float 'Values used for rating calc (base on bin distribution).
  'These are processed values, if UseV2 = True, then VMBinVel = SQRT((V1)^2 + (V2)^2), Else VMBinVel = V1
  Dim V1Disable(MaxBins) As Boolean 'Disable Variables for storing averages in tables
  Dim V2Disable(MaxBins) As Boolean
  Dim V3Disable(MaxBins) As Boolean
  Dim V4Disable(MaxBins) As Boolean
  Dim VmBinVelDisable(MaxBins) As Boolean

  #If VMHasVertical Then 'Keep these public until verification
    Public VerticalVelocity(MaxBins) As Float
    Public VerticalRSSI(MaxBins) As Long
    Public VerticalCorr(MaxBins) As Long
    Public VerticalBinDisable(MaxBins) As Boolean
  #EndIf

  #If VMHasBottomTrack Then
    Public BtmTrackRange(MaxBeams) As Float
    Public BtmTrackVelocity(MaxBeams) As Float
    Public BtmTrackRSSI(MaxBeams) As Long
    Public BtmTrackCorr(MaxBeams) As Long
    Public BtmRangeBeamDisable(MaxBeams) As Boolean
    Public BtmVelBeamDisable(MaxBeams) As Boolean
  #EndIf

  '================= Velocity Averaging Variables =============================
  Dim V1Sum As Float 'sum of bins in each ensemble for V1
  Dim V1EbbSum As Float ' sum of bins in each ensemble for V1 in positive dir
  Dim V1FldSum As Float ' sum of bins in each ensemble for V1 in Neg dir
  Dim V2Sum As Float 'sum of bins in each ensemble for V2
  Dim V2EbbSum As Float ' sum of bins in each ensemble for V2 in positive dir
  Dim V2FldSum As Float ' sum of bins in each ensemble for V2 in Neg dir
  Dim V3Sum As Float 'sum of bins in each ensemble for V3
  Dim V4Sum As Float 'sum of bins in each ensemble for V4
  Dim V1EbbAvg As Float 'average of bins in each ensemble for V1 for pos dir
  Dim V2EbbAvg As Float 'average of bins in each ensemble for V2 for pos dir
  Dim V1FldAvg As Float 'average of bins in each ensemble for V1 for Neg dir
  Dim V2FldAvg As Float 'average of bins in each ensemble for V2 for Neg dir
  Dim Cnt As Long
  Dim V1EbbCnt As Long
  Dim V2EbbCnt As Long
  Dim V1FldCnt As Long
  Dim V2FldCnt As Long
  Dim V1Cnt As Long
  Dim V2Cnt As Long
  Dim V3Cnt As Long
  Dim V4Cnt As Long

  '========================= RSSI Data Variables ==============================
  Dim ensRSSI(MaxBins,4) As Long  'MaxBins bins and 4 beams max  RSSI Data
  Dim nRSSI As Long 'for RSSI average calc
  Dim AccumRSSI As Long 'for RSSI average calc
  Dim AvgRSSI(MaxBins) As Long 'average of all beams for that bin per ensemble
  Dim AvgRSSIcounter As Long
  Dim AvgRSSIAccum As Long

  '======================== Correlation Data Variables =========================
  Dim ensCorr(MaxBins,4) As Long '25 bins and 4 beams max Correlation Data
  Dim nCorr As Long
  Dim AccumCorr As Long
  Dim AvgCorr(MaxBins) As Long 'average of all beams for that bin per ensemble

  '=====================VM Stage Data Variables ===========================
  Dim DepthMSB As Long 'debugging variables
  Dim DepthMSB1 As Long'debugging variables
  Dim DepthLSB As Long'debugging variables
  Dim DepthLSB1 As Long'debugging variables
  Dim LSBTemp As Long
  Dim LSB1Temp As Long
  Dim MSBTemp As Long
  Dim MSB1Temp As Long
  Dim L1SB As Long
  Dim M1SB As Long
  Dim TempM As Float
  Dim VMTemp As Long 'temporary debugging variable
  Dim VMPSTemp As Long 'temporary debugging variable
  Dim WHPSTemp As Float 'for workhorse pressure
  Dim WHTempM As Float
  Dim WHTempK As Float

  '==================== VM/PS SERIAL NUMBER VARIABLES =========================
  Dim ADCPSN01 As Long
  Dim ADCPSN02 As Long
  Dim ADCPSN03 As Long
  Dim ADCPSN04 As Long
  Dim InitialAdcpSN As Long
  Dim InitialPS1SN As String * 40 'used to hold the previous day's serial number and flag it if the instrument has changed
  Dim InitialPS2SN As String * 40 'used to hold the previous day's serial number and flag it if the instrument has changed

  '==================== NOISE FLOOR VARIABLES ==============================
  #If GetNoiseFloor = True Then
    Dim PT3String As String * 2000
    Dim NoiseFlrParsed As String * 105 '"RSSI Noise Floor" pasrsed from PT3 Command
    Dim FilterString As String * 5 'Holds string that the "InStr" instruction searches for
    Dim StartString 'Holds value for where "RSSI" begins in the PT3 command string
    Dim NoiseHGainW(4) 'array to hold values for each beam's "High Gain, WideBandwidth" Noise Floor
    Dim NoiseLGainW(4) 'Array to hold values for each beam's "Low Gain, WideBandwidth" Noise Floor
    Dim NoiseHGainN(4) 'Array to hold values for each beam's "High Gain, Narrow Bandwidth" noise floor
    Dim NoiseLGainN(4) 'Array to hold calues for each beam's "Low Gain, Narrow Bandwidth" noise floor
  #EndIf

  '==================== STORING SPIKES TO CARD ===============================
  #If StoreAllToCard = True Then
    Dim RSSIspike(MaxBins,4,16) As Float 'array to hold RSSI data Queue
    Dim Corrspike(MaxBins,4,16) As Float 'array to hold Correlation data Queue
    Dim Velspike(MaxBins,4,16) As Float 'array to hold Velocity data Queue
    Dim StageSpike(16) As Float 'array to hold Stage data Queue
    Dim FileHandle As Long
    Dim CardBadCount
    Dim CardOkCount
  #EndIf

  '======================= COMMUNICATIONS ===================================
  '           Used to set Comms mode on CR6
  Dim UseCommsZeroForADCP As Boolean 'Used to set proper comms more when ComC1 or ComC3 are used on CR6

  '================= VM DEBUGGING TIMER VARIABLES ===========================
  Dim WakeVMTimer(3): Alias WakeVMTimer = WakeVMStart, WakeVMEnd, WakeVMTotTime 'Timers for "WakeVM" sub
  Dim VMLoopTimer(3): Alias VMLoopTimer = VMLoopStart, VMLoopEnd, VMLoopTotTime 'Timers for pulling ADCP Serial data
  Dim ZeroVMTimer(3): Alias ZeroVMTimer = ZeroVMTimeStart, ZeroVMTimeEnd, ZeroVMTotTime 'Timers for zeroing VM arrays
  Dim CheckSumTimer(3): Alias CheckSumTimer =ChkSumChkStart, ChkSumChkEnd, ChkSumChkTotTime 'Timers for calculating check sum
  Dim MainDecodeTimer(3): Alias MainDecodeTimer = MainDecodeStart, MainDecodeEnd, MainDecodeTotTime 'Timers for main decode process
  Dim OneMinCalcTimer(3): Alias OneMinCalcTimer = OneMinCalcStart, OneMinCalcEnd, OneMinCalcTotTime 'Timers for calculating 1min averages over bins
  Dim VMMemTimer(3): Alias VMMemTimer = GetVMMemStart, GetVMMemEnd, GetVMMemTotTime 'Timers for checking WH memory
  Dim VMProcTimer(3): Alias VMProcTimer = VMTimeStart, VMTimeEnd, VMTotTime 'Timers for VM total processing
  Dim BeamChkTimer(3): Alias BeamChkTimer = CallBmChkStart, CallBmChkEnd, CallBmChkTotTime 'Timers for calling/storing BeamCheck table
  Dim CalcQTimer(3): Alias CalcQTimer = CalcQStart, CalcQEnd, CalcQTotTime 'Timers for Q calculations
  Dim GetStgTimer(3): Alias GetStgTimer = GetStgStart, GetStgEnd, GetStgTotTime 'Get Stage timers
  Dim PSTimer(6): Alias PSTimer = GetPS1Start, GetPS1End, GetPS1Tot, GetPS2Start, GetPS2End, GetPS2Tot 'Pressure sensor timers
  Dim SetTFTimer(3): Alias SetTFTimer = SetTFStart, SetTFEnd, SetTFTotTime
  Dim SetTSTimer(3): Alias SetTSTimer = SetTSStart, SetTSEnd, SetTSTotTime
  #If UseAutoRange = True Then
    Dim CalcRangeTimer(3): Alias CalcRangeTimer = CalcRangeStart, CalcRangeEnd, CalcRangeTotTime 'Timers for calculating last bin for uplookers
  #EndIf
  #If StoreAllToCard = True Then 'Timers for checking spikes on Vel, RSSI, and Corr and storing to memory card
    Dim StoreToCrdTimer(3): Alias StoreToCrdTimer = StoreToCrdStart, StoreToCrdEnd, StoreToCrdTotTime
    Dim ChkSpikeTimer(3): Alias ChkSpikeTimer = ChkSpikeStart, ChkSpikeEnd, ChkSpikeTotTime
    Dim AddSpikeTimer(3): Alias AddSpikeTimer = AddSpikeStart, AddSpikeEnd, AddSpikeTotTime
  #EndIf
#EndIf 'If HasVM = True

'=================================================================================================
'--------------------- DECLARE WQ SPECIFIC VARIABLES ---------------------------------------------
'=================================================================================================
#If WqSonde <> "NONE" Then
  Const WqNParams = 24 'Define Number of Parameters


  '---------------- Build Arrays and "In-Strings" ----------------------------------------
  ' Change to Dim after Testing
  Public WqIn As String * 256 'raw EXO String
  Public WqDelay As Long 'Placerholder for response from twipeb
  Public WipeTime As String * 25 'Time/Date wiper wipes (from datalogger timestamp)
  Public WipeFlag As Boolean 'flag to initiate wipe
  Public OldEXOTime As Long
  Public EXOTimeString As String * 20
  Public WqError As Boolean
  Public WqDead As Boolean
  Public WqBadData As Boolean
  Public WqErrCount As Long
  Public WqTotErrs As Long 'Count for total daily errors
  Public WqPwrCycleWait As Long
  Public WqPwrCycleTries As Long
  Public WqManualCycle As Boolean
  Public WqElevation As Float
  Public WqData(WqNParams)
  Public WqParamOrder(WqNParams)
  Public WqBytes As Long
  #If TopBottom = True Then
    Public BtmWqIn As String * 256 'Raw string for bottom exo
    Public BtmWqDelay As Long 'Placeholder for response from bottom's twipeb
    Public BtmWipeTime As String * 25 'Bottom wipe date/time from logger
    Public BtmWipeFlag As Boolean 'flag to initiate bottom wipe
    Public BtmOldEXOTime As Long
    Public BtmWqError As Boolean
    Public BtmWqDead As Boolean
    Public BtmWqBadData As Boolean
    Public BtmWqErrCount As Long
    Public BtmWqTotErrs As Long 'Count for total daily errors
    Public IsBtmWqNClosed As Boolean
    Public BtmWqPwrCycleWait As Long
    Public BtmWqPwrCycleTries As Long
    Public BtmWqManualCycle As Boolean
    Public BtmWqElevation As Float
    Public BtmWqData(WqNParams)
    Public BtmWqParamOrder(WqNParams)
    Public BtmWqBytes
  #EndIf
  Public WqLocs(WqNParams): Alias WqLocs = WqLocDate, WqLocTime, WqLocTempC, WqLocTempF, WqLocSpCond, WqLocTurbFNU, WqLocBatt, WqLocDOSat, WqLocDOmgL, WqLocDepthFt, WqLocDepthM, WqLocpH, WqLocpHmV, WqLocChlugL, WqLocChlRFU, WqLocBGApcRFU, WqLocBGApcugL, WqLocFDomRFU, WqLocFDomQSU, WqLocORPmV, WqLocNH4mgL, WqLocNO3mgL, WqLocCLmgL, WqLocWiperPos
  #If TopBottom = True Then
    Public BtmWqLocs(WqNParams): Alias BtmWqLocs = BtmWqLocDate, BtmWqLocTime, BtmWqLocTempC, BtmWqLocTempF, BtmWqLocSpCond, BtmWqLocTurbFNU, BtmWqLocBatt, BtmWqLocDOSat, BtmWqLocDOmgL, BtmWqLocDepthFt, BtmWqLocDepthM, BtmWqLocpH, BtmWqLocpHmV, BtmWqLocChlugL, BtmWqLocChlRFU, BtmWqLocBGApcRFU, BtmWqLocBGApcugL, BtmWqLocFDomRFU, BtmWqLocFDomQSU, BtmWqLocORPmV, BtmWqLocNH4mgL, BtmWqLocNO3mgL, BtmWqLocCLmgL, BtmWqLocWiperPos
  #EndIf
  Public WqDataArray(WqNParams): Alias WqDataArray = WqDate, WqTime, WqTempC, WqTempF, WqSpCond, WqTurbFNU, WqBatt, WqDOSat, WqDOmgL, WqDepthFt, WqDepthM, WqpH, WqpHmV, WqChlugL, WqChlRFU, WqBGApcRFU, WqBGApcugL, WqFDomRFU, WqFDomQSU, WqORPmV, WqNH4mgL, WqNO3mgL, WqCLmgL, WqWiperPos
  #If TopBottom = True Then
    Public BtmWqDataArray(WqNParams): Alias BtmWqDataArray = BtmWqDate, BtmWqTime, BtmWqTempC, BtmWqTempF, BtmWqSpCond, BtmWqTurbFNU, BtmWqBatt, BtmWqDOSat, BtmWqDOmgL, BtmWqDepthFt, BtmWqDepthM, BtmWqpH, BtmWqpHmV, BtmWqChlugL, BtmWqChlRFU, BtmWqBGApcRFU, BtmWqBGApcugL, BtmWqFDomRFU, BtmWqFDomQSU, BtmWqORPmV, BtmWqNH4mgL, BtmWqNO3mgL, BtmWqCLmgL, BtmWqWiperPos
  #EndIf
  #If WqSonde = "WQ_SERIAL_BURST" Then
    Public BurstMaxErrCnt = 4 '<-----------ESTABLISH FIXED VALUE FOR THIS
    Public BurstIn As String * 200
    Public BurstCount As Long
    Public RecBurstFlag As Boolean
    Public GetBurst As Boolean
    Public BurstMissed As Boolean
    Public TotalBurstVals
    Public BurstErrCnt
    Dim BurstData(WqNParams) 'Array to hold data until moved to proper location
    Dim BurstArray(MaxBurstCnt,WqNParams) 'Multi-dimensioned array used to loop through and parse burst data
    Public WqBurstData(WqNParams): Alias WqBurstData = BurstDate, BurstTime, BurstTempC, BurstTempF, BurstSpCond, BurstTurbFNU, BurstBatt, BurstDOSat, BurstDOmgL, BurstDepthFt, BurstDepthM, BurstpH, BurstpHmV, BurstChlugL, BurstChlRFU, BurstBGApcRFU, BurstBGApcugL, BurstFDomRFU, BurstFDomQSU, BurstORPmV, BurstNH4mgL, BurstNO3mgL, BurstCLmgL, BurstWiperPos
    Public MedBurstData(WqNParams): Alias MedBurstData = MedBurstDate, MedBurstTime, MedTempC, MedTempF, MedSpCond, MedTurbFNU, MedBatt, MedDOSat, MedDOmgL, MedDepthFt, MedDepthM, MedpH, MedpHmV, MedChlugL, MedChlRFU, MedBGApcRFU, MedBGApcugL, MedFDomRFU, MedFDomQSU, MedORPmV, MedNH4mgL, MedNO3mgL, MedCLmgL, MedWiperPos
    #If TopBottom = True Then
      Public BtmBurstCount As Long
      Public BtmRecBurstFlag As Boolean
      Public BtmBurstMissed As Boolean
      Public BtmTotalBurstVals
      Public BtmBurstErrCnt
      Dim BtmBurstData(WqNParams) 'Array to hold data until moved to proper location
      Dim BtmBurstArray(MaxBurstCnt,WqNParams) 'Multi-dimensioned array used to loop through and parse burst data
      Public WqBtmBurstData(WqNParams): Alias WqBtmBurstData = BtmBurstDate, BtmBurstTime, BtmBurstTempC, BtmBurstTempF, BtmBurstSpCond, BtmBurstTurbFNU, BtmBurstBatt, BtmBurstDOSat, BtmBurstDOmgL, BtmBurstDepthFt, BtmBurstDepthM, BtmBurstpH, BtmBurstpHmV, BtmBurstChlugL, BtmBurstChlRFU, BtmBurstBGApcRFU, BtmBurstBGApcugL, BtmBurstFDomRFU, BtmBurstFDomQSU, BtmBurstORPmV, BtmBurstNH4mgL, BtmBurstNO3mgL, BtmBurstCLmgL, BtmBurstWiperPos
      Public BtmMedBurstData(WqNParams): Alias BtmMedBurstData = BtmMedBurstDate, BtmMedBurstTime, BtmMedTempC, BtmMedTempF, BtmMedSpCond, BtmMedTurbFNU, BtmMedBatt, BtmMedDOSat, BtmMedDOmgL, BtmMedDepthFt, BtmMedDepthM, BtmMedpH, BtmMedpHmV, BtmMedChlugL, BtmMedChlRFU, BtmMedBGApcRFU, BtmMedBGApcugL, BtmMedFDomRFU, BtmMedFDomQSU, BtmMedORPmV, BtmMedNH4mgL, BtmMedNO3mgL, BtmMedCLmgL, BtmMedWiperPos
    #EndIf 'if we are using top bottom
  #EndIf 'If we are using serial burst
  '---------------- STANDARD WQ PUBLICS ---------------------------------
  Public Redeploy As Boolean 'Initialize sequence to identify parameter order <- should this be put with other Triggers/flags?
  Public IsWqNClosed As Boolean 'Is the SOA on a Normally closed relay
  #If TopBottom = True Then
    Public BtmRedeploy As Boolean
  #EndIf
  Public NoSondeTrig As Float 'variable to hold value when looking for "No Sonde"
  #If TopBottom = True Then
    Public BtmNoSondeTrig As Float 'Need separate value to check second sonde independently
  #EndIf
  #If LoggerType = CR6 Then
    Public WqUseCPort As Boolean
    Public UseCommsOneForSonde As Boolean
    Public UseCommsZeroForSonde As Boolean
    #If TopBottom = True Then
      Public BtmWqUseCPort As Boolean
      Public UseCommsOneForBtmSonde As Boolean
      Public UseCommsZeroForBtmSonde As Boolean
    #EndIf
  #EndIf

  '====================== WQ DEBUG TIMERS ====================================
  Dim RedeployTimer(3): Alias RedeployTimer = RedeployStart, RedeployEnd, RedeployTot
  Dim GetWqTimer(3): Alias GetWqTimer = GetWqStart, GetWqEnd, GetWqTot
  #If TopBottom = True Then
    Dim BtmRedeployTimer(3): Alias BtmRedeployTimer = BtmRedeployStart, BtmRedeployEnd, BtmRedeployTot
    Dim BtmGetWqTimer(3): Alias BtmGetWqTimer = BtmGetWqStart, BtmGetWqEnd, BtmGetWqTot
  #EndIf
  #If WqSonde = "WQ_SERIAL_BURST" Then
    Dim SetBurstTimer(3): Alias SetBurstTimer = SetBurstStart, SetBurstEnd, SetBurstTot
    Dim FillBurstTimer(3): Alias FillBurstTimer = FillBurstStart, FillBurstEnd, FillBurstTot
    Dim ProcBurstTimer(3): Alias ProcBurstTimer = ProcBurstStart, ProcBurstEnd, ProcBurstTot
    #If TopBottom = True Then
      Dim BtmSetBurstTimer(3): Alias BtmSetBurstTimer = BtmSetBurstStart, BtmSetBurstEnd, BtmSetBurstTot
      Dim BtmFillBurstTimer(3): Alias BtmFillBurstTimer = BtmFillBurstStart, BtmFillBurstEnd, BtmFillBurstTot
      Dim BtmProcBurstTimer(3): Alias BtmProcBurstTimer = BtmProcBurstStart, BtmProcBurstEnd, BtmProcBurstTot
    #EndIf
  #EndIf
#EndIf 'If has a sonde

#If HasSuna = True Then
  Public SampleSuna As Boolean 'Trigger to say when it's time to sample/turn on the SUNA
  Public SunaReady As Boolean 'Trigger to say when the SUNA is warmed up
  Public SunaMissedCnt 'Counter for when the SUNA missed (Either DarkFrame, or no data)
  Public LFrameCnt
  Public DFrameCnt
  Public BadSunaVals
  Dim SunaMissed As Boolean 'Trigger to Exit DoLoop if the we missed SUNA data
  Dim SunaOnTime 'How long was the SUNA powered
  Dim SunaSampleStart 'How long into the scan did the Suna Sampling Start
  Dim SunaStringLen(MaxSunaBurst) 'Length of the String read in
  Dim LocLF 'Variable to store where the L occurs in the string
  Dim LFrame As Boolean 'Used to trigger the Exit out of the DoLoop so we only get Light Frames
  Dim LocDF 'Variable to Store where D occurs in the string
  Dim DFrame As Boolean 'Used to exit DoLoop if Dark Frame was present
  Public LampWarn As Boolean
  Public MemWarn As Boolean
  Public LocSunaProb As Float
  Public SunaWarning As String * 200
  Dim LFrameThreshold As Long = 30 'Number of Light Frames wanted for Calculations
  Dim SunaHeader As String * 7
  Dim SunaSN 'Suna Parameters
  Dim SunaSampleTime
  Dim SunaNitrateuM
  Dim SunaNitratemgL
  Dim SunaFittingResult
  Dim A254
  Dim A350
  Dim TLamp
  Dim TSpec
  Dim SunaLampTime
  Dim SunaHumid
  Dim SunaSpecAve
  Dim SunaDarkAve
  Dim SunaVoltMain
  Dim SunaVoltLamp
  Dim SunaTimer 'Timer Name for specifying when to power the SUNA and Wiper
  Dim WipeSuna As Boolean 'Is it time to wipe?
  Dim RecSunaData As Boolean 'Flag to Trigger the SunaStats table
  Dim AvgSunaNitrateuM 'Variables to copy from SunaStats to variables, then "Sample" the stats in AQ table
  Dim MedSunaNitrateuM
  Dim StdSunaNitrateuM
  Dim AvgSunaNitratemgL
  Dim MedSunaNitratemgL
  Dim StdSunaNitratemgL
  Dim AvgSunaFittingResult
  Dim StdSunaFittingResult
  Dim MedA254
  Dim MedA350
  Dim AvgSunaDarkAve
  Dim AvgSunaSpecAve
  Dim AvgTSpec
  Dim AvgTLamp
  Dim AvgSunaHumid
  Dim AvgSunaLampTime
  Dim AvgSunaVoltMain
  Dim AvgSunaVoltLamp
  Dim LFHeader(MaxSunaBurst) As String
  Dim RawHeader(MaxSunaBurst) As String
  Dim SSN 'Location definitions used to parse data to correct locations
  Dim SST
  Dim SNuM
  Dim SNmgL
  Dim SFR
  Dim STL
  Dim STS
  Dim SLT
  Dim SH
  Dim SSA
  Dim SDA
  Dim SVL
  Dim SVM
  Dim SA254
  Dim SA350
  Dim SunaBurstIn As String * 2000 'String to read the data in from the Suna
  Dim RawSunaArray(MaxSunaBurst,282) As String'Multi-dimension array to store the MaxSunaBurst number of values
  Dim GoodSunaArray(MaxSunaBurst,282) As String
  Dim SunaBurstData(282) As String 'Parsed data per single sample
  Dim SpectrumData(256) 'Raw Spectrum data parsed from full array
  Dim mCount 'counters for loops
  Dim nCount
  Dim oCount
  Dim SunaSampleTimer 'Timer names to know when Suna is ready or wipes
  Dim SunaWipeTimer
  Dim WipeStart 'Start time (within the minute) of the wipe
  Dim StartWipe As Boolean 'Trigger to start the wipe
  Dim WipeEnd 'End time of the wipe (when the port gets switched off)
  Dim SunaWipeTotTime 'Total time it took for port to turn on/off
  Dim SunaWipeTime As String * 25
  Dim SunaProcessStart 'Start time of tables being written (within the minute, not Actual timestamp
  Dim SunaProcessEnd 'End time of tables being written
  Dim SunaProcessTotTime 'Total time for tables to be written
#EndIf 'if HasSuna

'=========================================================================================================
'------------------------------------- MODEM DIM VARIABLES -----------------------------------------------
'=========================================================================================================
#If HasModem = True Then
  Dim ModemScans As Long
  Public ModemWorks As Boolean 'Set to dim after verification
  Dim ModemFailure As Boolean
  Public PingResp As Long 'Response time for pinging google.com
#EndIf

'==========================================================================================================
'---------------------------------- RADIO NETWORK VARIABLES -----------------------------------------------
'==========================================================================================================
#If RadioNetwork = True Then
  #If IsMaster = True Then
    #If NetworkSlaves = 1 Then 'Declare how many nodes are in the system with conditional compile
      Public NeighborApb = 3 'PakBus address of Node "A"
      Public NeighborASecCode = "0000" 'Security code of neighbor A (use "0000" if no security code is set)
    #ElseIf NetworkSlaves = 2 Then
      Public NeighborApb = 3
      Public NeighborASecCode = "0000"
      Public NeighborBpb = 4 'PakBus address of Node "B"
      Public NeighborBSecCode = "0000" 'Security code of neighbor B (use "0000" if no security code is set)
    #ElseIf NetworkSlaves = 3 Then
      Public NeighborApb = 3
      Public NeighborASecCode = "0000"
      Public NeighborBpb = 4
      Public NeighborBSecCode = "0000"
      Public NeighborCpb = 5 'PakBus address of Node "C"
      Public NeighborCSecCode = "0000" 'Security code of neighbor C (use "0000" if no security code is set)
    #ElseIf NetworkSlaves = 4 Then
      Public NeighborApb = 3
      Public NeighborASecCode = "0000"
      Public NeighborBpb = 4
      Public NeighborBSecCode = "0000"
      Public NeighborCpb = 5
      Public NeighborCSecCode = "0000"
      Public NeighborDpb = 6 'PakBus address of Node "D"
      Public NeighborDSecCode = "0000" 'Security code of neighbor D (use "0000" if no security code is set)
    #EndIf 'number of nodes declarations
  #ElseIf IsMaster = False Then 'if it's part of a radio network but not the master datalogger
    Public MasterPB = 2 'PakBus address of master datalogger
    Public MasterSecCode = "0000" 'security code of master datalogger
  #EndIf 'Master/Slave declaration
#EndIf 'radio network declaration
' Declare placeholders for all RF451 Settings
#If RadioNetwork = True Then
  Public ReadRadSettings As Boolean 'Trigger to read in radio settings
  Public SetRadSettings As Boolean 'Trigger to reset radio settings
  Public SetRadToDefault As Boolean 'Trigger to Reset radio to factory defaults
  Public RadOn As Long 'Radio Enabled (0= False, 1 = True)
  Public RadOpMode As Long 'Operation mode (Point to Multipoint Master = 2, Point to Multipoint Slave = 3, Point to Multipoint Repeater = 7)
  Public RadFreqKey As Long  'Frequency Key (Min = 0, Max = 14)
  Public RadMaxPacket As Long '(Min = 0, Max = 9)
  Public RadMinPacket As Long '(Min = 0, Max = 9)
  Public RadDataRate As Long '(3 = Normal 115Kbps, 2 = High 153Kbps)
  Public RadTxPwr As Long 'Transmit power, 0=min, 10=max)
  Public RadRetryTO As Long 'Retry timeout, sets delay the radio will wait before dropping the connection to a master or repeater (factory=255 (if 1 in 255 packets is successful, link is maintained, Min = 8, Max = 255)
  Public RadLowPwr As Long 'Sets how many "slots" the transceiver sleeps (min = 2, max = 31)
  Public RadRepeaters As Long 'Are repeaters used in system (0 = no repeaters, 1 = repeaters used)
  Public RadPacketRepeat As Long 'hOw many times is the packet transmitted? (min= 0 (1 transmission), max = 9 (10 transmissions))
  Public RadSlaveRetry As Long 'How many times should the slave retrasmit a packet to master? (min = 0, max =9)
  Public RadFreqRepeat As Long '0 = Use Master Freq Key, 1= Use Repeater Freq Key
  Public RadSlaveRepeat As Long '0 = Normal, 1 = Enable Slave/Repeater
  Public RadRxSubID As Long 'Min = 0, Max = 15
  Public RadTxSubID As Long 'Min = 0, Max = 15
  Public RadNetID As Long 'Network ID, Min= 0, Max = 4095

  #If IsMaster = False Then 'If Not master then define Reset Slave
    Public ResetSlave As Boolean 'Set to true (automatically or manually) to reset the slave radio
    Public MasterReceive As Float 'Variable to store value from the master datalogger
    Public GetResult As Float 'was the communication successful (0 = successful)
    Public GetFailCnt As Float 'counter for how many times communications have failed
    Public MaxGetFails = 5 'threshold for how many times comms can fail before resetting the radio
    Public LinkDead As Boolean 'flag to indicate the link is considered dead (counter exceeded threshold)
  #EndIf

  Public ResetTried As Boolean 'indicates whether a reset of the radio was attempted
  Public NextTryCnt As Float 'counter to see how long it's been since last reset
  Public MaxNextTryCnt = 10 'user threshold for how long to wait between reset attempts
  Public ResetTryOK As Boolean 'flag to tell logger enough time passed to try a reset again. Set to True on Compile, then to false once a reset has been tried
  Public RadResetAttempts As Float 'how many times has the radio attempted a reset?

  Const MaxLinksDeadCnt = 10 'max number of times all links can be dead before a reset is attempted.
#EndIf 'If Radio Network
'Declare variables based on if the logger is in a radio network and whether it's the master in the network or not.
#If IsMaster = True AND RadioNetwork = True Then
  #If NetworkSlaves > 0 Then
    Public AllLinksDead As Float 'counter to record how many times all links have been dead
    Public SendToNetwork As Float 'Placeholder variable to send to the network, used to get response from loggers whether communication is successful or not
    Public ResetMaster As Boolean
    #If NetworkSlaves = 1 Then 'if there is only one node in the network (Simple Master/Slave communication, 2 dataloggers in network, 1 master, 1 slave)
      Public SendToAresult As Float 'Result of whether the SendVariable worked or not (cue for if comms were successful)
      Public SendToAFailCnt As Float 'count for how many times the comms have failed
      Public MaxAFails = 5 'max number of times comms can fail before resetting itself
      Public LinkToAdead As Boolean 'is the link to SlaveX considered dead (counter exceeds threshold)
    #ElseIf NetworkSlaves = 2 Then 'if there are two nodes in the network (both communicating directly through master, 3 dataloggers in network, 1 master, 2 slaves)
      Public SendToAresult As Float
      Public SendToAFailCnt As Float
      Public MaxAFails = 5
      Public LinkToAdead As Boolean
      Public SendToBresult As Float
      Public SendToBFailCnt As Float
      Public MaxBFails = 5
      Public LinkToBdead As Boolean
    #ElseIf NetworkSlaves = 3 Then 'if there are three nodes in the network (all three communicating directly through master, 4 dataloggers in network, 1 master, 3 slaves)
      Public SendToAresult As Float
      Public SendToAFailCnt As Float
      Public MaxAFails = 5
      Public LinkToAdead As Boolean
      Public SendToBresult As Float
      Public SendToBFailCnt As Float
      Public MaxBFails = 5
      Public LinkToBdead As Boolean
      Public SendToCresult As Float
      Public SendToCFailCnt As Float
      Public MaxCFails = 5
      Public LinkToCdead As Boolean
    #ElseIf NetworkSlaves = 4 Then 'if there are four nodes in the network (all four communicating directly through master 5 dataloggers in network, 1 master, 4 slaves)
      Public SendToAresult As Float
      Public SendToAFailCnt As Float
      Public MaxAFails = 5
      Public LinkToAdead As Boolean
      Public SendToBresult As Float
      Public SendToBFailCnt As Float
      Public MaxBFails = 5
      Public LinkToBdead As Boolean
      Public SendToCresult As Float
      Public SendToCFailCnt As Float
      Public MaxCFails = 5
      Public LinkToCdead As Boolean
      Public SendToDresult As Float
      Public SendToDFailCnt As Float
      Public MaxDFails = 5
      Public LinkToDdead As Boolean
    #EndIf 'node declarations
    ' #EndIf
    '      #ElseIf IsMaster = False AND RadioNetwork = True Then 'if the datalogger is in the network, but not the master
    '        Public MasterReceive As Float 'Variable to store value from the master datalogger
    '        Public GetResult As Float 'was the communication successful (0 = successful)
    '        Public GetFailCnt As Float 'counter for how many times communications have failed
    '        Public MaxGetFails = 5 'threshold for how many times comms can fail before resetting the radio
    '        Public LinkDead As Boolean 'flag to indicate the link is considered dead (counter exceeded threshold)
  #EndIf
#EndIf

'If we are using iridium declare the appropriate variables based on the type of water quality being collected
#If HasIridium=True Then
  'Iridium Radio Variables

  #If WqSonde <> "NONE" Then
    #If TopBottom = False Then
      Const IridiumVars = 14'need 14 places in the array for extra water quality parameters
    #Else
      Const IridiumVars = 16
    #EndIf
  #Else
    Const IridiumVars = 8'base array only need 8 for stage and ADVM data
  #EndIf

  Public IridiumOutArray(IridiumVars)

  'always will be used
  Public StationVolts_IRD
  Public AvgPS1Stg_IRD
  Public AvgPS2Stg_IRD
  Public AvgUpBeamStg_IRD
  Public AvgIndexVel_IRD
  Public AvgVMTemp_IRD
  Public AvgVMPitch_IRD
  Public AvgVMRoll_IRD

  #If WqSonde = "WQ_SERIAL_BURST" Then 'burst WQ variables
    Public MedBurstDate_IRD
    Public MedBurstTime_IRD
    Public MedTempC_IRD
    Public MedSpCond_IRD
    Public MedTurbFNU_IRD
    #If TopBottom = False Then
      Public WqBattV_Min_IRD
    #Else
      Public BtmMedTempC_IRD
      Public BtmMedSpCond_IRD
      Public BtmMedTurbFNU_IRD
    #EndIf
  #EndIf

  #If WqSonde = "WQ_SERIAL" Then 'non-burst WQ variables
    Public WqDate_IRD
    Public WqTime_IRD
    Public WqTempC_IRD
    Public WqSpCond_IRD
    Public WqTurbFNU_IRD
    #If TopBottom = False Then
      Public WqBattV_Min_IRD
    #Else
      Public BtmTempC_IRD
      Public BtmSpCond_IRD
      Public BtmTurbFNU_IRD
    #EndIf
  #EndIf

#EndIf

#If HasHMS = True Then
  Public WeBad As Boolean
  Public HMS_VMcount, HMS_WQcount, HMS_BtmWQCount, HMS_ModCount 'counters
  Public HMS_VMFlag, HMS_WqFlag, HMS_BtmWqFlag, HMS_ModFlag As Boolean
  Public HMS_24hrcount 'count to prevent multiple HMS attempts back to back
  Public HMS_BadThresh 'small thresholds to notify something's wrong
  Public VM_Thresh, WQ_Thresh, BtmWqThresh, Mod_Thresh '"big" thresholds to cycle HMS
#EndIf

Public UsrCase
Public CurrentDateTime As Long
Public CheckDateTime As Long
Public AvgChangeTime As String * 25 = "12/31/2020 23:46:00"
Public NewAvg As Boolean

'============================================================================================================
'--------------------------------------- DATA TABLES SECTION ------------------------------------------------
'============================================================================================================
DataTable(Aquarius,Rec15MinFlag,-1) 'Data table for data published to Aquarius/NWIS
  TableFile("CRD:" + Status.StationName + "_Aquarius",64,-1,35040,0,Day,0,0)
  OpenInterval
  Sample (1,TimeStamp15Min,String)
  Minimum(1,StationVolts,FP2,False,False)
  'It's more likely we'd have a VM station without having other sensors. This way the first part of the DECODES
  'for NWIS will always have VM stuff first. Then if we add a sensor, it'll come after and won't mess up the parsing
  #If HasVM = True Then 'If we have a VM or pressure sensors
    Average (1,PS1Stg,IEEE4,BadPS1Flg)
    Average (1,PS2Stg,IEEE4,BadPS2Flg)
    Average (1,UpBeamStg,IEEE4,BadUpbeamFlg)
    Average (1,IndexVel,IEEE4,BadVelFlag)
    Minimum (1,VMVolts,FP2,False,False)
    Average (1,VMtempC,FP2,False)
    Average (1,VMpitch,FP2,False)
    Average (1,VMroll,FP2,False)
  #EndIf 'if we have a VM or pressure sensors
  #If WqSonde = "WQ_SERIAL_BURST" Then 'if there's a sonde performing burst methods
    Sample (1,MedBurstDate,IEEE4) 'Do we need this in the AQ table or is it sufficient in the Burst Table?
    Sample (1,MedBurstTime,IEEE4) ' See note above
    Minimum (1,WqBatt,FP2,False,False)
    Sample (1,MedTempC,IEEE4) 'the "Med..." values are pulled from the burst table via "Med... = Burst.BurstMed..."
    Sample (1,MedSpCond,IEEE4)
    Sample (1,MedTurbFNU,IEEE4)
    Sample (1,MedDOSat,IEEE4)
    Sample (1,MedDOmgL,IEEE4)
    Sample (1,MedDepthFt,IEEE4)
    Sample (1,MedBatt,FP2)
    Sample (1,MedpH,IEEE4)
    Sample (1,MedChlugL,IEEE4)
    Sample (1,MedChlRFU,IEEE4)
    Sample (1,MedFDomRFU,IEEE4)
    Sample (1,MedFDomQSU,IEEE4)
    Sample (1,MedBGApcRFU,IEEE4)
    Sample (1,MedBGApcugL,IEEE4)
    #If TopBottom = True Then
      Sample (1,BtmMedBurstDate,IEEE4)
      Sample (1,BtmMedBurstTime,IEEE4)
      Minimum (1,BtmWqBatt,FP2,False,False)
      Sample (1,BtmMedTempC,IEEE4) 'the "Med..." values are pulled from the burst table via "Med... = Burst.BurstMed..."
      Sample (1,BtmMedSpCond,IEEE4)
      Sample (1,BtmMedTurbFNU,IEEE4)
      Sample (1,BtmMedDOSat,IEEE4)
      Sample (1,BtmMedDOmgL,IEEE4)
      Sample (1,BtmMedDepthFt,IEEE4)
      Sample (1,BtmMedDepthM,IEEE4)
      Sample (1,BtmMedBatt,FP2)
      Sample (1,BtmMedpH,IEEE4)
      Sample (1,BtmMedChlugL,IEEE4)
      Sample (1,BtmMedChlRFU,IEEE4)
      Sample (1,BtmMedFDomRFU,IEEE4)
      Sample (1,BtmMedFDomQSU,IEEE4)
      Sample (1,BtmMedBGApcRFU,IEEE4)
      Sample (1,BtmMedBGApcugL,IEEE4)
    #EndIf 'If second sonde present, Need to decide naming convention if we're only going to go with second SOA, no need to duplicate variables too much
  #EndIf 'If serial Burst Sonde(s)
  #If WqSonde = "WQ_SERIAL" Then 'Not performing burst, only take single, instant value
    Sample (1,WqDate,IEEE4)
    Sample (1,WqTime,IEEE4)
    Minimum (1,WqBatt,FP2,False,False)
    Sample (1,WqTempC,IEEE4)
    Sample (1,WqSpCond,IEEE4)
    Sample (1,WqTurbFNU,IEEE4)
    Sample (1,WqDOSat,IEEE4)
    Sample (1,WqDOmgL,IEEE4)
    Sample (1,WqDepthFt,IEEE4)
    Sample (1,WqDepthM,IEEE4)
    Sample (1,WqBatt,IEEE4)
    Sample (1,WqpH,IEEE4)
    Sample (1,WqChlugL,IEEE4)
    Sample (1,WqChlRFU,IEEE4)
    Sample (1,WqFDomRFU,IEEE4)
    Sample (1,WqFDomQSU,IEEE4)
    #If TopBottom Then 'If second sonde present <- need to address this for SDI12
      Sample (1,BtmWqDate,IEEE4)
      Sample (1,BtmWqTime,IEEE4)
      Minimum (1,BtmWqBatt,FP2,False,False)
      Sample (1,BtmWqTempC,IEEE4)
      Sample (1,BtmWqSpCond,IEEE4)
      Sample (1,BtmWqTurbFNU,IEEE4)
      Sample (1,BtmWqDOSat,IEEE4)
      Sample (1,BtmWqDOmgL,IEEE4)
      Sample (1,BtmWqDepthFt,IEEE4)
      Sample (1,BtmWqDepthM,IEEE4)
      Sample (1,BtmWqBatt,IEEE4)
      Sample (1,BtmWqpH,IEEE4)
      Sample (1,BtmWqChlugL,IEEE4)
      Sample (1,BtmWqChlRFU,IEEE4)
      Sample (1,BtmWqFDomRFU,IEEE4)
      Sample (1,BtmWqFDomQSU,IEEE4)
    #EndIf 'if second sonde present
  #EndIf 'If WqSonde = Serial or SDI12
  #If HasSuna = True Then 'If we're running a SUNA
    Sample (1,AvgSunaNitrateuM,IEEE4)
    Sample (1,MedSunaNitrateuM,IEEE4)
    Sample (1,StdSunaNitrateuM,IEEE4)
    Sample (1,AvgSunaNitratemgL,IEEE4)
    Sample (1,MedSunaNitratemgL,IEEE4)
    Sample (1,StdSunaNitratemgL,IEEE4)
    Sample (1,AvgSunaFittingResult,IEEE4)
    Sample (1,StdSunaFittingResult,IEEE4)
    Sample (1,MedA254,IEEE4)
    Sample (1,MedA350,IEEE4)
    Sample (1,AvgSunaDarkAve,IEEE4)
    Sample (1,AvgSunaSpecAve,IEEE4)
    Sample (1,AvgTSpec,FP2)
    Sample (1,AvgTLamp,FP2)
    Sample (1,AvgSunaHumid,FP2)
    Sample (1,AvgSunaLampTime,IEEE4)
    Sample (1,AvgSunaVoltMain,IEEE4)
    Sample (1,AvgSunaVoltLamp,IEEE4)
  #EndIf 'If we're running a SUNA
EndTable

DataTable(DataOut,Rec15MinFlag,-1)
  OpenInterval
  TableFile("CRD:" + Status.StationName + "_DataOut",64,-1,35040,0,Day,0,0)
  Sample (1,TimeStamp15Min,String)
  Sample (1,SiteID,String)
  Sample (1,SiteNum,String)
  Minimum (1,StationVolts,FP2,False,False)
  #If HasVM = True Then 'If We have VM or Pressure Sensors
    Average (1,IndexVel,IEEE4,BadVelFlag)
    Average (1,MeanVel,IEEE4,BadQFlag)
    Average (1,Qcfs,IEEE4,BadQFlag)
    Average (1,StagePrime,IEEE4,BadStgFlag)
    Average (1,StageSecnd,IEEE4,BadStg2Flag)
    Average (1,PS1Stg,IEEE4,BadPS1Flg)
    Average (1,PS2Stg,IEEE4,BadPS2Flg)
    Average (1,UpBeamStg,IEEE4,BadUpbeamFlg)
    Average (1,VMPressStg,IEEE4,BadVMPressFlg)
    #If WqSonde <> "NONE" Then 'If we have WQ
      Average(1,SondeStg,IEEE4,False)
    #EndIf 'If we have WQ
    Sample (1,StgSelect,String)
    Minimum (1,VMVolts,FP2,False,False)
    Average (1,VMtempC,FP2,False)
    Average (1,VMpitch,FP2,False)
    Average (1,VMroll,FP2,False)
    Average (1,VMHeading,FP2,False)
    Sample (6,BadStageCounters,FP2)
    Sample (1,StgOutOfBndCnt,FP2)
    Sample (1,Stg2OutOfBndCnt,FP2)
    Sample (1,BadVelCount,FP2)
    Sample (1,BadQCount,FP2)
    Average(1,AvgSwathRSSI,FP2,False)
    #If UseAutoRange = True Then 'If we want to autorange last uplooker bin
      Average (1,RangedBin,FP2,False)
      Sample (1,RangedBin,FP2)
    #EndIf 'if we want to auto range
    Average (MaxBins,VMBinVel(),IEEE4,VmBinVelDisable())
    Average(MaxBins,V1(),FP2,V1Disable())
    Average(MaxBins,V2(),FP2,V2Disable())
    Average(MaxBins,V3(),FP2,V3Disable())
    Average(MaxBins,V4(),FP2,V4Disable())
  #EndIf 'If we have VM or Pressure Sensors
  #If WqSonde <> "NONE" Then
    Sample (1,WqBatt,FP2)
    Sample (1,WqTempC,FP2)
    Sample (1,WqSpCond,IEEE4)
    Sample (1,WqTurbFNU,FP2)
    Sample (1,WqDOmgL,FP2)
    Sample (1,WqpH,FP2)
    Sample (1,WqChlugL,FP2)
    Sample (1,WqChlRFU,FP2)
    Sample (1,WqDOSat,FP2)
    Sample (1,WqORPmV,FP2)
    Sample (1,WqFDomRFU,FP2)
    Sample (1,WqFDomQSU,FP2)
    Sample (1,WqBGApcugL,FP2)
    Sample (1,WqNH4mgL,FP2)
    Sample (1,WqNO3mgL,FP2)
    Sample (1,WqCLmgL,FP2)
    Sample (1,WqWiperPos,FP2)
    Average (1,WqDepthFt,FP2,WqBadData)
    Average (1,WqDepthM,FP2,WqBadData)
    #If TopBottom = True Then
      Sample (1,BtmWqBatt,FP2)
      Sample (1,BtmWqTempC,FP2)
      Sample (1,BtmWqSpCond,IEEE4)
      Sample (1,BtmWqTurbFNU,FP2)
      Sample (1,BtmWqDOmgL,FP2)
      Sample (1,BtmWqpH,FP2)
      Sample (1,BtmWqChlugL,FP2)
      Sample (1,BtmWqChlRFU,FP2)
      Sample (1,BtmWqDOSat,FP2)
      Sample (1,BtmWqORPmV,FP2)
      Sample (1,BtmWqFDomRFU,FP2)
      Sample (1,BtmWqFDomQSU,FP2)
      Sample (1,BtmWqBGApcugL,FP2)
      Sample (1,BtmWqNH4mgL,FP2)
      Sample (1,BtmWqNO3mgL,FP2)
      Sample (1,BtmWqCLmgL,FP2)
      Sample (1,BtmWqWiperPos,FP2)
      Average (1,BtmWqDepthFt,FP2,BtmWqBadData)
      Average (1,BtmWqDepthM,FP2,BtmWqBadData)
    #EndIf 'If we have TopBottom
  #EndIf 'If WqSonde <> NONE
EndTable

DataTable(QAQCInfo,Rec24HrFlag,-1)
  OpenInterval
TableFile("CRD:" + Status.StationName + "_QAQCInfo",64,-1,365,0,Day,0,0)
  Sample (1,SiteID,String)
  Sample (1,SiteNum,String)
  Maximum (1,StationVolts,FP2,False,False)
  Minimum (1,StationVolts,FP2,False,False)
  Maximum (1,PTempC,FP2,False,False)
  Minimum (1,PTempC,FP2,False,False)
  Sample (1,Tech,String)
  Sample (1,VisitReason,String
  Sample (1,Program,String)
  Sample (1,ProgVersDate,String)
  Sample (1,ProgVersion, String)
  Sample (1,LastRecompile,String)
  Sample (1,SerNum,Long)
  Sample (1,OSVers,String)
  Sample (1,ProgErrors,Long)
  Sample (1,Low12Volts,Long)
  Sample (1,LithBat,FP2)
  Sample (1,SkipScans,Long)
  Sample (1,FreeCFMem,IEEE4)
  #If HasVM = True Then
    Sample (1,AdcpSN,Long)
    Sample (1,NewADCP,Boolean)
    Sample (1,IsCM,Boolean)
    Sample (1,IsVADCP,Boolean)
    Sample (1,IsWorkHorse,Boolean)
    Sample (1,PS1SN,String)
    Sample (1,NewPS1,Boolean)
    Sample (1,PS2SN,String)
    Sample (1,NewPS2,Boolean)
    Sample (1,EX,Long)'how is the vm setup
    Sample (1,Coord,String)
    Sample (1,Decode,String)
    Sample (1,NumADCPBins,FP2)
    Sample (1,NumBeams,FP2)
    Sample (1,EnsPings,FP2)
    Sample (1,BinSize,FP2)
    Sample (1,BlankDist,FP2)
    Sample (1,FlowSign,FP2)
    Sample (6,BinDist(),FP2)
    Sample (15,RatArray(),IEEE4)
    Sample (1,Trans,String)
    Sample (1,BiRatTran,FP2)
    Sample (1,UseBiRat,Boolean)
    Sample (1,UseV2,Boolean)
    #If UseAutoRange = True Then
      Sample (1,CutOffBins,FP2)
    #EndIf
    Sample (4,StgOffsets(),IEEE4)
    #If WqSonde <> "NONE" Then
      Sample (1,SondeOffset,IEEE4)
    #EndIf
    Sample (1,StgSelect,String)
    Maximum(1,VMVolts,FP2,False,False)
    Minimum(1,VMVolts,FP2,False,False)
    Maximum(1,VMtempC,FP2,False,False)
    Minimum(1,VMtempC,FP2,False,False)
    Maximum(1,VMpitch,FP2,False,False)
    Minimum(1,VMroll,FP2,False,False)
    Maximum(1,VMHeading,FP2,False,False)
    Minimum(1,VMHeading,FP2,False,False)
    Average(1,VMElevation,FP2,BadUpbeamFlg)
    Sample (1,VMElevation,FP2)
    Sample (1,BadQCount,Long)
    Sample (1,BadVelCount,Long)
    Sample (1,BadBinCnt,Long)
    Sample (1,BadEnsCount,FP2)
    Sample (1,StgOutOfBndCnt,FP2)
    Sample (1,StgOutOfBndCntTot,FP2)
    Sample (1,Stg2OutOfBndCnt,FP2)
    Sample (1,Stg2OutOfBndCntTot,FP2)
    Sample (12,BadStageCounters,Long)
    Sample (1,VMRestartAttempts,FP2)
    Sample (1,VMLowMemCount,FP2)
    Sample (1,VMLowMem,Boolean)
    Sample (1,VMMemFree,FP2)
    Sample (1,RecErased,Boolean)
  #EndIf 'If we have VM
  #If WqSonde <> "NONE" Then
    Maximum (1,WqBatt,FP2,False,False)
    Minimum (1,WqBatt,FP2,False,False)
        Sample (1,WqElevation,FP2)
        Average(1,WqElevation,FP2,WqBadData)
    Sample (1,WqTotErrs,FP2)
    Sample (1,WqPwrCycleTries,FP2)
    #If TopBottom = True Then 'if we have top bottom
      Maximum (1,BtmWqBatt,FP2,False,False)
      Minimum (1,BtmWqBatt,FP2,False,False)
      Sample (1,BtmWqElevation,FP2)
      Average(1,BtmWqElevation,FP2,BtmWqBadData)
      Sample (1,BtmWqTotErrs,FP2,False)
      Sample (1,BtmWqPwrCycleTries,FP2)
    #EndIf 'if we have top bottom
  #EndIf 'If we have sonde
EndTable

DataTable(SiteVisit,SiteVisTrig,50)
  TableFile("CRD:" + Status.StationName + "_SiteVisit",64,-1,50,0,Day,0,0)
  Sample (1,SiteID,String)
  Sample (1,SiteNum,String)
  Sample (1,StationVolts,FP2)
  Sample (1,Tech,String)
  Sample (1,VisitReason,String)
  #If HasVM = True Then 'If we have a VM
    Sample (1,IndexVel,IEEE4)
    Sample (1,Qcfs,IEEE4)
    Sample (1,StagePrime,IEEE4)
    Sample (1,UpBeamStg,IEEE4)
    Sample (1,VMPressStg,IEEE4)
    Sample (1,PS1Stg,IEEE4)
    Sample (1,PS2Stg,IEEE4)
    #If WqSonde <> "NONE" Then 'If sonde present
      Sample (1,SondeStg,IEEE4)
    #EndIf 'if sonde present
    Sample (4,StgOffsets(),IEEE4)
    #If WqSonde <> "NONE" Then 'if sonde present
      Sample (1,SondeOffset,IEEE4)
    #EndIf 'if sonde present
    Sample (1,VMtempC,FP2)
    Sample (1,VMpitch,FP2)
    Sample (1,VMroll,FP2)
    Sample (1,VMHeading,FP2)
    Sample (1,NumADCPBins,Long)
    Sample (1,BlankDist,Long)
    Sample (1,BinSize,Long)
    Sample (6,BinDist(),FP2)
    #If UseAutoRange = True Then 'if autoranging uplooker
      Sample (1,CutOffBins,FP2)
    #EndIf 'if autoranging
    Sample (15,RatArray(),IEEE4)
    Sample (1,BadQCount,Long)
    Sample (1,BadVelCount,Long)
    Sample (1,BadBinCnt,Long)
    Sample (1,BadEnsCount,FP2)
    Sample (1,BadStgCount,Long)
    Sample (1,VMRestartAttempts,FP2)
    Sample (1,VMLowMemCount,FP2)
    Sample (1,VMLowMem,Boolean)
    Sample (1,VMMemFree,FP2)
    Sample (1,RecErased,Boolean)
  #EndIf 'If we have VM
  #If (WqSonde <> "NONE") Then
    Sample (1,WqBatt,FP2)
    Sample (1,WqTempC,FP2)
    Sample (1,WqSpCond,IEEE4)
    Sample (1,WqTurbFNU,FP2)
    Sample (1,WqDOmgL,FP2)
    Sample (1,WqpH,FP2)
    Sample (1,WqChlugL,FP2)
    Sample (1,WqChlRFU,FP2)
    Sample (1,WqDepthFt,FP2)
    Sample (1,WqDepthM,FP2)
    Sample (1,WqDOSat,FP2)
    Sample (1,WqFDomRFU,FP2)
    Sample (1,WqFDomQSU,FP2)
    Sample (1,WqBGApcRFU,FP2)
    Sample (1,WqBGApcugL,FP2)
    Sample (1,WqNH4mgL,FP2)
    Sample (1,WqNO3mgL,FP2)
    Sample (1,WqCLmgL,FP2)
    Sample (1,WqErrCount,Long)
    #If TopBottom = True Then
      Sample (1,BtmWqBatt,FP2)
      Sample (1,BtmWqTempC,FP2)
      Sample (1,BtmWqSpCond,IEEE4)
      Sample (1,BtmWqTurbFNU,FP2)
      Sample (1,BtmWqDOmgL,FP2)
      Sample (1,BtmWqpH,FP2)
      Sample (1,BtmWqChlugL,FP2)
      Sample (1,BtmWqChlRFU,FP2)
      Sample (1,BtmWqDepthFt,FP2)
      Sample (1,BtmWqDepthM,FP2)
      Sample (1,BtmWqDOSat,FP2)
      Sample (1,BtmWqFDomRFU,FP2)
      Sample (1,BtmWqFDomQSU,FP2)
      Sample (1,BtmWqBGApcRFU,FP2)
      Sample (1,BtmWqBGApcugL,FP2)
      Sample (1,BtmWqNH4mgL,FP2)
      Sample (1,BtmWqNO3mgL,FP2)
      Sample (1,BtmWqCLmgL,FP2)
      Sample (1,BtmWqErrCount,Long)
    #EndIf 'if TopBottom
  #EndIf 'If WqSonde <> NONE
EndTable

DataTable(Data1m,Rec1MinFlag OR OneMinConsistent,-1)
  OpenInterval
  TableFile("CRD:" + Status.StationName + "_Data1m",64,-1,525600,0,Min,0,0)
  #If HasVM = True Then
    Sample(1,ADCPCenterTime,String)
  #EndIf 'Has VM
  Sample (1,SiteID,String)
  Sample (1,SiteNum,String)
  #If HasVM = True Then
    Sample (1,StagePrime,IEEE4)
    Sample (1,StageSecnd,IEEE4)
    Sample (1,IndexVel,IEEE4)
    Sample (1,MeanVel,IEEE4)
    Sample (1,Qcfs,IEEE4)
    Sample (MaxBins,VMBinVel(),IEEE4)
    Sample (MaxBins,V1(),IEEE4)
    Sample (MaxBins,V2(),IEEE4)
    Sample (MaxBins,V3(),IEEE4)
    Sample (MaxBins,V4(),IEEE4)
    #If UseAutoRange = True Then
      Sample(1,RangedBin,FP2)
      Sample(1,CutOffBins,FP2)
    #EndIf 'AutoRange
    Sample(1,StgSelect,String)
  #EndIf 'If HasVM
  #If WqSonde <> "NONE" Then
    Sample(24,WqDataArray(),IEEE4)
    #If TopBottom = True Then
      Sample(24,BtmWqDataArray,IEEE4)
    #EndIf
  #EndIf
EndTable

DataTable(SVMaq,True,1)
  Sample (1,SiteID,String)
  Sample (1,SiteNum,String)
  Sample (1,Program,String)
  Sample (1,ProgVersDate,String)
  Sample (1,ProgVersion, String)
  Sample (1,StationVolts,FP2)
  #If HasVM = True Then
    Sample (1,StagePrime,FP2)
    Sample (1,StageSecnd,FP2)
    Sample (1,PS1Stg,FP2)
    Sample (1,PS2Stg,IEEE4)
    Sample (1,UpBeamStg,IEEE4)
    Sample (1,VMPressStg,IEEE4)
    #If WqSonde <> "NONE" Then
      Sample (1,SondeStg,IEEE4)
    #EndIf 'if WqSonde <> NONE
    Sample (1,IndexVel,FP2)
    Sample (1,VMpitch,FP2)
    Sample (1,VMroll,FP2)
    Sample (1,VMtempC,FP2)
    Sample (1,VMVolts,FP2)
    Sample (4,StgOffsets(),IEEE4)
    #If WqSonde <> "NONE" Then
      Sample (1,SondeOffset,IEEE4)
    #EndIf 'if WqSonde <> NONE
    Sample (1,VMElevation,FP2)
  #EndIf 'If Has VM
  #If WqSonde <> "NONE" Then
    Sample(24,WqDataArray,IEEE4)
    Sample (1,WqElevation,FP2)
    #If TopBottom = True Then
      Sample(24,BtmWqDataArray,IEEE4)
      Sample(1,BtmWqElevation,FP2)
    #EndIf
  #EndIf
EndTable

DataTable(Debugger,True,-1)
  OpenInterval
  TableFile("CRD:" + Status.StationName + "_Debugger",64,-1,10080,0,Day,0,0)
  Sample(3,ProcTimer,FP2)
  #If HasVM = True Then 'If has VM
    Sample(3,VMProcTimer,FP2)
    Sample(3,VMLoopTimer,FP2)
    Sample(3,ZeroVMTimer,FP2)
    Sample(3,CheckSumTimer,FP2)
    Sample(3,MainDecodeTimer,FP2)
    #If UseAutoRange = True Then 'If auto range
      Sample(3,CalcRangeTimer,FP2)
    #EndIf 'if autorange
    Sample(3,OneMinCalcTimer,FP2)
    Sample(3,GetStgTimer,FP2)
    Sample(6,PSTimer,FP2)
    Sample(3,CalcQTimer,FP2)
    Sample(3,VMMemTimer,FP2)
    Sample(3,SetTSTimer,FP2)
    Sample(3,SetTFTimer,FP2)
    #If StoreAllToCard = True Then 'if store to card
      Sample(3,ChkSpikeTimer,FP2)
      Sample(3,StoreToCrdTimer,FP2)
      Sample(3,AddSpikeTimer,FP2)
    #EndIf 'if store to card
    Sample(3,WakeVMTimer,FP2)
  #EndIf 'if has vm
  #If WqSonde <> "NONE" Then
    Sample (3,RedeployTimer,FP2)
    Sample(3,GetWqTimer,FP2)
    Sample(1,WipeTime,String)
    #If TopBottom = True Then
      Sample(3,BtmRedeployTimer,FP2)
      Sample(3,BtmGetWqTimer,FP2)
      Sample(1,BtmWipeTime,String)
    #EndIf 'if top bottom
    #If WqSonde = "WQ_SERIAL_BURST" Then
      Sample(3,SetBurstTimer,FP2)
      Sample(3,FillBurstTimer,FP2)
      Sample(3,ProcBurstTimer,FP2)
      #If TopBottom = True Then
        Sample (3,BtmSetBurstTimer,FP2)
        Sample(3,BtmFillBurstTimer,FP2)
        Sample(3,BtmProcBurstTimer,FP2)
      #EndIf 'if top bottom
    #EndIf 'if burst
  #EndIf 'if sonde present
  #If HasSuna = True Then
    Sample (1,WipeStart,FP2)
    Sample (1,WipeEnd,FP2)
    Sample (1,SunaWipeTotTime,FP2)
    Sample (1,SunaWipeTime,String)
    Sample (1,SunaSampleStart,FP2)
    Sample (1,SunaOnTime,FP2)
    Sample (1,SunaProcessStart,FP2)
    Sample (1,SunaProcessEnd,FP2)
    Sample (1,SunaProcessTotTime,FP2)
  #EndIf 'has suna
  Sample(3,AQTabTimer,FP2)
  #If HasVM = True Then 'if has vm
    Sample(3,BeamChkTimer,FP2)
  #EndIf 'if has vm
  #If HasModem = True Then
    Sample(3,ModemChkTimer,FP2)
    Sample(1,PingResp,FP2)
  #EndIf
    Sample(1,OneMinCount,IEEE4)
EndTable


'============== VM ONLY TABLES =======================
#If HasVM = True Then
  DataTable (BeamCheck,Rec15MinFlag,-1)
    OpenInterval
    TableFile("CRD:" + Status.StationName + "_BeamCheck",64,-1,35040,0,Day,0,0)
    Sample (1,TimeStamp15Min,String)
    Sample (1,SiteID,String)
    Sample (1,StagePrime,IEEE4)
    Sample (1,NumBeams,Long)
    Sample (1,NumADCPBins,Long)
    Sample (1,BinSize,Long)
    Sample (1,StartBin,Long)
    Sample (1,EndBin,Long)
    Sample (1,VMpitch,FP2)
    Sample (1,VMroll,FP2)
    Average (MaxBins*4,ensRSSI(),UINT2,False)
    Average (MaxBins*4,ensCorr(),UINT2,False)
    Sample (1,VMupBeam,IEEE4)
    Average (1,VMupBeam,IEEE4,BadUpbeamFlg)
    Sample (1,VMtempC,IEEE4)
    Average (1,VMtempC,IEEE4,False)
    Sample (1,VMVolts,IEEE4)
    Average (1,VMVolts,IEEE4,False)
    'Sample (1,ExtWHConvertVolt,IEEE4)    Commented for now, do we think these are necessary? Maybe could read the higher voltage into Arduino, then sample that?
    'Average (1,ExtWHConvertVolt,IEEE4,False)
  EndTable

  #If VMHasVertical Then 'if we have 5th beam
    DataTable (VerticalVelocities,Rec15MinFlag,-1)
      OpenInterval 'tells table to process from last execution of table
      TableFile("CRD:" + Status.StationName + "_VerticalVelocities",64,-1,35040,0,Day,0,0)
      Sample (1,TimeStamp15Min,String)
      Sample (1,VerticalBinSize,UINT2)
      Sample (1,VerticalBinNum,UINT2)
      Sample (1,VerticalBin1Center,FP2)
      Sample (1,VerticalPings,Uint2)
      Average(MaxBins,VerticalVelocity(),IEEE4,VerticalBinDisable())
      Average(MaxBins,VerticalRSSI(),Uint2,False)
      Average(MaxBins,VerticalCorr(),Uint2,False)
    EndTable

    DataTable (Vertical1MinVel,Rec1MinFlag OR OneMinConsistent,-1)
      OpenInterval 'tells table to process from last execution of table
      TableFile("CRD:" + Status.StationName + "_Vertical1MinVel",64,-1,525600,0,Day,0,0)
      Sample (1,VerticalBinSize,UINT2)
      Sample (1,VerticalBinNum,UINT2)
      Sample (1,VerticalBin1Center,FP2)
      Sample (1,VerticalPings,Uint2)
      Sample(MaxBins,VerticalVelocity(),IEEE4)
      Sample(MaxBins,VerticalRSSI(),Uint2)
      Sample(MaxBins,VerticalCorr(),Uint2)
    EndTable
  #EndIf 'If we have 5th beam
  '========================================================================================
  '========================================================================================
  'Trial data table for Bottom Track data output
  #If VMHasBottomTrack Then 'if we have Bottom Track active
    DataTable (BottomTrack,Rec15MinFlag,-1)
      OpenInterval 'tells table to process from last execution of table
      TableFile("CRD:" + Status.StationName + "_BottomTrack",64,-1,35040,0,Day,0,0)
      Sample (1,TimeStamp15Min,String)
      Sample (1,BtmTrackPings,UINT2)
      Sample (1,BtmTrackMode,UINT2)
      Average(MaxBeams,BtmTrackRange(),IEEE4,BtmRangeBeamDisable())
      Average(MaxBeams,BtmTrackVelocity(),IEEE4,BtmVelBeamDisable())
      Average(MaxBeams,BtmTrackRSSI(),Uint2,False)
      Average(MaxBeams,BtmTrackCorr(),Uint2,False)
      #If VMHasVertical Then 'if we have 5th beam active
        Average(MaxBins,VerticalVelocity(),IEEE4,VerticalBinDisable())
      #EndIf 'if we have 5th beam active
    EndTable

    DataTable (BtmTrack1Min,Rec1MinFlag OR OneMinConsistent,-1)
      OpenInterval 'tells table to process from last execution of table
TableFile("CRD:" + Status.StationName + "_BtmTrack1Min",64,-1,525600,0,Day,0,0)
      Sample (1,BtmTrackPings,UINT2)
      Sample (1,BtmTrackMode,UINT2)
      Sample(MaxBeams,BtmTrackRange(),IEEE4)
      Sample(MaxBeams,BtmTrackVelocity(),IEEE4)
      Sample(MaxBeams,BtmTrackRSSI(),Uint2)
      Sample(MaxBeams,BtmTrackCorr(),Uint2)
      #If VMHasVertical Then 'if we have 5th beam active
        Sample(MaxBins,VerticalVelocity(),IEEE4)
      #EndIf 'if we have 5th beam active
    EndTable
  #EndIf 'if we have bottom track active

  #If IsSpecStudy = True Then
    DataTable (VelData,Rec15MinFlag,-1)
      OpenInterval 'tells table to process from last execution of table
      TableFile("CRD:" + Status.StationName + "_VelData",64,-1,35040,0,Day,0,0)
      Sample (1,TimeStamp15Min,String)
      Sample (1,SiteID,String)
      Sample (1,SiteNum,String)
      Sample(1,Coord,String)
      Sample(1,Decode,String)
      Average(MaxBins,V1(),FP2,V1Disable())
      Average(MaxBins,V2(),FP2,V2Disable())
      Average(MaxBins,V3(),FP2,V3Disable())
      Average(MaxBins,V4(),FP2,V4Disable())
      Average (108,ensRSSI(),UINT2,False)
      Average (108,ensCorr(),UINT2,False)
      Sample (1,VMHeading,FP2)
      Average (1,VMpitch,FP2,False)
      Average (1,VMroll,FP2,False)
      Average (1,VMtempC,FP2,False)
      'store other... x, y, think about this... what do we really want in here
    EndTable
  #EndIf 'if "special study"

  #If GetNoiseFloor = True Then 'if we want noise floor
    DataTable (NoiseFloor,True,365)
      OpenInterval
      TableFile("CRD:" + Status.StationName + "_NoiseFloor",64,-1,365,0,Day,0,0)
      Sample (1,SiteID,String)
      Sample (1,SiteNum,String)
      Sample (4,NoiseHGainW(),FP2)
      'Sample (1,NoiseHGainW(2),FP2)
      Sample (4,NoiseHGainN(),FP2)
      'Sample (1,NoiseHGainN(2),FP2)
      Sample (4,NoiseLGainW(),FP2)
      'Sample (1,NoiseLGainW(2),FP2)
      Sample (4,NoiseLGainN(),FP2)
      'Sample (1,NoiseLGainN(2),FP2)
      Sample (1,VMtempC,IEEE4)
      Sample (1,VMVolts,IEEE4)
      'Sample (1,ExtWHConvertVolt,IEEE4) commented out for now, discuss if we need it
    EndTable
  #EndIf 'if we want noise floor
#EndIf 'If HasVM = True

#If WqSonde = "WQ_SERIAL_BURST" Then
  DataTable(Burst,RecBurstFlag,192) '2 days
    TableFile("CRD:" + Status.StationName + "_Burst",64,-1,35040,0,Day,0,0)
    OpenInterval
    Sample (1,SiteID,String)
    Sample (1,SiteNum,String)
    Sample (1,BurstDate,IEEE4)
    Sample (1,BurstTime,IEEE4)
    Sample (1, BurstPeriod, IEEE4)
    '    Sample (1,BurstMedDate,IEEE4)
    '    Sample (1,BurstMedTime,IEEE4)
    Median (1,BurstDate,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstTime,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstTempC,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstTempF,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstSpCond,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstTurbFNU,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstDOSat, MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstDOmgL,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstORPmV,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstDepthFt,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstDepthM,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstBatt,MaxBurstCnt,FP2,BurstMissed)
    Median (1,BurstpH,MaxBurstCnt,FP2,BurstMissed)
    Median (1,BurstpHmV,MaxBurstCnt,FP2,BurstMissed)
    Median (1,BurstChlugL,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstChlRFU,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstBGApcRFU,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstBGApcugL,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstFDomRFU,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstFDomQSU,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstNH4mgL,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstNO3mgL,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstCLmgL,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstWiperPos,MaxBurstCnt,FP2,BurstMissed)
    StdDev (1,BurstTempC,IEEE4,False)
    Minimum (1,BurstTempC,IEEE4,False,0)
    Maximum (1,BurstTempC,IEEE4,False,0)
    StdDev (1,BurstSpCond,IEEE4,False)
    Minimum (1,BurstSpCond,IEEE4,False,0)
    Maximum (1,BurstSpCond,IEEE4,False,0)
    StdDev (1,BurstTurbFNU,IEEE4,False)
    Minimum (1,BurstTurbFNU,IEEE4,False,0)
    Maximum (1,BurstTurbFNU,IEEE4,False,0)
    StdDev (1,BurstDOSat,IEEE4,False)
    Minimum (1,BurstDOSat,IEEE4,False,0)
    Maximum (1,BurstDOSat,IEEE4,False,0)
    StdDev (1,BurstDOmgL,IEEE4,False)
    Minimum (1,BurstDOmgL,IEEE4,False,0)
    Maximum (1,BurstDOmgL,IEEE4,False,0)
    StdDev (1,BurstORPmV,IEEE4,False)
    Minimum (1,BurstORPmV,IEEE4,False,0)
    Maximum (1,BurstORPmV,IEEE4,False,0)
    StdDev (1,BurstDepthFt,IEEE4,False)
    Minimum (1,BurstDepthFt,IEEE4,False,0)
    Maximum (1,BurstDepthFt,IEEE4,False,0)
    StdDev (1,BurstDepthM,IEEE4,False)
    Minimum (1,BurstDepthM,IEEE4,False,0)
    Maximum (1,BurstDepthM,IEEE4,False,0)
    StdDev (1,BurstBatt,FP2,False)
    Minimum (1,BurstBatt,FP2,False,0)
    Maximum (1,BurstBatt,FP2,False,0)
    StdDev (1,BurstpH,FP2,False)
    Minimum (1,BurstpH,FP2,False,0)
    Maximum (1,BurstpH,FP2,False,0)
    StdDev (1,BurstpHmV,FP2,False)
    Minimum (1,BurstpHmV,FP2,False,0)
    Maximum (1,BurstpHmV,FP2,False,0)
    StdDev (1,BurstChlugL,IEEE4,False)
    Minimum (1,BurstChlugL,IEEE4,False,0)
    Maximum (1,BurstChlugL,IEEE4,False,0)
    StdDev (1,BurstChlRFU,IEEE4,False)
    Minimum (1,BurstChlRFU,IEEE4,False,0)
    Maximum (1,BurstChlRFU,IEEE4,False,0)
    StdDev (1,BurstBGApcRFU,IEEE4,False)
    Minimum (1,BurstBGApcRFU,IEEE4,False,0)
    Maximum (1,BurstBGApcRFU,IEEE4,False,0)
    StdDev (1,BurstBGApcugL,IEEE4,False)
    Minimum (1,BurstBGApcugL,IEEE4,False,0)
    Maximum (1,BurstBGApcugL,IEEE4,False,0)
    StdDev (1,BurstFDomRFU,IEEE4,False)
    Minimum (1,BurstFDomRFU,IEEE4,False,0)
    Maximum (1,BurstFDomRFU,IEEE4,False,0)
    StdDev (1,BurstFDomQSU,IEEE4,False)
    Minimum (1,BurstFDomQSU,IEEE4,False,0)
    Maximum (1,BurstFDomQSU,IEEE4,False,0)
    StdDev (1,BurstNH4mgL,IEEE4,False)
    Minimum (1,BurstNH4mgL,IEEE4,False,0)
    Maximum (1,BurstNH4mgL,IEEE4,False,0)
    StdDev (1,BurstNO3mgL,IEEE4,False)
    Minimum (1,BurstNO3mgL,IEEE4,False,0)
    Maximum (1,BurstNO3mgL,IEEE4,False,0)
    StdDev (1,BurstCLmgL,IEEE4,False)
    Minimum (1,BurstCLmgL,IEEE4,False,0)
    Maximum (1,BurstCLmgL,IEEE4,False,0)
    StdDev (1,BurstWiperPos,FP2,False)
    Minimum (1,BurstWiperPos,FP2,False,0)
    Maximum (1,BurstWiperPos,FP2,False,0)
    Sample (1,TotalBurstVals,FP2)
    Sample (1,BurstMissed,Boolean)
    Sample (1,BurstErrCnt,FP2)
  EndTable

  '__________________________________________Metadata for each burst sample_____________________________________
  '_____________________collect each 1 second value that is being used to calculate "Burst" table values________________
  DataTable(SecBurst,True,360)
    'DataInterval(0,1,Min,-1)
    TableFile("CRD:" + Status.StationName + "_SecBurst",64,-1,86400,0,Day,0,0) '30 days per file
    OpenInterval
    Sample (1,SiteID,String)
    Sample (1,SiteNum,String)
    Sample (1,BurstDate,IEEE4)
    Sample (1,BurstTime,IEEE4)
    Sample (1,BurstTempC,IEEE4)
    Sample (1,BurstTempF,IEEE4)
    Sample (1,BurstSpCond,IEEE4)
    Sample (1,BurstTurbFNU,IEEE4)
    Sample (1,BurstDOSat,IEEE4)
    Sample (1,BurstDOmgL,IEEE4)
    Sample (1,BurstORPmV,IEEE4)
    Sample (1,BurstDepthFt,IEEE4)
    Sample (1,BurstDepthM,IEEE4)
    Sample (1,BurstBatt,FP2)
    Sample (1,BurstpH,FP2)
    Sample (1,BurstpHmV,FP2)
    Sample (1,BurstChlugL,IEEE4)
    Sample (1,BurstChlRFU,IEEE4)
    Sample (1,BurstBGApcRFU,IEEE4)
    Sample (1,BurstBGApcugL,IEEE4)
    Sample (1,BurstFDomRFU,IEEE4)
    Sample (1,BurstFDomQSU,IEEE4)
    Sample (1,BurstNH4mgL,IEEE4)
    Sample (1,BurstNO3mgL,IEEE4)
    Sample (1,BurstCLmgL,IEEE4)
    Sample (1,BurstWiperPos,FP2)
    Sample (1,TotalBurstVals,FP2)
    Sample (1,BurstMissed,Boolean)
    Sample (1,BurstErrCnt,FP2)
  EndTable

  #If TopBottom = True Then
    DataTable(BtmBurst,BtmRecBurstFlag,192)
      'DataInterval(0,1,Min,-1)
      TableFile("CRD:" + Status.StationName + "_BtmBurst",64,-1,35040,0,Day,0,0)
      OpenInterval
      Sample (1,SiteID,String)
      Sample (1,SiteNum,String)
      Sample (1,BtmBurstDate,IEEE4)
      Sample (1,BtmBurstTime,IEEE4)
      Sample (1,BurstPeriod, IEEE4)
      '    Sample (1,BurstMedDate,IEEE4)
      '    Sample (1,BurstMedTime,IEEE4)
      Median (1,BtmBurstDate,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstTime,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstTempC,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstTempF,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstSpCond,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstTurbFNU,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstDOSat, MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstDOmgL,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstORPmV,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstDepthFt,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstDepthM,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstBatt,MaxBurstCnt,FP2,BurstMissed)
      Median (1,BtmBurstpH,MaxBurstCnt,FP2,BurstMissed)
      Median (1,BtmBurstpHmV,MaxBurstCnt,FP2,BurstMissed)
      Median (1,BtmBurstChlugL,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstChlRFU,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstBGApcRFU,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstBGApcugL,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstFDomRFU,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstFDomQSU,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstNH4mgL,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstNO3mgL,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstCLmgL,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BtmBurstWiperPos,MaxBurstCnt,FP2,BurstMissed)
      StdDev (1,BtmBurstTempC,IEEE4,False)
      Minimum (1,BtmBurstTempC,IEEE4,False,0)
      Maximum (1,BtmBurstTempC,IEEE4,False,0)
      StdDev (1,BtmBurstSpCond,IEEE4,False)
      Minimum (1,BtmBurstSpCond,IEEE4,False,0)
      Maximum (1,BtmBurstSpCond,IEEE4,False,0)
      StdDev (1,BtmBurstTurbFNU,IEEE4,False)
      Minimum (1,BtmBurstTurbFNU,IEEE4,False,0)
      Maximum (1,BtmBurstTurbFNU,IEEE4,False,0)
      StdDev (1,BtmBurstDOSat,IEEE4,False)
      Minimum (1,BtmBurstDOSat,IEEE4,False,0)
      Maximum (1,BtmBurstDOSat,IEEE4,False,0)
      StdDev (1,BtmBurstDOmgL,IEEE4,False)
      Minimum (1,BtmBurstDOmgL,IEEE4,False,0)
      Maximum (1,BtmBurstDOmgL,IEEE4,False,0)
      StdDev (1,BtmBurstORPmV,IEEE4,False)
      Minimum (1,BtmBurstORPmV,IEEE4,False,0)
      Maximum (1,BtmBurstORPmV,IEEE4,False,0)
      StdDev (1,BtmBurstDepthFt,IEEE4,False)
      Minimum (1,BtmBurstDepthFt,IEEE4,False,0)
      Maximum (1,BtmBurstDepthFt,IEEE4,False,0)
      StdDev (1,BtmBurstDepthM,IEEE4,False)
      Minimum (1,BtmBurstDepthM,IEEE4,False,0)
      Maximum (1,BtmBurstDepthM,IEEE4,False,0)
      StdDev (1,BtmBurstBatt,FP2,False)
      Minimum (1,BtmBurstBatt,FP2,False,0)
      Maximum (1,BtmBurstBatt,FP2,False,0)
      StdDev (1,BtmBurstpH,FP2,False)
      Minimum (1,BtmBurstpH,FP2,False,0)
      Maximum (1,BtmBurstpH,FP2,False,0)
      StdDev (1,BtmBurstpHmV,FP2,False)
      Minimum (1,BtmBurstpHmV,FP2,False,0)
      Maximum (1,BtmBurstpHmV,FP2,False,0)
      StdDev (1,BtmBurstChlugL,IEEE4,False)
      Minimum (1,BtmBurstChlugL,IEEE4,False,0)
      Maximum (1,BtmBurstChlugL,IEEE4,False,0)
      StdDev (1,BtmBurstChlRFU,IEEE4,False)
      Minimum (1,BtmBurstChlRFU,IEEE4,False,0)
      Maximum (1,BtmBurstChlRFU,IEEE4,False,0)
      StdDev (1,BtmBurstBGApcRFU,IEEE4,False)
      Minimum (1,BtmBurstBGApcRFU,IEEE4,False,0)
      Maximum (1,BtmBurstBGApcRFU,IEEE4,False,0)
      StdDev (1,BtmBurstBGApcugL,IEEE4,False)
      Minimum (1,BtmBurstBGApcugL,IEEE4,False,0)
      Maximum (1,BtmBurstBGApcugL,IEEE4,False,0)
      StdDev (1,BtmBurstFDomRFU,IEEE4,False)
      Minimum (1,BtmBurstFDomRFU,IEEE4,False,0)
      Maximum (1,BtmBurstFDomRFU,IEEE4,False,0)
      StdDev (1,BtmBurstFDomQSU,IEEE4,False)
      Minimum (1,BtmBurstFDomQSU,IEEE4,False,0)
      Maximum (1,BtmBurstFDomQSU,IEEE4,False,0)
      StdDev (1,BtmBurstNH4mgL,IEEE4,False)
      Minimum (1,BtmBurstNH4mgL,IEEE4,False,0)
      Maximum (1,BtmBurstNH4mgL,IEEE4,False,0)
      StdDev (1,BtmBurstNO3mgL,IEEE4,False)
      Minimum (1,BtmBurstNO3mgL,IEEE4,False,0)
      Maximum (1,BtmBurstNO3mgL,IEEE4,False,0)
      StdDev (1,BtmBurstCLmgL,IEEE4,False)
      Minimum (1,BtmBurstCLmgL,IEEE4,False,0)
      Maximum (1,BtmBurstCLmgL,IEEE4,False,0)
      StdDev (1,BtmBurstWiperPos,FP2,False)
      Minimum (1,BtmBurstWiperPos,FP2,False,0)
      Maximum (1,BtmBurstWiperPos,FP2,False,0)
      Sample (1,BtmTotalBurstVals,FP2)
      Sample (1,BtmBurstMissed,Boolean)
      Sample (1,BtmBurstErrCnt,FP2)
    EndTable

    '__________________________________________Metadata for each burst sample_____________________________________
    '_____________________collect each 1 second value that is being used to calculate "Burst" table values________________
    DataTable(BtmSecBurst,True,360) '30 min
      'DataInterval(0,1,Min,-1)
      TableFile("CRD:" + Status.StationName + "_BtmSecBurst",64,-1,86400,0,Day,0,0) '30 days per file
      OpenInterval
      Sample (1,SiteID,String)
      Sample (1,SiteNum,String)
      Sample (1,BtmBurstDate,IEEE4)
      Sample (1,BtmBurstTime,IEEE4)
      Sample (1,BtmBurstTempC,IEEE4)
      Sample (1,BtmBurstTempF,IEEE4)
      Sample (1,BtmBurstSpCond,IEEE4)
      Sample (1,BtmBurstTurbFNU,IEEE4)
      Sample (1,BtmBurstDOSat,IEEE4)
      Sample (1,BtmBurstDOmgL,IEEE4)
      Sample (1,BtmBurstORPmV,IEEE4)
      Sample (1,BtmBurstDepthFt,IEEE4)
      Sample (1,BtmBurstDepthM,IEEE4)
      Sample (1,BtmBurstBatt,FP2)
      Sample (1,BtmBurstpH,FP2)
      Sample (1,BtmBurstpHmV,FP2)
      Sample (1,BtmBurstChlugL,IEEE4)
      Sample (1,BtmBurstChlRFU,IEEE4)
      Sample (1,BtmBurstBGApcRFU,IEEE4)
      Sample (1,BtmBurstBGApcugL,IEEE4)
      Sample (1,BtmBurstFDomRFU,IEEE4)
      Sample (1,BtmBurstFDomQSU,IEEE4)
      Sample (1,BtmBurstNH4mgL,IEEE4)
      Sample (1,BtmBurstNO3mgL,IEEE4)
      Sample (1,BtmBurstCLmgL,IEEE4)
      Sample (1,BtmBurstWiperPos,FP2)
      Sample (1,BtmTotalBurstVals,FP2)
      Sample (1,BtmBurstMissed,Boolean)
      Sample (1,BtmBurstErrCnt,FP2)
    EndTable
  #EndIf 'If Top/Bottom
#EndIf 'If Burst

'============================================================================
'------------------------ SUNA SPECIFIC TABLES ------------------------------
'============================================================================
#If HasSuna = True Then
  DataTable (SunaStats,RecSunaData,-1)
    TableFile("CRD:" + Status.StationName + "_SunaStats",64,-1,35040,0,Day,0,0)
    Sample (1,SunaSN,FP2)
    Average (1,SunaNitrateuM,IEEE4,False)
    Median (1,SunaNitrateuM,30,IEEE4,False)
    StdDev (1,SunaNitrateuM,IEEE4,False)
    Average (1,SunaNitratemgL,IEEE4,False)
    Median (1,SunaNitratemgL,30,IEEE4,False)
    StdDev (1,SunaNitratemgL,IEEE4,False)
    Average (1,SunaFittingResult,IEEE4,False)
    Median (1,SunaFittingResult,30,IEEE4,False)
    StdDev (1,SunaFittingResult,IEEE4,False)
    Median (1,A254,30,IEEE4,False)
    Median (1,A350,30,IEEE4,False)
    Average (1,SunaDarkAve,IEEE4,False)
    Average (1,SunaSpecAve,IEEE4,False)
    Average (1,TSpec,FP2,False)
    Average (1,TLamp,FP2,False)
    Average (1,SunaHumid,FP2,False)
    Average (1,SunaLampTime,IEEE4,False)
    Average (1,SunaVoltMain,IEEE4,False)
    Average (1,SunaVoltLamp,IEEE4,False)
    Sample (1,LFrameCnt,FP2,False)
    Sample (1,DFrameCnt,FP2,False)
    Sample (1,BadSunaVals,FP2,False)
    Sample (1,LampWarn,Boolean)
    Sample (1,MemWarn,Boolean)
    Sample (1,SunaWarning,String)
  EndTable

  DataTable (SunaLFData,1,-1)
    TableFile("CRD:" + Status.StationName + "_SunaLFData",64,-1,86400,0,Day,0,0) '30 days per file
    Sample(1,SunaHeader,String)
    Sample(282,SunaBurstData(),IEEE4)
  EndTable

  DataTable (RawSunaData,1,-1)
    CardOut (0,350000)
    TableFile("CRD:" + Status.StationName + "_RawSunaData",64,-1,95040,0,Day,0,0) '30 days per file, assume 33 records per sample (30LF, 3DF)
    Sample(1,SunaHeader,String)
    Sample(282,SunaBurstData(),IEEE4)
  EndTable

  DataTable (SunaLength,1,-1)
    TableFile("CRD:" + Status.StationName + "_SunaLength",64,-1,35040,0,Day,0,0)
    Sample (MaxSunaBurst,SunaStringLen(),FP2)
  EndTable
#EndIf 'if has suna
'=======================================================================

'=========================================================================
'------------------- RADIO NETWORK STATUS TABLE --------------------------
'=========================================================================
#If RadioNetwork = True Then
  DataTable (RadioStatus,1,1) 'testing table, holds nothing of importance for now.
    #If IsMaster = True Then
      #If NetworkSlaves = 1 Then
        Sample (1,SendToAFailCnt,FP2)
        Sample (1,LinkToAdead,Boolean)
        Sample (1,ResetTried,Boolean)
        Sample (1,RadResetAttempts,FP2)
      #ElseIf NetworkSlaves = 2 Then
        Sample (1,SendToAFailCnt,FP2)
        Sample (1,LinkToAdead,Boolean)
        Sample (1,SendToBFailCnt,FP2)
        Sample (1,LinkToBdead,Boolean)
        Sample (1,AllLinksDead,Boolean)
        Sample (1,ResetTried,Boolean)
        Sample (1,RadResetAttempts,FP2)
      #ElseIf NetworkSlaves = 3 Then
        Sample (1,SendToAFailCnt,FP2)
        Sample (1,LinkToAdead,Boolean)
        Sample (1,SendToBFailCnt,FP2)
        Sample (1,LinkToBdead,Boolean)
        Sample (1,SendToCFailCnt,FP2)
        Sample (1,LinkToCdead,Boolean)
        Sample (1,AllLinksDead,Boolean)
        Sample (1,ResetTried,Boolean)
        Sample (1,RadResetAttempts,FP2)
      #ElseIf NetworkSlaves = 4 Then
        Sample (1,SendToAFailCnt,FP2)
        Sample (1,LinkToAdead,Boolean)
        Sample (1,SendToBFailCnt,FP2)
        Sample (1,LinkToBdead,Boolean)
        Sample (1,SendToCFailCnt,FP2)
        Sample (1,LinkToCdead,Boolean)
        Sample (1,SendToDFailCnt,FP2)
        Sample (1,LinkToDdead,Boolean)
        Sample (1,AllLinksDead,Boolean)
        Sample (1,ResetTried,Boolean)
        Sample (1,RadResetAttempts,FP2)
      #EndIf 'Network Slaves
    #Else 'Not master
      Sample (1,GetFailCnt,FP2)
      Sample (1,LinkDead,Boolean)
      Sample (1,ResetTried,Boolean)
      Sample (1,RadResetAttempts,FP2)
    #EndIf 'Not master
  EndTable
#EndIf 'If radio network

#If HasHMS = True Then
  DataTable(HMSTable,WeBad OR HMS_Manual,60)
    TableFile("CRD:" + Status.StationName + "_HMSTable",64,-1,60,0,Day,0,0)
    Sample(1,WeBad,Boolean)
    Sample(1,HMS_Manual,Boolean)
    #If HasVM = True Then
      Sample(1,HMS_VMcount,FP2)
      Sample(1,HMS_VMFlag,Boolean)
    #EndIf
    #If WqSonde <> "NONE" Then
      Sample(1,HMS_WQcount,FP2)
      Sample(1,HMS_WqFlag,Boolean)
      #If TopBottom = True Then
        Sample(1,HMS_BtmWQCount,FP2)
        Sample(1,HMS_BtmWqFlag,Boolean)
      #EndIf
    #EndIf
    #If HasModem = True Then
      Sample(1,HMS_ModCount,FP2)
      Sample(1,HMS_ModFlag,Boolean)
    #EndIf
    Sample(1,LastRecompile,String)
  EndTable
#EndIf
'=========== FUNCTION TO FORMAT TIMES FOR DIFFERENT PURPOSES ==================
Function FTime(TimeIn As String * 25) As String *25 'converts datalogger time string into appropriate formatting for different instruments
  SplitStr (FSplitTime(),TimeIn," ",6,0)
  Dim SendMonth As String
  Dim SendDay As String
  Dim SendHour As String
  Dim SendMin As String
  Dim SendSec As String
  Dim SendYear As String
  Dim SendVmYear As String
  Dim TFMin As String
  Dim TempHour As Float
  Dim TempMin As Float
  Dim TFSec As String

  If FSplitTime(1) < 10 Then
    SendMonth = "0" + FSplitTime(1)
  Else
    SendMonth = FSplitTime(1)
  EndIf
  If FSplitTime(2) < 10 Then
    SendDay = "0" + FSplitTime(2)
  Else
    SendDay = FSplitTime(2)
  EndIf
  If FSplitTime(4) < 10 Then
    SendHour = "0" + FSplitTime(4)
  Else
    SendHour = FSplitTime(4)
  EndIf
  If FSplitTime(5) < 10 Then
    SendMin = "0" + FSplitTime(5)
  Else
    SendMin = FSplitTime(5)
  EndIf

  If Round(FSplitTime(6),0) < 10 Then
    SendSec = "0" + Round(FSplitTime(6),0)
  Else
    SendSec = Round(FSplitTime(6),0)
  EndIf
  SendYear = Right(FSplitTime(3),4) '4 digit year
  SendVmYear = Right(FSplitTime(3),2) '2 digit year
  Select Case FTimeIn 'Determine which timestamp format is needed
  Case 1 'If storing 15min interval
    Ftime = SendYear + "-" + SendMonth + "-" + SendDay + " " + SendHour + ":" + SendMin + ":" + "00"
  Case 2 'if sending TF command to CM or WH
    TempMin = FSplitTime(5)
    If Round(FSplitTime(6),0) < VMStartSec - 13 Then 'If we got to the TF set at least 13sec before the proposed start sec
      TempMin = TempMin 'issue the start time for the same minute
    Else
      TempMin = TempMin + 1 'otherwise start collection on the next minute
    EndIf
    If TempMin < 10 Then
      TFMin = "0" + TempMin
    Else
      TFMin = TempMin
    EndIf
    If VMStartSec < 10 Then
      TFSec = "0" + VMStartSec
    Else
      TFSec = VMStartSec
    EndIf
    FTime = SendVmYear + "/" + SendMonth + "/" + SendDay + "," + SendHour + ":" + TFMin + ":" + TFSec 'Use next minute/user defined sec
  Case 3 'If setting time in CM of WH use time now
    Ftime = SendVmYear + "/" + SendMonth + "/" + SendDay + "," + SendHour + ":" + SendMin + ":" + SendSec

  Case 4 'If storing spike data to card file
    Ftime = SendMonth + "/" + SendDay + "/" + SendYear + " " + SendHour + ":" + SendMin + ":" + SendSec
  Case 5 'If setting EXO time
    TempHour = FSplitTime(4)
    If DWRSonde = False Then
      TempHour = TempHour + 8 'USGS sets sonde times to UTC
    Else
      TempHour = TempHour 'Leave as datalogger's PST hour
    EndIf
    If TempHour >= 24 Then 'if we're over 24hours,
      TempHour = TempHour - 24 'subtract 24 from value
    EndIf
    If TempHour < 10 Then 'if under 10
      SendHour = "0" + TempHour 'add leading zero to string
    Else
      SendHour = TempHour
    EndIf
    Ftime = SendHour + ":" + SendMin + ":" + SendSec
  EndSelect
End Function


'============================ USER DEFINED START UP VARIABLES ================================
Sub UserDefaults
  Tech = "TEC"
  StationName = XXX 'no quotations around name
  SiteNum = "12345678"
  VisitReason = "Program update"
  'Default Flow setup values
  'Note if using bi-rating start and end must include all EBB and FLOOD bins
  #If HasVM = True Then 'only bother with these if there's a VM on board
    StartBin = 1
    EndBin = 27
    StartEbbBin = 1 'used for bi-directional rating
    EndEbbBin = 27 'used for bi-directional rating
    StartFldBin = 1 'used for bi-directional rating
    EndFldBin = 27  'used for bi-directional rating
    BiRating = False 'set to true if using bi-directional rating
    BiRatTran = 0 'set to transition velocity for bi-directional rating
    MinExpStg = 0
    MaxExpStg = 30
    MinExpVel = -5
    MaxExpVel = 6
    FlowSign = 1
    SelStgPrime = PSpress
    SelStgSecnd = UPbeam
    UpBeamOffset = 0
    VMPressOffset = 0
    PS1Offset = 0
    PS2Offset = 0
    'communication setup for Pressure sensors
    PSPressPort = 3
    PSPressAddr = 0
    PSpress2Port = 5
    PSpress2Addr = 0
    CalcQ = True 'True if logger Q calcs are wanted
    'Area Rating:
    StgOffset = 0
    StgCoef = 0
    StgCoef2 = 0
    'meanvel rating:
    VelOffset = 0
    VelCoef = 0
    VelCoef2 = 0
    VelCoef3 = 0
    UpVelOffset = 0
    UpVelCoef = 0
    UpVelCoef2 = 0
    UpVelCoef3 = 0
    LowVelOffset = 0
    LowVelCoef = 0
    LowVelCoef2 = 0
    LowVelCoef3 = 0
    Trans = NAN
    UseV2 = False
    UseDir = False
    IsVMNClosed = True 'Default setting for the existance of a normally Closed VM power Relay
    #If UseAutoRange Then
      RangeSource = UPbeam 'sensor to use for water depth over VM transducer faces
      DucerDepthOffset = 0 'difference between water depth sensor and VM transducer face
      RangedBin = 0 'starting point for range calculation
      CutOffBins = 1 'Starting point for number of bins to discard when using AutoRange feature
    #EndIf 'If use auto range for uplookers
  #EndIf 'If has VM
  #If WqSonde <> "NONE" Then
    IsWqNClosed = True 'Is there a normally closed relay powering Sonde
    #If HasVM = True Then
    SondeOffset = 0
    #EndIf
    #If TopBottom = True Then
      IsBtmWqNClosed = True 'Standard NC relay
    #EndIf
  #EndIf
EndSub

'=========================== PROGRAM INITIALIZATION, SET VARIABLES TO STARTING STATE ==============
Sub Initialize
  '-------Standard Variables --------
  ProgVersDate = ProgramVersionDate
  ProgVersion =ProgramVersion
  LastScan = "00:00"
  LastRecompile = Status.StartTime
  SiteID = Status.StationName(1,1) 'pull SiteID from the status page, defined via "StationName" instruction above
  Rec1MinFlag = False
  OneMinCount = 0
  ScanNum = 0
  #If HasVM = True OR WqSonde <> "NONE" Then
    StoreVariablesFlg = False
    GetVariablesFlg = True 'If there are variables stored in USR drive, pull them on start up
  #EndIf
  OneMinConsistent = False 'Make continuous collection false at start up. Only user activated/USR drive
  '---------VM only variables ----------
  #If HasVM Then 'Has VM
    CMD = "" 'blank out command
    SendCMD = False 'don't send command at start up
    SetVMTimeFlg = False 'Don't try to set the time on start up
    UseCommsZeroForADCP = False 'Set to false, then allow logger to set appropriately
    MissedEns = 0
    Erase(LongArray()) 'Make sure array that holds ADCP PD0 is empty
    AvgRSSIStartBin = StartBin
    AvgRSSIEndBin  = EndBin
    VMPower = True
    IsSubmersed = False
    IsCM = True 'These are auto set, should not matter
    IsVADCP = False
    IsWorkHorse = False
    TrueUpBeamStg = BadDataIndicator
    TrueVMPressStg = BadDataIndicator
    TruePS1Stg = BadDataIndicator
    TruePS2Stg = BadDataIndicator
    SendFlowData = False
    RecordAll = False
    StageFlags() = True
    BadVelFlag = True
    BadQFlag = True
    VMdataIn = False
    BadCheckSum = 0
    HeaderMismatch = 0
    NumbytesZero = 0
    ReceivedBytes = 0
    WakeUpVM = False
    SetVMTimeFlg = False
    VMRestartAttempts = 0
    AvgRSSIcounter = 0
    AvgRSSIAccum = 0
    AvgSwathRSSI = 0
    VMLowMemVal = 0
    InitialAdcpSN = 0
    InitialPS1SN = 0
    InitialPS2SN = 0
    BiRatOK  = False 'Used by program to determin if BiRating can be done (if using CM with Instrument Coords). do not change manually, SET TO FALSE HERE
    UseBiRat = False 'flag set BY PROGRAM if both the above are true.  do not change manually, SET TO FALSE HERE
    #If GetNoiseFloor = True Then 'Get Noise Floor
      FilterString = "RSSI"
      SendPT3 = True
      PT3Time = 3
    #EndIf 'If Get Noise Floor
    #If StoreAllToCard = True Then
      SpikeCounter = 0
      SendHeader = True 'send header of file on first call to storing spikes
    #EndIf
  #EndIf 'If has VM
  '------End of VM only variables ---------
  #If WqSonde <> "NONE" Then 'If WqSonde present
    #If HasVM = True Then
    TrueSondeStg = BadDataIndicator
    #EndIf
    WqData() = 0'<----------CHANGE THESE VARIABLE NAMES
    WqDataArray() = 0'<------------------THEY WILL BE CONFUSING
    WqParamOrder() = BadDataIndicator
    WqLocs() = BadDataIndicator
    WqErrCount = 0
    WqTotErrs = 0
    WqPwrCycleWait = WQDeadCntMax 'Set to max threshold so it can power cycle the first time we reach the error threshold
    WqPwrCycleTries = 0
    OldEXOTime = 0
    SetEXOTimeFlg = False
    WqError = False
    WqDead = False
    Redeploy = True
    WipeFlag = False
    WqManualCycle = False
    #If TopBottom = True Then
      BtmWqData() = 0
      BtmWqDataArray() = 0
      BtmWqParamOrder() = BadDataIndicator
      BtmWqLocs() = BadDataIndicator
      BtmWqErrCount = 0
      BtmWqTotErrs = 0
      BtmWqPwrCycleWait = WQDeadCntMax
      BtmWqPwrCycleTries = 0
      BtmOldEXOTime = 0
      BtmWqError = False
      BtmWqDead = False
      BtmRedeploy = True
      BtmWipeFlag = False
      BtmWqManualCycle = False
    #EndIf
    #If WqSonde = "WQ_SERIAL_BURST" Then
      RecBurstFlag = False
      GetBurst = False
      BurstPeriod = 1000
    #EndIf
  #EndIf 'If WqSonde <> NONE
  #If HasModem = True Then
    IsModemNClosed = True
    KeepModemOn = True
    ModemHrsOff = 4
    If IsSubmersed = False AND IsModemNClosed = True Then
      #If LoggerType = CR1000 Then
        SW12(0) 'turn on telemetery if there is a Normally closed relay present.
      #EndIf
      #If LoggerType = CR6 Then
        SW12(1,0)
      #EndIf
    Else
      #If LoggerType = CR1000 Then
        SW12(1) 'turn on telemetery if there's no NC relay present
      #EndIf
      #If LoggerType = CR6 Then
        SW12(1,1)
      #EndIf
    EndIf
    IsModemOn = True
  #EndIf
  #If HasIridium Then
    IridiumManualCycle = False
  #EndIf
  #If HasHMS = True Then
    WeBad = False
    HMS_Disable = False
    HMS_BadThresh = 240
    HMS_24hrcount = 0
    HMS_Manual = False
    #If HasVM = True Then
      HMS_VMcount = 0
      HMS_VMFlag = False
      VM_Thresh = 670
    #EndIf
    #If WqSonde <> "NONE" Then
      HMS_WQcount = 0
      HMS_WqFlag = False
      WQ_Thresh = 1440
      #If TopBottom = True Then
        HMS_BtmWQCount = 0
        HMS_BtmWqFlag = False
        BtmWqThresh = 1440
      #EndIf
    #EndIf
    #If HasModem = True Then
      HMS_ModCount = 0
      HMS_ModFlag = False
      Mod_Thresh = 1440
    #EndIf
  #EndIf
EndSub

'================= MOD TIME CALCULATIONS =========================
Sub CalcMods
  RealSeconds = (Hour * 3600) + (Minute * 60) + Second
  'see if time is close to 15 minute or Day Interval
  Mod5Minutes = RealSeconds MOD 300
  Mod15Minutes = RealSeconds MOD 900
  Mod60Minutes = RealSeconds MOD 3600
  ModDay = RealSeconds MOD 86400
EndSub

'=============== SET UP COM PORTS FOR CR6 =====================
Sub SetPorts
  #If LoggerType = CR1000 Then
    ExitSub 'don't need to set CommsMode for CR1000
  #ElseIf LoggerType = CR6 Then
    #If HasVM = True Then
      If (AdcpPort = ComC1) OR (AdcpPort = ComC3) Then
        UseCommsZeroForADCP = True
      EndIf
    #EndIf 'if we have VM
    #If WqSonde <> "NONE" Then
      If WqSerialPort = ComC1 OR WqSerialPort = ComC3 Then
        WqUseCPort = True 'Variable to indicate if WQ is in the C port
      EndIf
      If IsWqMax232 = True AND WqUseCPort = True Then ' if sonde is using Max232 and is in a C port
        UseCommsOneForSonde = True 'then me need to use comms mode one to speak TTL
      EndIf
      If IsWqMax232 = False AND WqUseCPort = True Then 'ifsonde isn't using a Max232 and is in a c port
        UseCommsZeroForSonde = True 'then we need to uses comms mode zero to speak standard RS232
      EndIf
      #If TopBottom = True Then
        If BtmWqSerialPort = ComC1 OR BtmWqSerialPort = ComC3 OR BtmWqSerialPort = ComRS232 Then
          BtmWqUseCPort = True
        EndIf
        If IsBtmWqMax232 = True AND BtmWqUseCPort = True Then
          UseCommsOneForBtmSonde = True
        EndIf
        If IsBtmWqMax232 = False AND BtmWqUseCPort = True Then
          UseCommsZeroForBtmSonde = True
        EndIf
      #EndIf
    #EndIf 'if sonde is in serial mode
  #EndIf 'Loggertype declaration
EndSub


'=============== GET SYSTEM INFORMATION =======================
'      Pulling Data from Status Table, checking battery, temp, errors, etc.
Sub GetSysInfo
  ScanStart = Timer(DebugTimer,mSec,2) 'Start a timer to time all functions
  ScanStart = ScanStart/1000 'convert mSec to seconds
  Battery (StationVolts) 'get battery volts
  PanelTemp(PTempC,60)
  PTempF = PTempC * 9/5 + 32
  SerNum = Status.SerialNumber(1,1)
  OSVers = Status.OSVersion(1,1)
  Program = Status.ProgName(1,1)
  ProgErrors = Status.ProgErrors(1,1)
  Low12Volts = Status.Low12VCount(1,1)
  LithBat = Status.LithiumBattery(1,1)
  SkipScans = Status.SkippedScan(1,1)
  FreeCFMem = Status.CardBytesFree(1,1)
EndSub

'============== ZERO COUNTERS/FLAGS =========================
Sub ZeroErrCounters
  #If HasVM Then
    BadBinCnt = 0
    BadEnsemble = 0
    BadEnsCount = 0
    VMRestartAttempts = 0
    BadStgCountTot = 0 'initialize bad stage counter
    BadStg2CntTot = 0
    BadPS1CntTot = 0
    BadPS2CntTot = 0
    BadUpbeamCntTot = 0
    BadVMPressCntTot = 0
    StgOutOfBndCntTot = 0
    Stg2OutOfBndCntTot = 0
    BadQCount = 0
    BadVelCount = 0 'initialize counter
    NewADCP = False
    NewPS1 = False
    NewPS2 = False
  #EndIf
  #If WqSonde <> "NONE" Then
    WqPwrCycleTries = 0 'set counter to zero at midnight
    WqTotErrs = 0
    #If TopBottom = True Then
      BtmWqPwrCycleTries = 0 'set counter to zero at midnight
      BtmWqTotErrs = 0
    #EndIf
  #EndIf
  '  CDMAFailure = False
EndSub

'======================= Set Last Scan =====================
'Stores current hour and minute in the LastScan Variable
Sub GetLastScan
  RealTime (rTime()) 'get real time array
  If Minute >= 0 AND Minute < 10 Then
    LastScan = Hour + ":0" + Minute
  Else
    LastScan = Hour + ":" + Minute
  EndIf
EndSub

'================ Zero out all Timers =====================
'     Force to NANs after each scan. Then they'll be NAN if sub isn't used
Sub ZeroTimers
  #If HasVM = True Then 'has VM
    WakeVMTimer() = BadDataIndicator
    VMLoopTimer() = BadDataIndicator
    ZeroVMTimer() = BadDataIndicator
    CheckSumTimer() = BadDataIndicator
    MainDecodeTimer() = BadDataIndicator
    OneMinCalcTimer() = BadDataIndicator
    VMMemTimer() = BadDataIndicator
    VMProcTimer() = BadDataIndicator
    BeamChkTimer() = BadDataIndicator
    CalcQTimer() = BadDataIndicator
    GetStgTimer() = BadDataIndicator
    PSTimer() = BadDataIndicator
    SetTFTimer() = BadDataIndicator
    SetTSTimer() = BadDataIndicator
    #If UseAutoRange = True Then 'auto range
      CalcRangeTimer() = BadDataIndicator
    #EndIf 'end auto range
    #If StoreAllToCard = True Then 'store to card
      StoreToCrdTimer() = BadDataIndicator
      ChkSpikeTimer() = BadDataIndicator
      AddSpikeTimer() = BadDataIndicator
    #EndIf 'end store to card
  #EndIf 'end has vm
  #If WqSonde <> "NONE" Then
    RedeployTimer() = BadDataIndicator
    GetWqTimer() = BadDataIndicator
    WipeTime = BadDataIndicator
    #If TopBottom = True Then
      BtmRedeployTimer() = BadDataIndicator
      BtmGetWqTimer() = BadDataIndicator
      BtmWipeTime = BadDataIndicator
    #EndIf 'if top bottom
    #If WqSonde = "WQ_SERIAL_BURST" Then
      SetBurstTimer() = BadDataIndicator
      FillBurstTimer() = BadDataIndicator
      ProcBurstTimer() = BadDataIndicator
      #If TopBottom = True Then
        BtmSetBurstTimer() = BadDataIndicator
        BtmFillBurstTimer() = BadDataIndicator
        BtmProcBurstTimer() = BadDataIndicator
      #EndIf 'if top bottom
    #EndIf 'if burst
  #EndIf 'if sonde present
  #If HasSuna = True Then
    WipeStart = BadDataIndicator
    WipeEnd = BadDataIndicator
    SunaWipeTotTime = BadDataIndicator
    SunaSampleStart = BadDataIndicator
    SunaOnTime = BadDataIndicator
    SunaProcessStart = BadDataIndicator
    SunaProcessEnd = BadDataIndicator
    SunaProcessTotTime = BadDataIndicator
    SunaWipeTime = BadDataIndicator
    SunaMissed = False
    SunaReady = False
    WipeSuna = False
  #EndIf 'has suna
  DataTabsTimer() = BadDataIndicator
  AQTabTimer() = BadDataIndicator
EndSub

'============== VM ONLY SUBROUTINES =========================
#If HasVM = True Then 'If there's a VM in the system

  ' ----------------Power System -------------------------------
  ' This was originally designed to manually turn ADCP on or off
  ' for acoustic telemetry studies, then modified for a submersed
  ' data logger without a relay. Suggest keeping in case special
  ' projects come up where we want to turn off instrument for some period
  Sub ToggleVMPower
    Select Case IsSubmersed
    Case False
      If VMPower = True Then
        ExitSub
      EndIf
      If VMPower = False Then 'If user instrument OFF
        SerialFlush (AdcpPort)
        'Turn Power on and off to ADCP
        If IsVMNClosed Then
          PortSet (VMSwitchPort,1) 'assumes NC relay
        Else
          PortSet (VMSwitchPort,0) 'NO relay
        EndIf
      EndIf
    Case True
      If VMPower = True Then
        #If LoggerType = CR1000 Then SW12(1)
        #ElseIf LoggerType = CR6 Then SW12(1,1)
        #EndIf
        ExitSub
      Else
        SerialFlush (AdcpPort)
        #If LoggerType = CR1000 Then SW12(0)
        #ElseIf LoggerType = CR6 Then SW12(1,0)
        #EndIf
      EndIf
    End Select
  EndSub


  '------------------- Set up VM Serial Port ------------------------
  Sub OpenADCPPort
    #If LoggerType = CR6 Then
      If (IsVmMax232 = True) AND (AdcpPort <> ComMe) Then
        If UseCommsZeroForADCP Then
          SerialOpen (AdcpPort,VmBaud,19,0,2000,0)'open ADCP PORT with 2000 byte buffer using format 19
        Else
          SerialOpen (AdcpPort,VmBaud,19,0,2000)
        EndIf
      Else
        If UseCommsZeroForADCP Then
          SerialOpen (AdcpPort,VmBaud,3,0,2000,0)'open ADCP PORT with 2000 byte buffer using format 3
        Else
          SerialOpen (AdcpPort,VmBaud,3,0,2000)
        EndIf
      EndIf
    #Else
      If (IsVmMax232 = True) AND (AdcpPort <> ComMe) Then
        SerialOpen (AdcpPort,VmBaud,19,0,2000)'open with 2000 byte buffer using format 19
      Else
        SerialOpen (AdcpPort,VmBaud,3,0,2000) 'open ADCP PORT with 2000 byte buffer using format 3
      EndIf
    #EndIf
  EndSub

  '================== Cycle power to ADCP ============================
  ' Used if logger hasn't gotten data in X time or if user manually wants
  ' a power cycle to the instrument.
  Sub CycleVMPower
    Select Case IsSubmersed
    Case False
      SerialFlush (AdcpPort)
      'Turn Power on and off to ADCP assuming NC relay
      If IsVMNClosed Then
        PortSet (VMSwitchPort,1 )
        Delay (1,3,Sec)
        PortSet (VMSwitchPort,0)
      Else
        PortSet (VMSwitchPort,0 )
        Delay (1,3,Sec)
        PortSet (VMSwitchPort,1)
      EndIf
    Case True
      SerialFlush (AdcpPort)
      #If LoggerType = CR1000 Then SW12(0)
      #ElseIf LoggerType = CR6 Then SW12(1,0)
      #EndIf
      Delay (1,3,Sec)
      #If LoggerType = CR1000 Then SW12(1)
      #ElseIf LoggerType = CR6 Then SW12(1,1)
      #EndIf
    EndIf
  EndSub

  '================= VM Center Time =======================
  '    Used to calculate a timestamp that reflects the
  '    Center of the VM ensemble
  Sub VMCenter
    Dim NumSecs As Long 'Number of seconds since Jan 1, 1990
    Dim MidTime As Long 'Midpoint of Ensemble in seconds
    MidTime = ((EnsPings/2) + 2)/2 'WP60, VP3, 30s for WP, 1.5s for VP = ~32s, /2 = 16
    NumSecs = Debugger.TimeStamp(1,1)'Format 1 = Number of seconds since 1990, second 1 = 1 record ago, so use previous minute
    NumSecs = NumSecs + VMSecond + MidTime 'Use VMSecond from PD0 (start of ensemble) and EnsPings to calculate estimated center of sample
    'This assumes 0.5s TP and VP3. Resolution of SecSince1990 is nearest second, so 1.5s will produce same
    ADCPCenterTime = SecsSince1990(NumSecs,4) 'Calculates timestamp string in "yyyy-MM-dd HH:mm:ss" format and stores in ADCPCenterTime string
  EndSub


  '================== SOFTWARE BREAK ======================
  '   Sends +++ to VM to initialize a break
  Sub SoftwareBreak
    SerialOut (AdcpPort,"+++",CHR(62),2,50)'send alt break command twice, wait for >
    SerialIn (Banner,AdcpPort,25,CHR(62),100)'get banner from ADCP
    SerialFlush (AdcpPort)
    SentBreak = True
  EndSub

  '==================== SET ADCP TIME ==============================
  Sub SetVMTime
    SetTSStart = Timer(DebugTimer,msec,4)
    SetTSStart = SetTSStart/1000
    FTimeIn = 3 'Set FTime input argument to be "TS" formatting to set ADCP clock
    SerialFlush(AdcpPort) 'Make sure buffer is empty
    If IsVADCP = True Then 'the VADCP needs a CSTOP command to get into command mode
      If SentBreak = False Then
        SerialOut (AdcpPort,"+++","",0,100)'send alt break command
        Delay (1,1,Sec)'wait for reply
        SerialIn (Banner,AdcpPort,100,-1,100)'get banner from ADCP
        SerialFlush (AdcpPort)
        SentBreak = True
      EndIf
      SerialOut (AdcpPort,"CSTOP" + CHR(13) + CHR(10),"",0,100)
      SerialIn (Warning,AdcpPort,100,-1,100)
      SerialFlush (AdcpPort)
      VMTimeString = "TS" + Ftime(Public.Timestamp)
      SerialOut (AdcpPort,VMTimeString + CHR(13) + CHR(10),"",0,100)
      SerialIn (Warning,AdcpPort,100,-1,55) 'get echo of CS command
      Delay (1,1,Sec)'wait for reply
      SerialOut (AdcpPort,"CS"+ CHR(13) + CHR(10),"",0,100)
      SerialIn (CSCmd,AdcpPort,100,-1,100) 'get echo of CS command
      SerialFlush (AdcpPort)
      SetVMTimeFlg = False
      SentBreak = False
      SetTSEnd = Timer(DebugTimer,mSec,4)
      SetTSEnd = SetTSEnd/1000
      SetTSTotTime = SetTSEnd - SetTSStart
      ExitSub
    Else
      If SentBreak = False Then
        Call SoftwareBreak
      EndIf
      VMTimeString = "TS" + Ftime(Public.Timestamp)
      SerialOut (AdcpPort,VMTimeString + CHR(13) + CHR(10),"",0,15)
      SerialIn (TSEcho,AdcpPort,15,-1,55) 'get echo of TS command
      SerialFlush(AdcpPort)
      Delay(1,100,mSec)
      Call SetTF
      SetVMTimeFlg = False
      SentBreak = False
    EndIf
    SetTSEnd = Timer(DebugTimer,mSec,4)
    SetTSEnd = SetTSEnd/1000
    SetTSTotTime = SetTSEnd - SetTSStart
  EndSub

  '==================== SET START OF ENSEMBLE =======================
  ' This sub is designed to specify the exact time the VM should start pinging
  ' using the "TF" command
  Sub SetTF
    SetTFStart = Timer(DebugTimer,mSec,4)
    SetTFStart = SetTFStart/1000
    If IsVADCP = True OR VMHasVertical OR VMHasBottomTrack Then ExitSub 'VADCP, Sentinel V and RiverPro don't have option for TF
    FTimeIn = 2 'Set up for TF command, format like above, but set the seconds and 1 min forward
    VMTimeString = "TF" + Ftime(Public.TimeStamp) 'Set Time string to appropriate value, + 1 min, at VMStartSec
    If SentBreak = False Then 'If we didn't send a break already, then send a break signal
      Call SoftwareBreak
    EndIf
    Delay(1,100,mSec)
    SerialOut (AdcpPort,VMTimeString + CHR(13) + CHR(10),"",0,25)
    SerialIn (TFEcho,AdcpPort,25,-1,55)
    SerialFlush(AdcpPort)
    Delay(1,100,mSec) '0.10s delay before issuing CS command
    SerialOut (AdcpPort,"CS"+ CHR(13) + CHR(10),"",0,25)
    SerialIn (CSCmd,AdcpPort,25,-1,100) 'get echo of CS command
    SerialFlush(AdcpPort)
    SentBreak = False
    SendTF = False
    SetTFEnd = Timer(DebugTimer,mSec,4)
    SetTFEnd = SetTFEnd/1000
    SetTFTotTime = SetTFEnd - SetTFStart
  EndSub

  '================ Wake VM ==========================
  ' Designed to "wake up" the VM, cycles the power and then
  ' continues to set TF and issue CS command
  Sub WakeVM
    WakeVMStart = Timer(DebugTimer,msec,4)
    WakeVMStart = WakeVMStart/1000
    Banner = ""
    CSCmd = ""
    Call CycleVmPower 'Cycle the Power of for VM
    SerialFlush(AdcpPort) 'Ensure serial buffer is empty
    If IsVADCP = True Then
      If SentBreak = False Then ' if we haven't sent a break, issue one
        SerialOut (AdcpPort,"+++","",0,100)'send alt break command
        Delay (1,1,Sec)'wait for reply
        SerialIn (Banner,AdcpPort,100,-1,100)'get banner from ADCP
        SerialFlush (AdcpPort)
        SentBreak = True
      EndIf 'if sentbreak = false
      SerialOut (AdcpPort,"CSTOP" + CHR(13) + CHR(10),"",0,100) 'stop pinging
      SerialIn (CSCmd,AdcpPort,100,-1,100)
      SerialFlush (AdcpPort)
      Delay (1,1,Sec)
      SerialOut (AdcpPort,"CS"+ CHR(13) + CHR(10),"",0,100)
      SerialIn (CSCmd,AdcpPort,100,-1,100) 'get echo of CS command
      SerialFlush (AdcpPort)
      SentBreak = False
      VMRestartAttempts = VMRestartAttempts + 1
    Else
      Call SetVMTime 'By calling this sub, we send a software break (+++), if necessary, set TS, SetTF, then issue CS
      VMRestartAttempts = VMRestartAttempts + 1
    EndIf
    WakeUpVM = False 'Set flag back to false so it doesn't continuously cycle power
    VMDeadCount = 0 'set to zero and try again
    WakeVMEnd = Timer(DebugTimer,msec,4)
    WakeVMEnd = WakeVMEnd/1000
    WakeVMTotTime = WakeVMEnd-WakeVMStart
  EndSub

  '=============== Check Workhorse Memory =====================
  Sub GetVMFreeMem
    GetVMMemStart = Timer(DebugTimer,msec,4)
    GetVMMemStart = GetVMMemStart/1000
    Banner = ""
    Warning = ""
    If IsWorkHorse = False Then
      GetVMMemEnd = Timer(DebugTimer,msec,4)
      GetVMMemEnd = GetVMMemEnd/1000
      GetVMMemTotTime = GetVMMemEnd-GetVMMemStart
      ExitSub 'if it's not a workhorse, don't bother checking memory
    EndIf
    If IfTime(10,1440,Min) AND RecCalibData = False AND OneMinConsistent = False Then 'if 10min after midnight, and we aren't recording 1min data
      If SentBreak = False Then
        Call SoftwareBreak
      EndIf
      Delay (1,100,mSec)
      SerialOut (AdcpPort,"RS?" + CHR(13) + CHR(10),"",0,25) 'Send "RS?" to check see how much memory is free on WH recorder
      SerialIn (VMMemString,AdcpPort,25,-1,150) 'Get response back from "RS?" command in "VMMemString" variable
      SerialFlush (AdcpPort)
      Call SetVMTime
      SendCMD = False
      VMMemFree = Mid (VMMemString,17,3)    ' Parse amount of memory free out of VM Response
    Else
      VMMemString = "" 'make this string blank
      If VMMemFree <= VMLowMemVal Then      'Set flag to notify if low memory on VM (determined per site), how many times?
        VMLowMem = True
        VMLowMemCount = VMLowMemCount + 1
      Else
        VMLowMem = False
        VMLowMemCount = 0
      EndIf
      If VMMemFree = 0 Then                 'Set Flag to notify if VM is out of memory, how many times?
        VMNoMem = True
        VMNoMemCount = VMNoMemCount + 1
      Else
        VMNoMem = False
        VMNoMemCount = 0
      EndIf
    EndIf
    GetVMMemEnd = Timer(DebugTimer,msec,4)
    GetVMMemEnd = GetVMMemEnd/1000
    GetVMMemTotTime = GetVMMemEnd-GetVMMemStart
  EndSub

  '================ EraseWH Documentation =======================
  ' If user issued a command to erase the memory then store a flag
  Sub EraseWH
    If CMD = "RE ErAsE" Then 'If command to erase WH recorder is sent then...
      RecEraseString = Mid (Warning,23,15)  'Parse string to get "Recorder erased" from response
    Else
      RecEraseString = ""
    EndIf
    If RecEraseString = "Recorder erased" Then 'if the recorder was successfully erased, flag it in data table
      RecErased = True
    EndIf
    If IfTime (10,1440,min) AND RecErased = True Then 'Reset Recorder erase flag to false at 00:10 (allows time for flag to be written to QAQC table).
      RecErased = False
    EndIf
  EndSub

  '================== Send Custom Command To VM =============================
  Sub SendSetup
    If SendCMD = True Then 'if user wants to send a command
      Banner = ""
      Warning = ""
      CSCmd = ""
      If CMD = "" Then 'if the command line is blank
        SendCMD = False
        ExitSub
      EndIf
      SerialFlush (AdcpPort) 'Empty the serial buffer
      If SentBreak = False Then 'We haven't sent a break yet
        Call SoftwareBreak
      EndIf 'we sent a break
      'send commands to HADCP
      Delay (1,100,mSec)'delay before next command
      SerialOut (AdcpPort,CMD + CHR(13) + CHR(10),"",0,25)'Send user entered command
      #If GetNoiseFloor = True Then
        If CMD = "PT3" Then 'if PT3 is issued
          SerialIn (PT3String,AdcpPort,85,"",2000)'Get PT3 command response
        Else
          SerialIn (Warning,AdcpPort,25,"",75) 'store any other response to CMD in "Warning"
        EndIf 'if PT3 is the command
      #Else 'If Noisefloor isn't wanted, simply store into "warning"
        SerialIn (Warning,AdcpPort,25,"",75) 'store any other response to CMD in "Warning"
      #EndIf 'determine if Noisefloor
      SerialFlush (AdcpPort)
      Call SetVMTime
      SendCMD = False
      CMD = ""
      Call EraseWH
      #If GetNoiseFloor = True Then
        Call ParsePT3
        CallTable NoiseFloor
      #EndIf
    EndIf
  EndSub

  '=====================Parse the PT3 string ===========================
  ' if user wants noise floor, parse the PT3 response
  #If GetNoiseFloor = True Then
    Sub ParsePT3 'This routine parses the response received from the ADVM when it's been issued a "PT3" command for CHANNEL MASTER ONLY.
      NoiseFlrParsed = ""
      Erase NoiseHGainW()
      Erase NoiseLGainW()
      Erase NoiseHGainN()
      Erase NoiseLGainN()
      'The final product is the "Noise Floor" for each beam. The commented out sections are for Beams 3 and 4, if we wanted them.
      If (IsCM = False) AND (IsWorkHorse = False) Then ExitSub 'if instrument is not a channel master or Workhorse then exit subroutine
      If CMD = "PT3" Then
        VisitReason = "Sent PT3 Command to ADVM"
        'StartString = InStr (1600,Warning,FilterString,2) 'Parse PT3 response into correct variables
        If IsWorkHorse Then
          'Workhorse parse stuff here
          StartString = InStr (1,PT3String,FilterString,2) 'Parse PT3 response into correct variables
          NoiseFlrParsed = Mid (PT3String,StartString,104)
          NoiseHGainW(1) = Mid (NoiseFlrParsed,10,2)
          NoiseHGainW(2) = Mid (NoiseFlrParsed,15,2)
          NoiseHGainW(3) = Mid (NoiseFlrParsed,20,2)
          NoiseHGainW(4) = Mid (NoiseFlrParsed,25,2)
          NoiseLGainW(1) = Mid (NoiseFlrParsed,50,2)
          NoiseLGainW(2) = Mid (NoiseFlrParsed,55,2)
          NoiseLGainW(3) = Mid (NoiseFlrParsed,60,2)
          NoiseLGainW(4) = Mid (NoiseFlrParsed,65,2)
        Else
          StartString = InStr (1,PT3String,FilterString,2) 'Parse PT3 response into correct variables
          NoiseFlrParsed = Mid (PT3String,StartString,104)
          NoiseHGainW(1) = Mid (NoiseFlrParsed,33,2)
          NoiseHGainW(2) = Mid (NoiseFlrParsed,37,2)
          'NoiseHGainW(3) = Mid (NoiseFlrParsed,41,2)
          'NoiseHGainW(4) = Mid (NoiseFlrParsed,45,2)
          NoiseLGainW(1) = Mid (NoiseFlrParsed,52,2)
          NoiseLGainW(2) = Mid (NoiseFlrParsed,56,2)
          'NoiseLGainW(3) = Mid (NoiseFlrParsed,60,2)
          'NoiseLGainW(4) = Mid (NoiseFlrParsed,64,2)
          NoiseHGainN(1) = Mid (NoiseFlrParsed,71,2)
          NoiseHGainN(2) = Mid (NoiseFlrParsed,75,2)
          'NoiseHGainN(3) = Mid (NoiseFlrParsed,79,2)
          'NoiseHGainN(4) = Mid (NoiseFlrParsed,83,2)
          NoiseLGainN(1) = Mid (NoiseFlrParsed,90,2)
          NoiseLGainN(2) = Mid (NoiseFlrParsed,94,2)
          'NoiseLGainN(3) = Mid (NoiseFlrParsed,98,2)
          'NoiseLGainN(4) = Mid (NoiseFlrParsed,102,2)
        EndIf
      Else
        PT3String = ""
      EndIf 'if cmd = pt3
      PT3String = ""
    EndSub
  #EndIf 'if user want's to get noise floor

  '======================= Sub to pull ADCP Data in from Serial Buffer =============================
  'The following code looks for the incoming data stream,stores the data in an array of longs, and passes the data through
  'a series of checks.  If those checks fail then the scan is truncated, the ruesulting
  'data is flagged, and the serial port is flushed.  On the next scan the next valid ensemble
  'is read, if there is good data in the buffer then that should be reflected in the output.
  'An array of longs is needed to collect the data because the campbell cannot read the
  'binary PD0 ensemble into a string.  When it hits a blank (HEX 00) it terminates the
  'string cutting off the rest of the ensemble'
  'so to get around this, we read in the data (one byte at a time) and put it into an
  'array of longs.  But at this point there is another problem. RDI transmits binary
  'data in "little indian" fashon (least significant byte first), but longs (two bytes)
  'are stored by campbell "big indian" (most significant byte first), so after we read
  'the byte in (to a temporary long),it is in the most significant byte.  We then must use the
  'MoveBytes statement to move it into the least significant position and store it in
  'the long array.
  Sub GetVmData
    VMLoopStart = Timer(DebugTimer,msec,4)
    VMLoopStart = VMLoopStart/1000
    EnsBytes = 0
    SubScans = 0
    ADCPDone = False
    NumBytes = 0 'Zero counters for ADCP Decoder
    InCount=0
    For ADCPLoop = 1 To 2 'do the loop twice, in case ensemble wasn't there the first time through
      Do While SerialInChk(AdcpPort) 'check the buffer
        InCount=InCount+1
        SerialInBlock(AdcpPort,Nums(1),1) 'pull from the AdcpPort buffer into "Nums(1)", 1 character at a time
        MoveBytes(LongArray(InCount),3,Nums(1),0,1)'this is required because ADCP outputs bytes (little indean - big indian) in the reverse order that is done in the cr10000 (Big-indian Little indian)
        If InCount > 5 Then 'if we've gotten more than 5 bytes
          If LongArray(1) <> 127 OR LongArray(2) <> 127 'These characters are at the start of each ensemble hex 7F7F, check that the bytes match
            FramingError = FramingError + 1 'if they don't, FramingError
            InCount = InCount-2 'discard junk bytes and continue reduce "InCount" to look at the beginning of ens again
          EndIf
        EndIf
        NumBytes = InCount 'number of bytes = InCount
        If InCount > 4 Then 'get number of bytes per ensemble from adcp data
          LSB = LongArray(3)
          MSB = LongArray(4)
          EnsBytes = LSB + (MSB*256)
        EndIf
        If NumBytes > 4 AND EnsBytes = NumBytes - 2 Then 'we have all the bytes, let's get out of both loops
          SerialFlush(AdcpPort) 'We've stored all the bytes in the LongArray and rearranged them
          ADCPDone = True 'We're done
          ExitDo 'get out of the loop once we've gotten everything
        EndIf
        Delay (1,30,uSec) 'delay before starting next iteration
      Loop
      If FramingError > 0 Then
        HeaderMismatch = HeaderMismatch + 1
        FramingError = 0
      EndIf
      SubScans = SubScans + 1 'Count number of loops we tried
      If ADCPDone Then
        HeaderMismatch = 0
        ExitFor 'Exit the For-Next loop
      EndIf
      Delay (1,1000,mSec) 'Wait a bit for incoming ensemble, but not more than 2 seconds
    Next
    If HeaderMismatch > 0 Then
      VMdataIn = False 'header not found in the right spot
    EndIf
    If NumBytes < 1 Then 'There was nothing in the buffer
      VMdataIn = False
      NumbytesZero = NumbytesZero + 1
    Else
      NumbytesZero = 0
    EndIf
    If NumBytes = ((EnsBytes *2) +4) Then 'there were two ensembles in the buffer
      VMdataIn = False
    EndIf
    ReceivedBytes = NumBytes
    If NumbytesZero > 5 Then 'if 5 consecutive minutes with 0 bytes
      Call ZeroVMArrays
      NumbytesZero = 0
    EndIf
    If VMdataIn = False Then 'if we didn't find right header, no bytes, or double bytes then it's "dead"
      VMDeadCount = VMDeadCount + 1
      BadEnsemble = BadEnsemble + 1
      #If HasHMS = True Then
        HMS_VMcount = HMS_VMcount + 1
        If HMS_VMcount >= HMS_BadThresh Then
          HMS_VMFlag  = True
        EndIf
      #EndIf
    EndIf
    If VMDeadCount >= VMDeadCntMax Then
      WakeUpVM = True 'set flag to try to reset VM
      AdcpSN = 0 ' Zero out the SN so when something comes back online, it'll auto send the TS/TF
    EndIf
    SerialFlush (AdcpPort)
    VMLoopEnd = Timer(DebugTimer,msec,4)
    VMLoopEnd = VMLoopEnd/1000
    VMLoopTotTime = VMLoopEnd-VMLoopStart
  EndSub

  '==================== CALCULATE CHECKSUM =================================
  ' To have verification that we actually got the whole ensemble properly
  Sub ChecksumCheck
    ChkSumChkStart = Timer(DebugTimer,msec,4)
    ChkSumChkStart = ChkSumChkStart/1000
    'Get ensemble length (from the header)
    Dim CkSumCount As Long
    LSB = LongArray(3)
    MSB = LongArray(4)
    EnsembleLen = LSB + (MSB*256)
    'calculate checksum here to see if it matches the checksum sent by the ADCP
    CalcCheckSum = 0
    CkSumCount = 0
    For CkSumCount = 1 To EnsembleLen
      CalcCheckSum = CalcCheckSum + LongArray(CkSumCount)
    Next CkSumCount
    CalcCheckSum = 65535 AND CalcCheckSum
    EnsCheckSum = LongArray(CkSumCount)
    TempL = LongArray(CkSumCount + 1)
    EnsCheckSum = EnsCheckSum + TempL * 256
    ChkSumChkEnd = Timer(DebugTimer,msec,4)
    ChkSumChkEnd = ChkSumChkEnd/1000
    ChkSumChkTotTime = ChkSumChkEnd - ChkSumChkStart
  EndSub

  '======================= MAIN VM DECODER ===================================
  'Main Decoder for PD0 file.  This Is run after incoming data has passed checks in main program scan.
  'This decoder parses out the various data types and the varibles that are contained in the fixed header data type.
  'The variable data types are decoded in separate subroutines and those subroutines are called from this subroutine.

  Sub MainDecode
    MainDecodeStart = Timer(DebugTimer,msec,4)
    MainDecodeStart = MainDecodeStart/1000
    '-------------initialize vertical info
    #If VMHasVertical Then
      VerticalLeadOffset = NaN
      VerticalVelocityOffset = NaN
      VerticalRSSIOffset = NaN
      VerticalCorrOffset = NaN
      Dim Vertcount As Long
      For Vertcount = 1 To MaxBins
        VerticalVelocity(Vertcount) = BadVel
        VerticalRSSI(Vertcount) = BadVel
        VerticalCorr(Vertcount) = BadVel
        VerticalBinDisable(Vertcount) = True
      Next Vertcount
    #EndIf
    'end vertical initialize
    '-------------initialize Bottom Track info
    #If VMHasBottomTrack Then
      BtmTrackOffset = NaN
      BtmTrackPings = NaN
      BtmTrackMode = NaN
      Dim BotCount As Long
      For BotCount = 1 To MaxBeams
        BtmTrackRange(BotCount) = BadVel
        BtmTrackVelocity(BotCount) = BadVel
        BtmTrackRSSI(BotCount) = BadVel
        BtmTrackCorr(BotCount) = BadVel
        BtmRangeBeamDisable(BotCount) = True
        BtmVelBeamDisable(BotCount) = True
      Next BotCount
    #EndIf
    '---------------end bottom initialize

    Dim OffsetCounter As Long
    Dim TypeCounter As Long
    Dim IdCounter As Long
    'First decode PD0 header
    DataTypes = LongArray(6)
    DataTypes = DataTypes + 1 'Include the vertical data"
    OffsetCounter = 1
    'Get data offsets for each data type
    For TypeCounter = 1 To (DataTypes*2) Step 2
      LSB = LongArray(TypeCounter+6)
      MSB = LongArray(TypeCounter+7)
      Offsets(OffsetCounter)=(LSB + (MSB*256)) + 1
      OffsetCounter = OffsetCounter + 1
    Next TypeCounter
    'Get fixed leader offset
    FixedLeadOffset = Offsets(1)
    'Get variable leader offset
    VarLeadOffset = Offsets(2)
    'Now decode the fixed leader
    'get number of Beams
    NumBeams = LongArray(FixedLeadOffset + 8)
    'Get number of Bins
    NumADCPBins = LongArray(FixedLeadOffset + 9)
    If NumADCPBins >= MaxBins Then
      Numbins = MaxBins
      'fix for numadcp bins < maxbins
    Else
      Numbins = NumADCPBins
    EndIf
    'Get Pings per Ensemble
    LSB = LongArray(FixedLeadOffset + 10)
    MSB = LongArray(FixedLeadOffset + 11)
    EnsPings = LSB + (MSB * 256)
    'Get Bin Size
    LSB = LongArray(FixedLeadOffset + 12)
    MSB = LongArray(FixedLeadOffset + 13)
    BinSize = LSB + (MSB * 256)
    'Get Blanking distance
    LSB = LongArray(FixedLeadOffset + 14)
    MSB = LongArray(FixedLeadOffset + 15)
    BlankDist = LSB + (MSB * 256)
    EX = LongArray(FixedLeadOffset + 25)
    If EX <= 7 Then
      Coord = "BEAM"
      Select Case NumBeams
      Case 2
        Decode = "Radial Velocities - V1=Beam1 V2=Beam2 disregard V3 and V4"
      Case 3
        Decode = "Radial Velocities - V1=Beam1 V2=Beam2 V3=Beam3 disregard V4"
      Case 4
        Decode = "Radial Velocities - V1=Beam1 V2=Beam2 V3=Beam3 V4=Beam4"
      Case Else
        Decode = "System could not be decoded"
      End Select
      RecordAll = true 'Beam coordinates are only used by special studies
      UseDir = false
    EndIf
    If (EX <= 15) AND (EX > 7) Then
      Coord = "INST"
      Select Case NumBeams
      Case 2
        Decode = "Instrument Coordinates - V1=X V2=Y disregard V3 and V4"
        BiRatOK = True 'sets flag indication that this is a channel master in instrument coordinates and it's ok to use a bi-directional rating if needed
      Case 3
        Decode = "Instrument Coordinates - V1=X V2=Y disregard V3 V4=Error"
        If IsVADCP = False Then
          BiRatOK = True 'It's ok to use the bi-rating if it is a 3-beam system and NOT an uplooker
        Else
          BiRatOK = False
        EndIf
      Case 4
        Decode = "Instrument Coordinates - V1=X V2=Y V3=Z and V4=Error"
        BiRatOK = False 'Don't allow use of bi-rating with uplookers.
      Case Else
        Decode = "System could not be decoded"
      End Select
      UseDir = false
    EndIf
    If (EX <= 23) AND (EX > 15) Then
      Coord = "SHIP"
      Select Case NumBeams
      Case 2
        Decode = "Error! --  Cannot set CM to ship coordinates"
      Case 3
        Decode = "Ship Coordinates - V1=Port V2=Starbord V3=Z and V4=Error"
      Case 4
        Decode = "Ship Coordinates - V1=Port V2=Starbord V3=Z and V4=Error"
      Case Else
        Decode = "System could not be decoded"
      End Select
      UseDir = false
    EndIf
    If (EX <= 31) AND (EX > 23) Then
      Coord = "EARTH"
      Select Case NumBeams
      Case 2
        Decode = "Error! --  Cannot set CM to Earth coordinates"
      Case 3
        Decode = "Earth Coordinates - V1=East V2=North V3=Z and V4=Error"
        RecordAll = true 'Special studies also uses earth coordinates
        UseDir = false
      Case 4
        Decode = "Earth Coordinates - V1=East V2=North V3=Z and V4=Error"
        RecordAll = true 'Special studies also uses earth coordinates
      Case Else
        Decode = "System could not be decoded"
      End Select
    EndIf
    'get instrument s/n
    ADCPSN01 = LongArray(FixedLeadOffset + 57)
    ADCPSN02 = LongArray(FixedLeadOffset + 56)
    ADCPSN03 = LongArray(FixedLeadOffset + 55)
    ADCPSN04 = LongArray(FixedLeadOffset + 54)
    AdcpSN = ADCPSN04 + (ADCPSN03*256) + (ADCPSN02*65536) +(ADCPSN01*16777216)
    '  TestADCPSN = ADCPSN04 + (ADCPSN03*256) + (ADCPSN02*65536) +(ADCPSN01*16777216)

    'get Variable Header Data
    Call VarLeadDecode
    'Loop through remaining data types, verify thier profile IDs and assign proper offsets'  Other data can be accomodated here if need be IE percent good etc
    'If profile IDs match the required data types, then call the appropriate decoders
    IsCM = False
    IsVADCP = False
    IsWorkHorse = False
    For IdCounter = 3 To DataTypes
      LSB = LongArray(Offsets(IdCounter))
      MSB = LongArray(Offsets(IdCounter) + 1)
      TempID = LSB + (MSB * 256)
      IDWords(IdCounter) = TempID
      Select Case TempID
      Case CorrelationProfileID
        'Ok it matches Correlation ID
        CorrDatOffset = Offsets(IdCounter)
        Call CorrelationDecode
      Case RSSIProfileID
        'OK it matches RSSI ID
        RSSIDatOffset = Offsets(IdCounter)
        Call RSSIDecode
      Case VelocityProfileID
        'OK it matches Velocity ID
        VelDatOffset = Offsets(IdCounter)
        Call VelDecode

        #If VMHasVertical Then
        Case VertLeaderID
          VerticalLeadOffset = Offsets(IdCounter)

        Case VertVelocityID
          VerticalVelocityOffset = Offsets(IdCounter)

        Case VertRSSIID
          VerticalRSSIOffset = Offsets(IdCounter)

        Case VertCorrID
          VerticalCorrOffset = Offsets(IdCounter)

        #EndIf

        #If VMHasBottomTrack Then
        Case BottomTrackID
          BtmTrackOffset = Offsets(IdCounter)
          Call BtmTrackDecode
        #EndIf
      Case VMStageID
        'Ok it matches Surface track (vertical beam) Status ID
        VMStageDatOffset = Offsets(IdCounter)
        If NumBeams = 2 Then
          IsCM = True
        Else
          IsVADCP = True
          Call VADCPTransform
        EndIf
        If (IsCM = False) AND (IsVADCP = False)
          If (NumBeams = 4) OR (NumBeams = 3) Then IsWorkHorse = True 'It's a 4 beamworkhorse or 3 beam Hadcp)
        EndIf
        Call VMStageDecode

        '=======================================================================
      EndSelect
    Next IdCounter

    '=================================================================================
    'after all IDs have been checked then we can decode vertical info if it is present
    #If VMHasVertical Then
      'initialize Profile arrays
      'Check and call Vertical decode subs
      If VerticalLeadOffset <> NaN Then Call VertLeaderDecode
      If VerticalVelocityOffset <> Nan Then Call VertVelocityDecode
      If VerticalRSSIOffset <> NaN Then Call VertRSSIDecode
      If VerticalCorrOffset <> NaN Then Call VertCorrDecode
    #EndIf
    '====================================================================================
    'After calling all the decoders, Zero out the LongArray
    Erase (LongArray())
    MainDecodeEnd = Timer(DebugTimer,msec,4)
    MainDecodeEnd = MainDecodeEnd/1000
    MainDecodeTotTime = MainDecodeEnd-MainDecodeStart
  EndSub

  '============ VARIABLE LEADER DECODER ==========================
  'This Sub decodes the variable leader from the LongArray
  Sub VarLeadDecode
    VarLeadOffset = VarLeadOffset - 1 'to line up with RDI Documentation
    'When you decode 2 byte binary data, you have to multiply the most significant byte
    'by 256
    LSB = 0
    MSB = 0
    Temp = 0
    'get Ensemble Number
    LSB = LongArray(VarLeadOffset + 3)
    MSB = LongArray(VarLeadOffset + 4)
    MSB1 = LongArray(VarLeadOffset + 12)
    EnsembleNo = (65536 * MSB1) + (256 * MSB) + LSB
    'get Vm time
    VMYear = LongArray(VarLeadOffset + 5)
    VMMonth = LongArray(VarLeadOffset + 6)
    VMDay = LongArray(VarLeadOffset + 7)
    VMHour = LongArray(VarLeadOffset + 8)
    VMMinute = LongArray(VarLeadOffset + 9)
    VMSecond = LongArray(VarLeadOffset + 10)
    VMTime = VMYear + "/" + VMMonth + "/" + VMDay + " " + VMHour + ":" + VMMinute + ":" + VMSecond
    'get Buit in test results
    LSB = LongArray(VarLeadOffset + 13)
    MSB = LongArray(VarLeadOffset + 14)
    BIT = (256 * MSB) + LSB
    'get Heading
    LSB = LongArray(VarLeadOffset + 19)
    MSB = LongArray(VarLeadOffset + 20)
    VMHeading = ((256 * MSB) + LSB) * 0.01 'Heading scale factor
    'get Pitch
    LSB = LongArray(VarLeadOffset + 21)
    MSB = LongArray(VarLeadOffset + 22)
    Temp = (256 * MSB) + LSB
    If Temp > 32767 Then
      Temp = Temp - 65536
    EndIf
    VMpitch = Temp * 0.01 'Pitch scale factor
    'get Roll
    LSB = LongArray(VarLeadOffset + 23)
    MSB = LongArray(VarLeadOffset + 24)
    Temp = (256 * MSB) + LSB
    If Temp > 32767 Then
      Temp = Temp - 65536
    EndIf
    VMroll = Temp * 0.01 'Roll scale factor
    'Get Salinity
    LSB = LongArray(VarLeadOffset + 25)
    MSB = LongArray(VarLeadOffset + 26)
    Temp = (256 * MSB) + LSB
    ES = Temp
    'Get Temperature
    LSB = LongArray(VarLeadOffset + 27)
    MSB = LongArray(VarLeadOffset + 28)
    Temp = (256 * MSB) + LSB
    If Temp > 32767 Then
      Temp = Temp - 65536
    EndIf
    VMtempC = Temp * 0.01 'Temperature scale factor
    VMtempF = VMtempC * 9/5 + 32
    'get WHvolts
    VMVolts = LongArray(VarLeadOffset + 36)

    'get pressure from Workhorse
    WHpressure = 0
    WHTempM = 0
    WHTempK = 0
    WHPSTemp = 0
    DepthLSB = 0
    DepthLSB1 = 0
    DepthMSB = 0
    DepthMSB1 = 0
    'Get corrected Max pressure (depth) from ensemble
    DepthLSB = LongArray(VarLeadOffset + 49)
    DepthLSB1 = LongArray(VarLeadOffset + 50)
    DepthMSB = LongArray(VarLeadOffset + 51)
    DepthMSB1 = LongArray(VarLeadOffset + 52)
    WHPSTemp = (16777216 * DepthMSB1) + (65536 * DepthMSB) + (256 * DepthLSB1) + DepthLSB 'this seems quite large, Better call RDI
    If WHPSTemp <> 0 Then
      WHTempK = WHPSTemp/100 'convert from decapascals to kpa
      WHTempM = (WHTempK * (1.02-0.00069*ES))/10
      WHpressure = WHTempM * Meters_to_Feet 'convert to feet
    Else
      WHpressure = BadDataIndicator
    EndIf
  EndSub

  '======================== CORRELATION DECODER ========================
  Sub CorrelationDecode
    'initialize output Arrays
    For Bin = 1 To MaxBins
      For Beam = 1 To MaxBeams
        ensCorr(Bin,Beam) = 0
      Next Beam
    Next Bin
    Binstep = 1
    EnsBin = 0
    CorrDatOffset = CorrDatOffset + 1 'to get past 2 byte ID
    For Bin = 1 To Numbins 'Start at Bin 1 Beam 1
      nCorr = 0
      AccumCorr = 0
      Temp = CorrDatOffset + (4 * EnsBin) 'jump down 4 bytes each bin
      EnsBin = EnsBin + Binstep
      For Beam = 1 To NumBeams 'only grab one byte each loop
        AccumCorr = AccumCorr + LongArray(Temp + Beam)
        nCorr = nCorr + 1
        ensCorr(Bin,Beam) = LongArray(Temp + Beam) 'could also average here
      Next Beam
      Select Case nCorr 'average beams for each bin
      Case 0
        AvgCorr(Bin)= 0
      Case 1
        AvgCorr(Bin) = AccumCorr
      Case 2 To 4
        AvgCorr(Bin) = AccumCorr / nCorr
      Case Else
        AvgCorr(Bin) = 0
      EndSelect
    Next Bin
  EndSub

  '=============== RSSI DECODER ========================
  Sub RSSIDecode
    'initialize output Arrays
    For Bin = 1 To MaxBins
      For Beam = 1 To MaxBeams
        ensRSSI(Bin,Beam) = 0
      Next Beam
    Next Bin
    Binstep = 1
    EnsBin = 0
    RSSIDatOffset = RSSIDatOffset + 1 'to get past 2 byte ID
    For Bin = 1 To Numbins 'Start at Bin 1 Beam 1
      nRSSI = 0 'zero beamwise rssi counter
      AccumRSSI = 0 'zero beamwise rssi accumulator
      AvgRSSIAccum = 0 'zero binwise rssi accumulator
      AvgRSSIcounter = 0 'zero binwise rssi counter
      Temp = RSSIDatOffset + (4 * EnsBin) 'jump down 4 bytes each bin
      EnsBin = EnsBin + Binstep
      For Beam = 1 To NumBeams 'only grab one byte each loop
        AccumRSSI = AccumRSSI + LongArray(Temp + Beam)
        nRSSI = nRSSI + 1
        ensRSSI(Bin,Beam) = LongArray(Temp + Beam) 'could also average here
      Next Beam
      Select Case nRSSI 'average beams for each bin
      Case 0
        AvgRSSI(Bin)= 0
      Case 1
        AvgRSSI(Bin) = AccumRSSI
      Case 2 To 4
        AvgRSSI(Bin) = AccumRSSI / nRSSI
      Case Else
        AvgRSSI(Bin) = 0
      EndSelect
    Next Bin
    'calculate average RSSI from Swath of data (User Selected Bins)
    For Bin = AvgRSSIStartBin To AvgRSSIEndBin
      If AvgRSSI(Bin) <> 0 Then 'average the bins
        AvgRSSIAccum = AvgRSSIAccum + AvgRSSI(Bin)
        AvgRSSIcounter = AvgRSSIcounter + 1
      EndIf
    Next Bin
    If (AvgRSSIAccum <> 0) AND (AvgRSSIcounter <> 0) Then 'if either the accumulator is zero or the counter is zero then set avgrssi to bad
      AvgSwathRSSI = AvgRSSIAccum/AvgRSSIcounter
    Else
      AvgSwathRSSI = BadDataIndicator
    EndIf
  EndSub

  '================== VM STAGE DECODER =======================
  Sub VMStageDecode
    If IsWorkHorse Then
      VMpressure = BadDataIndicator
      VMupBeam = BadDataIndicator
      Exit Sub
    EndIf
    VMStageDatOffset = VMStageDatOffset - 1 'to line up with RDI Documentation
    'When you decode 4 byte binary data, you have to multiply the most significant byte
    'by 16777216
    '--------------Debugging variables
    DepthLSB = 0
    DepthLSB1 = 0
    DepthMSB = 0
    DepthMSB1 = 0
    '---------------Debugging variables
    Temp = 0
    TempM = 0
    LSBTemp = 0
    LSB1Temp = 0
    MSBTemp = 0
    MSB1Temp = 0
    '---------------------Get get corrected Surface track (depth) from ensemble
    DepthLSB = LongArray(VMStageDatOffset + 3)
    DepthLSB1 = LongArray(VMStageDatOffset + 4)
    DepthMSB = LongArray(VMStageDatOffset + 5)
    DepthMSB1 = LongArray(VMStageDatOffset + 6)
    VMTemp = (16777216 * DepthMSB1) + (65536 * DepthMSB) + (256 * DepthLSB1) + DepthLSB
    If VMTemp <> 0 Then
      TempM = VMTemp/10000
    Else
      TempM = BadDataIndicator
    EndIf
    VMupBeam = TempM 'This is the range to the surface from the upward beam
    '-----------------------------------------------------get uncorrected depth
    LSBTemp = LongArray(VMStageDatOffset + 7)
    LSB1Temp = LongArray(VMStageDatOffset + 8)
    MSBTemp = LongArray(VMStageDatOffset + 9)
    MSB1Temp = LongArray(VMStageDatOffset + 10)
    '    RawDepth = (16777216 * MSB1Temp) + (65536 * MSBTemp) + (256 * LSB1Temp) + LSBTemp
    '----------------Get Signal Amplitude at Surface
    LSBTemp = LongArray(VMStageDatOffset + 12)
    '    DepthSig = LSBTemp
    '--------------------------------Get Percent Good of Surface Track
    LSBTemp = LongArray(VMStageDatOffset + 13)
    '    PercGoodSurface = LSBTemp
    LSB = 0
    L1SB = 0
    MSB = 0
    M1SB = 0
    Temp = 0
    TempM = 0
    'Get corrected Max pressure (depth) from ensemble
    LSB = LongArray(VMStageDatOffset + 43)
    L1SB = LongArray(VMStageDatOffset + 44)
    MSB = LongArray(VMStageDatOffset + 45)
    M1SB = LongArray(VMStageDatOffset + 46)
    VMPSTemp = (16777216 * M1SB) + (65536 * MSB) + (256 * L1SB) + LSB 'this seems quite large, Better call RDI
    If VMPSTemp <> 0 Then
      TempM = VMPSTemp/10000
    Else
      TempM = BadDataIndicator
    EndIf
    VMpressure = TempM
    VMupBeam = VMupBeam * Meters_to_Feet 'convert to Feet
    VMpressure = VMpressure * Meters_to_Feet 'convert to Feet
    If VMupBeam = BadDataIndicator Then 
    BadUpbeamFlg = True
    BadUpbeamCnt = BadUpbeamCnt + 1
    BadUpbeamCntTot = BadUpbeamCntTot + 1
    Else
      BadUpbeamFlg = False
      BadUpbeamCnt = BadUpbeamCnt
      BadUpbeamCntTot = BadUpbeamCntTot
    EndIf
    If VMpressure = BadDataIndicator Then
      BadVMPressFlg = True
      BadVMPressCnt = BadVMPressCnt + 1
      BadVMPressCntTot = BadVMPressCntTot + 1
    Else
      BadVMPressFlg = False
      BadVMPressCnt = BadVMPressCnt
      BadVMPressCntTot = BadVMPressCntTot
    EndIf
  EndSub

  '================== VELOCITY DECODER ==============================
  Sub VelDecode
    'initialize output Arrays
    If FlowSign = 0 Then FlowSign = 1
    For Bin = 1 To MaxBins
      For Beam = 1 To MaxBeams
        EnsVelocity(Bin,Beam) = NAN
      Next Beam
      V1(Bin) = NAN
      V2(Bin) = NAN
      V3(Bin) = NAN
      V4(Bin) = NAN
      V1Disable(Bin) = False
      V2Disable(Bin) = False
      V3Disable(Bin) = False
      V4Disable(Bin) = False
    Next Bin
    Binstep = 1
    EnsBin = 0
    For Bin = 1 To Numbins 'Start at Bin 1 Beam 1
      Temp = VelDatOffset + 8 * EnsBin 'jump down 8 bytes each bin
      EnsBin = EnsBin + Binstep
      For Beam = 1 To NumBeams
        Index = Temp + 2 * Beam 'index down Two bytes each beam
        LSB = LongArray(Index)
        MSB = LongArray(Index + 1)
        BinVel = (256 * MSB) + LSB
        If BinVel = 32768 Then
          EnsVelocity(Bin, Beam) = NAN 'bad data
        Else
          If BinVel > 32767 Then 'Handle twos compliment (negative velocity)
            BinVel = BinVel - 65536
            If BinVel < -32767 Then 'smallest allowable velocity
              BinVel = NAN 'bad data
            Else 'apply flow sign
              BinVel = BinVel * VelocityScaleWater
              BinVel = BinVel * FlowSign
            EndIf
            EnsVelocity(Bin,Beam) = BinVel
          Else
            If BinVel > 32767 Then 'largest allowable velocity
              BinVel = NAN
            Else 'apply flow sign
              BinVel = BinVel * VelocityScaleWater
              BinVel = BinVel * FlowSign
            EndIf
            EnsVelocity(Bin,Beam) = BinVel
          EndIf
        EndIf
      Next Beam
      'uplooker will use Zvel and Evel
      V1(Bin) = EnsVelocity(Bin,1) 'Separate the big array into sub arrays
      If V1(Bin) = NAN Then V1Disable(Bin) = True 'disable the median or average calc
      V2(Bin) = EnsVelocity(Bin,2) 'Could also use a small temp array for 'ensVelocity()
      If V2(Bin) = NAN Then V2Disable(Bin) = True 'disable the median or average calc
      V3(Bin) = EnsVelocity(Bin,3)
      If V3(Bin) = NAN Then V3Disable(Bin) = True 'disable the median or average calc
      V4(Bin) = EnsVelocity(Bin,4)
      If V4(Bin) = NAN Then V4Disable(Bin) = True 'disable the median or average calc
    Next Bin
  EndSub

  '================= VERTICAL BEAM DECODE SECTION ===================
  '   This is only used if we have a 5th beam (Sentinel V or RiverPro)
  #If VMHasVertical Then
    Sub VertLeaderDecode
      'decode selected vertical leader data
      Dim tempLeadOffset As Long
      tempLeadOffset = VerticalLeadOffset - 1
      LSB = LongArray(tempLeadOffset + 3)
      MSB = LongArray(tempLeadOffset + 4)
      VerticalBinNum = (MSB * 256) + LSB
      LSB = LongArray(tempLeadOffset + 5)
      MSB = LongArray(tempLeadOffset + 6)
      VerticalPings = (MSB * 256) + LSB
      LSB = LongArray(tempLeadOffset + 7)
      MSB = LongArray(tempLeadOffset + 6)
      VerticalBinSize = (MSB * 256) + LSB
      LSB = LongArray(tempLeadOffset + 9)
      MSB = LongArray(tempLeadOffset + 10)
      VerticalBin1Center = (MSB * 256) + LSB
    EndSub

    Sub VertVelocityDecode
      'decode vertical velocity profile
      If VerticalBinNum <> NaN Then 'ok we have vertical velocity bins
        Dim Vertbin As Long
        Dim tempVelOffset As Long
        Dim tempVertVel As Float
        tempVelOffset = VerticalVelocityOffset - 1
        Dim vertbinstep As Long = 2
        Dim Counter As Long = 1
        tempVelOffset = tempVelOffset + 2
        For Vertbin = 1 To (VerticalBinNum * 2) Step vertbinstep
          tempVertVel = 0
          LSB = LongArray(tempVelOffset + Vertbin)
          MSB = LongArray(tempVelOffset + (Vertbin + 1))
          tempVertVel = (MSB * 256) + LSB
          If tempVertVel = 32768 Then
            tempVertVel = BadVel
          EndIf
          'convert twos compliment
          If tempVertVel > 32767 Then 'twos compliment for negative velocities
            tempVertVel = tempVertVel - 65536
          EndIf
          If tempVertVel <> BadVel Then
            'convert to cm/s
            tempVertVel = tempVertVel * VelocityScaleWater
            VerticalBinDisable(Counter) = False
          Else
            VerticalBinDisable(Counter) = True
          EndIf
          VerticalVelocity(Counter) = tempVertVel
          Counter = Counter + 1
        Next Vertbin
      EndIf
      Counter = 1
    EndSub

    Sub VertRSSIDecode
      Dim Vertbin As Long
      Dim tempRSSIOffset As Long
      tempRSSIOffset = VerticalRSSIOffset - 1
      tempRSSIOffset = tempRSSIOffset + 2
      For Vertbin = 1 To VerticalBinNum
        VerticalRSSI(Vertbin) = LongArray(tempRSSIOffset + Vertbin)
      Next Vertbin
    EndSub

    Sub VertCorrDecode
      Dim Vertbin As Long
      Dim tempCorrOffset As Long
      tempCorrOffset = VerticalCorrOffset - 1
      tempCorrOffset = tempCorrOffset + 2
      For Vertbin = 1 To VerticalBinNum
        VerticalCorr(Vertbin) = LongArray(tempCorrOffset + Vertbin)
      Next Vertbin
    EndSub
  #EndIf 'If VMHasVertical

  '======================== BOTTOM TRACK DECODING SECTION ===================
  ' This is only used if we're using a down looking ADCP with Bottom Tracking
  #If VMHasBottomTrack
    Sub BtmTrackDecode
      BtmTrackOffset = BtmTrackOffset - 1
      LSB = LongArray(BtmTrackOffset + 3)
      MSB = LongArray(BtmTrackOffset + 4)
      BtmTrackPings = (MSB * 256) + LSB

      BtmTrackMode = LongArray(BtmTrackOffset + 10)

      Dim BtIndex,BtCounter As Long
      Dim BtTempRange As Float
      BtCounter = 1
      For BtIndex = 17 To (15 + (NumBeams * 2)) Step 2
        LSB = LongArray(BtmTrackOffset + BtIndex)
        MSB = LongArray(BtmTrackOffset + (BtIndex + 1))
        BtTempRange = (MSB * 256) + LSB
        If BtTempRange = 32768 Then
          BtTempRange = BadVel
          BtmRangeBeamDisable(BtCounter) = True
        Else
          BtmTrackRange(BtCounter) = BtTempRange * 0.0328084 'cm to feet
          BtmRangeBeamDisable(BtCounter) = False
        End If
        BtCounter = BtCounter + 1
      Next BtIndex

      Dim btTempVel As Float
      BtCounter = 1
      For BtIndex = 25 To (23 + (NumBeams * 2)) Step 2
        LSB = LongArray(BtmTrackOffset + BtIndex)
        MSB = LongArray(BtmTrackOffset + (BtIndex + 1))
        btTempVel = (MSB * 256) + LSB
        If btTempVel = 32768 Then
          btTempVel = BadVel
          BtmVelBeamDisable(BtCounter) = True
        ElseIf btTempVel > 32767 'twos compliment (negative velocities)
          btTempVel = btTempVel - 65536
        End If
        If btTempVel <> BadVel Then
          BtmTrackVelocity(BtCounter) = btTempVel * VelocityScaleWater
          BtmVelBeamDisable(BtCounter) = False
        EndIf
        BtCounter = BtCounter + 1
      Next BtIndex

      For BtIndex = 1 To NumBeams
        BtmTrackCorr(BtIndex) = LongArray(BtmTrackOffset + (BtIndex + 32))
      Next BtIndex

      For BtIndex = 1 To NumBeams
        BtmTrackRSSI(BtIndex) = LongArray(BtmTrackOffset + (BtIndex + 72))
      Next BtIndex
    End Sub
  #EndIf

  '================ RANGED BIN CALCULATION ==================
  ' This is used if we want uplooker to autorange it's bin distribution
  ' based on a stage sensor/water depth
  #If UseAutoRange = True Then
    Sub CalcRangeBin
      CalcRangeStart = Timer(DebugTimer,msec,4)
      CalcRangeStart = CalcRangeStart/1000
      'Dim Range As Float
      Dim DucerDepth As Float 'this is in FT
      Dim Sensordepth As Float 'this is in FT
      Dim DucerDepthCM As Float 'convert ducer depth to Centimeters
      'calculate range to water surface and set endbin appropriately
      Select Case RangeSource
      Case UPbeam
        Sensordepth = VMupBeam
      Case VMpress
        Sensordepth = VMpress
      Case PSpress
        Sensordepth = PsPress1Stg(1)
      Case PSpress2
        Sensordepth = PSpress2Stg(1)
        #If WqSonde <> "NONE" Then
        Case WqPress
          Sensordepth = WqDepthFt
        #EndIf
      End Select
      DucerDepth = Sensordepth + DucerDepthOffset
      DucerDepthCM = DucerDepth * 30.48
      RangedBin = (FIX((DucerDepthCM - BlankDist)/BinSize))-CutOffBins 'remove user selected number of bins (based on beamchecks)
      EndBin = RangedBin 'Set end bin to the ranged bin for Index calcs
      CalcRangeEnd = Timer(DebugTimer,msec,4)
      CalcRangeEnd = CalcRangeEnd/1000
      CalcRangeTotTime = CalcRangeEnd - CalcRangeStart
    EndSub
  #EndIf 'If Using Auto Range for uplookers

  '================== VELOCITY CHECKS ============================
  ' This simple checks velocity agains expected values and
  ' flags if the index is outside of expectations
  Sub VelCheck
    If IndexVel <> 0 OR IndexVel <> BadDataIndicator Then 'if there is data, then probably good to go...
      If (IndexVel >= MinExpVel) AND (IndexVel <= MaxExpVel) Then 'if  Vel is in range, then
        BadVelFlag = False 'We have valid data but maybe it's a spike
      Else 'if vel not in range...
        BadVelFlag = True
        BadVelCount = BadVelCount + 1
      EndIf
    Else 'otherwise, if no data in buffer, or serial error then
      BadVelFlag = True
      BadVelCount = BadVelCount + 1
      IndexVel = BadDataIndicator
    EndIf
  EndSub

  '==================== ONE MINUTE VELOCITY CALCULATIONS ========================
  'subroutine averages all good bins for each ensemble for V1,V2, V3,and V4
  Sub OneMinuteCalcs
    OneMinCalcStart = Timer(DebugTimer,msec,4)
    OneMinCalcStart = OneMinCalcStart/1000
    Dim TotBins As Long
    Dim BinVelCount As Long
    Public MidBin As Long 'These can likely be dimmed here instead of public
    Public EbbDir As Boolean = True
    V1Cnt = 0
    V1EbbCnt = 0
    V1FldCnt = 0
    V2Cnt = 0
    V2EbbCnt = 0
    V2FldCnt = 0
    V3Cnt = 0
    V4Cnt = 0
    V1Sum = 0
    V1EbbSum = 0
    V1FldSum = 0
    V2Sum = 0
    V2EbbSum = 0
    V2FldSum = 0
    V3Sum = 0
    V4Sum = 0
    IndexVel = 0
    For BinVelCount = 1 To MaxBins
      VMBinVel(BinVelCount) = NAN
      VmBinVelDisable(BinVelCount) = False
    Next BinVelCount
    VelCount = 0 'Zero out VelCount variable
    If (BiRatOK = True) AND (BiRating = True) Then 'Ok the user wants a bi-directional rating and we are using a channel master (instrument coordinates)
      UseBiRat = True 'we can do it
    Else
      UseBiRat = False'we can't do it (or user doesn't want it
    EndIf
    TotBins = EndBin - StartBin
    'lets deterimine flow dir from V1 just in case we are using bi-rating
    MidBin = TotBins/2
    If V1(MidBin) > BiRatTran Then 'Calculate flow direction (CM) if using Ebb/Flood rating (only used for CM with Instrument velocities)
      EbbDir = true 'flow is positive
    Else
      EbbDir = false 'flow is negative
    EndIf
    For Cnt = StartBin To EndBin
      If (V1(Cnt) <> NAN) AND (V1(Cnt)>= MinExpVel) AND (V1(Cnt)<= MaxExpVel) 'its probably good
        V1Sum = V1Sum + V1(Cnt)
        V1Cnt = V1Cnt + 1
        If UseBiRat = true Then 'Ok we have a bi-directional rating
          If EbbDir Then 'flow is positive (ebb) use the EBB bins
            'Calc Ebb bin sum here
            If (Cnt >= StartEbbBin) AND (Cnt <= EndEbbBin) Then 'let's do this bin
              V1EbbSum += V1(Cnt)
              V1EbbCnt += 1
            EndIf 'if it's in range
          Else 'Ok it's Flood direction (negative)
            'Calc Fld bin sum here
            If (Cnt >= StartFldBin) AND (Cnt <= EndFldBin)Then 'lets do this one
              V1FldSum += V1(Cnt)
              V1FldCnt += 1
            EndIf 'if it's in-range
          EndIf 'direction
        EndIf 'if Birating
      Else
        BadBinCnt = BadBinCnt + 1
        V1(Cnt) = BadDataIndicator
      EndIf
    Next
    If V1Sum <> 0 Then
      V1Avg = V1Sum/V1Cnt 'Calculate normal V1
    Else
      V1Avg = 0
    EndIf
    If V1EbbSum <> 0 Then
      V1EbbAvg = V1EbbSum/V1EbbCnt 'Calculate Bi-rating Ebb bin average
    Else
      V1EbbAvg = 0
    EndIf
    If V1FldSum <> 0 Then
      V1FldAvg = V1FldSum/V1FldCnt 'Calculate Bi-rating Flood bin average
    Else
      V1FldAvg = 0
    EndIf
    For Cnt = StartBin To EndBin 'OK, in case we are using both X(V1) and Y(V2) velocities to calculate iVel then we have to calc V2 averages
      If (V2(Cnt) <> NAN) AND (V2(Cnt)>= MinExpVel) AND (V2(Cnt)<= MaxExpVel)
        V2Sum = V2Sum +  V2(Cnt) 'Calculate normal V2
        V2Cnt = V2Cnt + 1
        If UseBiRat = true Then 'Ok we have a bi-directional rating
          If EbbDir Then
            'Calc Ebb bin sum here
            If (Cnt >= StartEbbBin) AND (Cnt <= EndEbbBin) Then 'let's do this bin
              V2EbbSum += V2(Cnt)
              V2EbbCnt += 1
            EndIf 'if it's in range
          Else 'Ok it's Flood direction
            'Calc Fld bin sum here
            If (Cnt >= StartFldBin) AND (Cnt <= EndFldBin)Then 'ok let's do this bin
              V2FldSum += V2(Cnt)
              V2FldCnt += 1
            EndIf 'if it's in-range
          EndIf 'direction
        EndIf 'if Birating
      Else
        BadBinCnt = BadBinCnt + 1
        V2(Cnt) = BadDataIndicator
      EndIf
    Next
    If V2Sum <> 0 Then
      V2Avg =  V2Sum/V2Cnt 'Calculate normal V2
    Else
      V2Avg = 0
    EndIf
    If V2EbbSum <> 0 Then
      V2EbbAvg = V2EbbSum/V2EbbCnt 'Calculate Bi-rating Ebb bin average (V2)
    Else
      V2EbbAvg = 0
    EndIf
    If V2FldSum <> 0 Then
      V2FldAvg = V2FldSum/V2FldCnt  'Calculate Bi-rating Flood bin average (V2)
    Else
      V2FldAvg = 0
    EndIf
    For Cnt = StartBin To EndBin
      If (V3(Cnt) <> NAN) AND (V3(Cnt)>= MinExpVel) AND (V3(Cnt)<= MaxExpVel)
        V3Sum = V3Sum +  V3(Cnt)
        V3Cnt = V3Cnt + 1
      Else
        BadBinCnt = BadBinCnt + 1
        V3(Cnt) = BadDataIndicator
      EndIf
    Next
    If V3Sum <> 0 Then
      V3Avg =  V3Sum/V3Cnt
    Else
      V3Avg = 0
    EndIf
    For Cnt = StartBin To EndBin
      If (V4(Cnt) <> NAN) AND (V4(Cnt)>= MinExpVel) AND (V4(Cnt)<= MaxExpVel)
        V4Sum = V4Sum +  V4(Cnt)
        V4Cnt = V4Cnt + 1
      Else
        BadBinCnt = BadBinCnt + 1
        V4(Cnt) = BadDataIndicator
      EndIf
    Next
    If V4Sum <> 0 Then
      V4Avg =  V4Sum/V4Cnt
    Else
      V4Avg = 0
    EndIf

    If UseV2 = True Then 'If the user wants to use Y-velocity in Index calculation
      If BiRating Then 'calculate proper direction
        If EbbDir Then
          IndexVel = SQR(V1EbbAvg^2 + V2EbbAvg^2) 'pos flow
        Else
          IndexVel = SQR(V1FldAvg^2 + V2FldAvg^2) 'neg flow
        EndIf
      Else
        IndexVel = SQR(V1Avg^2 + V2Avg^2)'reg calc
      EndIf 'birating = true
      For Cnt = 1 To MaxBins
        If (V1(Cnt)<> BadDataIndicator) AND (V2(Cnt)<> BadDataIndicator) Then
          VMBinVel(Cnt) = SQR (V1(Cnt)^2 + V2(Cnt)^2)
          If ((Cnt >= StartBin) AND (Cnt <= EndBin)) Then
            VelCount = VelCount + 1
          EndIf
        Else
          VMBinVel(Cnt) = BadDataIndicator
          VmBinVelDisable(Cnt) = True
        EndIf
      Next
    ElseIf UseDir = True Then 'If the user wants to use compass direction as incicator for Positive flow
      IndexVel = (V1Avg * SIN(DegToRad * PosFlowDir)) + (V2Avg * COS(DegToRad * PosFlowDir))
      For Cnt = 1 To MaxBins
        If (V1(Cnt)<> BadDataIndicator) AND (V2(Cnt)<> BadDataIndicator) Then
          VMBinVel(Cnt) = (V1 * SIN(DegToRad * PosFlowDir)) + (V2 * COS(DegToRad * PosFlowDir))
          If ((Cnt >= StartBin) AND (Cnt <= EndBin)) Then
            VelCount = VelCount + 1
          EndIf
        Else
          VMBinVel(Cnt) = BadDataIndicator
          VmBinVelDisable(Cnt) = True
        EndIf
      Next
    Else 'just normal computation using V1
      If BiRating Then 'we're using Ebb and Flood
        If EbbDir Then
          IndexVel = V1EbbAvg
        Else 'if flood
          IndexVel = V1FldAvg
        EndIf
      Else 'bi-rating is false
        IndexVel = V1Avg
      EndIf
      For Cnt = 1 To MaxBins
        If V1(Cnt) <> BadDataIndicator Then
          VMBinVel(Cnt) = V1(Cnt)
          If ((Cnt >= StartBin) AND (Cnt <= EndBin)) Then
            VelCount = VelCount + 1
          EndIf
        Else
          VMBinVel(Cnt) = BadDataIndicator
          VmBinVelDisable(Cnt) = True
        EndIf
      Next
    EndIf
    If VelCount >=  EndBin - StartBin Then 'if VelCount < EndBin, then must have been some bad bins (allow one missing bin)
      BadVelFlag = False 'initialize flag to false again
      Call VelCheck 'call velocity Checker, simply indicating if we had data outside our expected range
    Else 'if VelCount isn't close to number of bins, then
      BadVelFlag = True 'set flag to true
      IndexVel = BadDataIndicator
      BadVelCount = BadVelCount + 1
      '  VelLoop = 0 'initialize variable for Vel Filter below
    EndIf
    'now lets count the bad velocity bins to keep track of them
    BadBinCount = (((EndBin+1)-StartBin)- VelCount)
    OneMinCalcEnd = Timer(DebugTimer,msec,4)
    OneMinCalcEnd = OneMinCalcEnd/1000
    OneMinCalcTotTime = OneMinCalcEnd - OneMinCalcStart
  EndSub

  '==================== Transform V1 and V2 for VADCP =================
  ' Because the brilliant RDI Engineers decided to reverse X and Y vels on the VADCP.
  Sub VADCPTransform
    If IsVADCP = True Then
      Dim TempV1(MaxBins) As Float
      Dim TempV1Disable(MaxBins) As Boolean
      Dim TempV2(MaxBins) As Float
      Dim TempV2Disable(MaxBins) As Boolean
      Dim TempCounter As Long
      For TempCounter = 1 To MaxBins
        TempV2(TempCounter) = V1(TempCounter) 'copy them out
        tempV2disable(TempCounter) = V1Disable(TempCounter) 'have to switch out the disable booleans also
        TempV1(TempCounter) = V2(TempCounter)
        TempV1disable(TempCounter) = V2Disable(TempCounter)
        V2(TempCounter) = TempV2(TempCounter) 'put them back in the opposite array
        V2Disable(TempCounter) = TempV2disable(TempCounter)
        V1(TempCounter) = TempV1(TempCounter)
        V1Disable(TempCounter) = TempV1disable(TempCounter)
        'V1 should now be X velocity and V2, Y velocity when using a VADCP
      Next TempCounter
    EndIf
  EndSub

  '=================== INTERNAL Q CALCULATIONS ====================
  Sub CalculateQ 'calculate discharge
    CalcQStart = Timer(DebugTimer,msec,4)
    CalcQStart = CalcQStart/1000
    If CalcQ = False Then ' if Q calculations are not wanted (CalcQ = no)
      BadQCount = 0
      Area = NAN
      MeanVel = NAN
      Qcfs = 0
      BadQFlag = True
      CalcQEnd = Timer(DebugTimer,msec,4)
      CalcQEnd = CalcQEnd/1000
      CalcQTotTime = CalcQEnd-CalcQStart
      ExitSub
    Else ' if Q calculations are wanted
      If Trans = BadDataIndicator Then 'if there is no valid transition point
        'then use standard velocity rating info for meanvel calculation
        MeanVel = VelOffset + (VelCoef * IndexVel) + (VelCoef2 * IndexVel^2) + (VelCoef3 * IndexVel^3)
      Else 'if there is a valid transition point
        If IndexVel >= Trans Then 'if iVel is greater or equal to the transition point
          'then use upper meanvel rating information
          MeanVel = UpVelOffset + (UpVelCoef * IndexVel) + (UpVelCoef2 * IndexVel^2) + (UpVelCoef3 * IndexVel^3)
        ElseIf IndexVel <= Trans Then 'if iVel is less than the transition point
          'then use lower meanvel rating information
          MeanVel = LowVelOffset + (LowVelCoef * IndexVel) + (LowVelCoef2 * IndexVel^2) + (LowVelCoef3 * IndexVel^3)
        EndIf
      EndIf
      If BadVelFlag = False AND  BadStgFlag = False Then 'Ok, now if both iVel and Stage are still good, then
        BadQFlag = False 'then Q data is still good
        'user enters rating values with keypad
        Area = StgOffset + (StgCoef*StagePrime) + (StgCoef2 * StagePrime^2)
        'check to see if iVel data is good
        Qcfs = Area * MeanVel 'calculate Q
        If Qcfs = 0 Then 'if calculated Q is exactly zero
          'then don't believe it (probably no rating data entered)
          BadQFlag = True 'Q data is now bad, so don't average it
          BadQCount = BadQCount + 1 'Q is now bad
          Qcfs = BadDataIndicator
        EndIf
      Else 'if stage or velocity were bad, then
        BadQFlag = True 'Q data is now bad, so don't average it
        BadQCount = BadQCount + 1 'and increment counter
        Qcfs = BadDataIndicator
      EndIf
    EndIf
    CalcQEnd = Timer(DebugTimer,msec,4)
    CalcQEnd = CalcQEnd/1000
    CalcQTotTime = CalcQEnd-CalcQStart
  EndSub

  '================== GET STAGE DATA ========================
  ' This routine calculates stage from all sensors and defines
  ' which sensor is the primary/secondary sensor
  Sub GetStage
    GetStgStart = Timer(DebugTimer,mSec,4)
    GetStgStart = GetStgStart/1000
    If IsWorkHorse Then
      VMpressure = WHpressure 'It's a workhorse and there is no "VMPress" from CM
    EndIf
    Call GetPressureSensors 'Call both sensors to get most recent value
    Call TrueStage 'If user entered a "TrueStage" value, calculate the offset based on current reading
    'then apply it to the data
    UpBeamStg = VMupBeam + UpBeamOffset
    VMPressStg = VMpressure + VMPressOffset
    PS1Stg = PsPress1Stg(1) + PS1Offset
    PS2Stg = PSpress2Stg(1) + PS2Offset
    #If WqSonde <> "NONE" Then
      SondeStg = WqDepthFt + SondeOffset
    #EndIf
    Select Case SelStgPrime
    Case UPbeam 'User selected Upbeam to be used as Primar Stage
      If VMdataIn = True AND VMupBeam <> NAN Then 'If there are data coming in and they are valid
        StagePrime = UpBeamStg
        BadStgFlag = False
      Else 'otherwise flag data as bad
        BadStgFlag = True
        StagePrime = BadDataIndicator
      EndIf
    Case VMpress 'User Selected VM Pressure sensor to be used as Primary stage
      If VMdataIn = True AND VMpressure <> NAN Then 'If there are data coming in and they are valid
        StagePrime = VMPressStg
        BadStgFlag = False
      Else ' Otherwise flag data as bad
        BadStgFlag = True
        StagePrime = BadDataIndicator
      EndIf
    Case PSpress 'User selected Pressure sensor 1 to be used as stage
      If PSPressDataIn = True Then
        StagePrime = PS1Stg
        BadStgFlag = False
      Else ' Otherwise flag data as bad
        BadStgFlag = True
        StagePrime = BadDataIndicator
      EndIf
    Case PSpress2 'User selected Pressure Sensor 2 to be used as stage
      If PSpress2DataIn = True Then 'if there are data then
        StagePrime = PS2Stg
        BadStgFlag = False
      Else 'otherwise flag the data as bad
        BadStgFlag = True
        StagePrime = BadDataIndicator
      EndIf
      'need all sondes checked for stage
      #If WqSonde <> "NONE" Then
      Case WqPress 'User selected YSI for Stage
        'Get YSI Stage Data
        If WqError = False Then 'If there are data then
          StagePrime = SondeStg
          BadStgFlag = False
        Else 'Otherwise flag the data as bad
          BadStgFlag = True
          StagePrime = BadDataIndicator
        EndIf
      #EndIf
    EndSelect

    Select Case SelStgSecnd
    Case UPbeam 'User selected Upbeam to be used as Stage
      If (VMdataIn = True AND VMupBeam <> NAN) Then 'If there are data coming in and they are valid
        StageSecnd = UpBeamStg
        BadStg2Flag = False
      Else 'otherwise flag data as bad
        StageSecnd = BadDataIndicator
        BadStg2Flag = True
      EndIf
    Case VMpress 'User Selected VM Pressure sensor to be used as stage
      If (VMdataIn = True AND VMpressure <> NAN) Then 'If there are data coming in and they are valid
        StageSecnd = VMPressStg
        BadStg2Flag = False
      Else ' Otherwise flag data as bad
        StageSecnd = BadDataIndicator
        BadStg2Flag = True
      EndIf
    Case PSpress 'User selected Pressure sensor 1 to be used as stage
      If PSPressDataIn = True Then
        StageSecnd = PS1Stg
        BadStg2Flag = False
      Else ' Otherwise flag data as bad
        StageSecnd = BadDataIndicator
        BadStg2Flag = True
      EndIf
    Case PSpress2 'User selected Pressure Sensor 2 to be used as stage
      If PSpress2DataIn = True Then 'if there are data then
        StageSecnd = PS2Stg
        BadStg2Flag = False
      Else 'otherwise flag the data as bad
        StageSecnd = BadDataIndicator
        BadStg2Flag = True
      EndIf
      #If WqSonde <> "NONE" Then
      Case WqPress 'User selected YSI for Stage
        'Get YSI Stage Data
        If WqError = False Then 'If there are data then
          StageSecnd = SondeStg
          BadStg2Flag = False
        Else 'Otherwise flag the data as bad
          StageSecnd = BadDataIndicator
          BadStg2Flag = True
        EndIf
      #EndIf
    EndSelect

    'now check to make sure primary stage is within range
    'this is the stage used to calculate flows
    If BadStgFlag = False Then 'if stage data is still good then...
      'lets check to see if within the expected range
      If StagePrime > MaxExpStg OR StagePrime < MinExpStg Then 'if out of expected range
        StgOutOfBndCnt = StgOutOfBndCnt + 1
        StgOutOfBndCntTot = StgOutOfBndCntTot + 1 'incriment bad stage counter
      EndIf
    Else 'if Bad Stage Flag was already true (from above code)
      BadStgCount = BadStgCount + 1 'increment bad stage counter
      BadStgCountTot = BadStgCountTot + 1
    EndIf
    If BadStg2Flag = False Then 'if stage data is still good then...
      'lets check to see if within the expected range
      If StageSecnd > MaxExpStg OR StageSecnd < MinExpStg Then 'if out of expected range
        Stg2OutOfBndCnt = Stg2OutOfBndCnt + 1
        Stg2OutOfBndCntTot = Stg2OutOfBndCntTot + 1 'incriment bad stage counter
      EndIf
    Else 'if Bad Stage Flag was already true (from above code)
      BadStg2Cnt = BadStg2Cnt + 1 'increment bad stage counter
      BadStg2CntTot = BadStg2CntTot + 1
    EndIf
    StgDiff = StagePrime - StageSecnd
    'which stage insturment type being used will be stored in the output files
    StgSelect = SelStgPrime + ":" + SelStgSecnd 'indicates stage type being used
    VMElevation = StagePrime - VMupBeam 'get instrument elevation to datum using primary stage sensor and raw upbeam value
    GetStgEnd = Timer(DebugTimer,mSec,4)
    GetStgEnd = GetStgEnd/1000
    GetStgTotTime = GetStgEnd - GetStgStart
  EndSub

  '=============== CALCULATE OFFSETS FOR STAGE ====================
  Sub TrueStage
    'Now lets get correct offsets for each instrument to produce an accurate "Stage"
    If TrueUpBeamStg = BadDataIndicator AND TrueVMPressStg = BadDataIndicator AND TruePS1Stg = BadDataIndicator AND TruePS2Stg = BadDataIndicator Then
      #If WqSonde <> "NONE" Then 'If sonde on board, check if used tried to set offset
        If TrueSondeStg = BadDataIndicator Then ExitSub 'if not, exit sub
      #EndIf 'if WqSonde <> NONE
      ExitSub 'if no Wq and all above are true, exit sub
    EndIf
    If ((TrueUpBeamStg <> BadDataIndicator) AND (VMupBeam <> BadDataIndicator)) Then ' if user types in a reference stage for Upbeam then
      UpBeamOffset = TrueUpBeamStg-VMupBeam ' get offset for UpBeam
    EndIf 'Otherwise do nothing
    If ((TrueVMPressStg <> BadDataIndicator) AND (VMpressure <> BadDataIndicator)) Then 'if user types in a reference stage VM Pressure sensor then
      VMPressOffset = TrueVMPressStg-VMpressure 'get offset for VM pressure sensor
    EndIf 'otherwise do nothing
    If ((TruePS1Stg <> BadDataIndicator) AND (PsPress1Stg(1) <> BadDataIndicator)) Then 'if user types in a reference stage for Pressure sensor1 then
      PS1Offset = TruePS1Stg-PsPress1Stg(1) 'Get offset for pressure sensor 1
    EndIf 'Otherwise do nothing
    If ((TruePS2Stg <> BadDataIndicator) AND (PSpress2Stg(1) <> BadDataIndicator)) Then 'if user types in a reference stage for pressure sensor2 then
      PS2Offset = TruePS2Stg - PSpress2Stg(1)
    EndIf 'Otherwise do nothing
    #If WqSonde <> "NONE" Then
      If ((TrueSondeStg <> BadDataIndicator) AND (WqDepthFt <> BadDataIndicator)) Then 'if user types in a reference stage for YSI then
        SondeOffset = TrueSondeStg - WqDepthFt
      EndIf
    #EndIf
  EndSub

  '================= GET PRESSURE SENSOR DATA ======================
  Sub GetPressureSensors
    GetPS1Start = Timer(DebugTimer,mSec,4)
    GetPS1Start = GetPS1Start/1000
    Select Case PSPressPort
    Case 3
      SDI12Recorder (PsPress1Stg(),PS1Com3,PSPressAddr,"M!",1.0,0)
    Case 5
      SDI12Recorder (PsPress1Stg(),PS1Com5,PSPressAddr,"M!",1.0,0)
    EndSelect
    If PsPress1Stg(1) = NAN Then 'if no data commes in
      PSPressDataIn = False
      BadPS1Flg = True
      BadPS1Cnt = BadPS1Cnt + 1
      BadPS1CntTot = BadPS1CntTot + 1
    Else 'if there is PS Pressure data
      PSPressDataIn = True
      BadPS1Flg = False
    EndIf
    GetPS1End = Timer(DebugTimer,mSec,4)
    GetPS1End = GetPS1End/1000
    GetPS1Tot = GetPS1End - GetPS1Start

    GetPS2Start = Timer(DebugTimer,mSec,4)
    GetPS2Start = GetPS2Start/1000
    Select Case PSpress2Port
    Case 3
      SDI12Recorder (PSpress2Stg(),PS2Com3,PSpress2Addr,"M!",1.0,0)
    Case 5
      SDI12Recorder (PSpress2Stg(),PS2Com5,PSpress2Addr,"M!",1.0,0)
    EndSelect
    If PSpress2Stg(1) = NAN Then 'if no data comes in
      PSpress2DataIn = False
      BadPS2Flg = True
      BadPS2Cnt = BadPS2Cnt + 1
      BadPS2CntTot = BadPS2CntTot + 1
    Else 'if there is Float Recorder data
      PSpress2DataIn = True
      BadPS2Flg = False
    EndIf
    GetPS2End = Timer(DebugTimer,mSec,4)
    GetPS2End = GetPS2End/1000
    GetPS2Tot = GetPS2End - GetPS2Start
  EndSub

  '================== ZERO OUT ALL VM ARRAYS ======================
  Sub ZeroVMArrays
    ZeroVMTimeStart = Timer(DebugTimer,msec,4)
    ZeroVMTimeStart = ZeroVMTimeStart/1000
    Dim ZeroCounter As Long
    'Zero The raw data array
    Erase (LongArray())
    'Zero the bin velocity arrays
    For Bin = 1 To MaxBins
      For Beam = 1 To MaxBeams
        EnsVelocity(Bin,Beam) = Nan
      Next Beam
    Next Bin
    For ZeroCounter = 1 To MaxBins
      V1(ZeroCounter) = Nan
      V2(ZeroCounter) = Nan
      VMBinVel(ZeroCounter) = Nan
    Next ZeroCounter
    IndexVel = NaN
    Erase (ensCorr())
    Erase (AvgRSSI())
    #If StoreAllToCard = True
      Erase Velspike()
      Erase RSSIspike()
      Erase Corrspike()
    #EndIf
    ZeroVMTimeEnd = Timer(DebugTimer,msec,4)
    ZeroVMTimeEnd = ZeroVMTimeEnd/1000
    ZeroVMTotTime = ZeroVMTimeEnd - ZeroVMTimeStart
  EndSub

  '================ GET PS AND VM SERIAL NUMBERS ===================
  ' This also checks against previous day's number to see if it's new
  ' to store a flag in the QAQC table
  Sub GetSN
    If AdcpSN <> InitialAdcpSN Then 'ADCP SN starts as 0, so this covers us on program initialization.
      NewADCP = True
      SendTF = True
      InitialAdcpSN = AdcpSN 'set the new s/n to initial
    EndIf
    If ModDay = 0 AND RecCalibData = False Then 'if midnight and not Calbrating then get serial numbers of all
      Select Case PSPressPort
      Case 3
        SDI12Recorder (PS1SN,PS1Com3,PSPressAddr,"I!",1.0,0) '"I!" command gets brand, model, serial number, firmware, etc. from pressure sensors.
        If PS1SN <> InitialPS1SN Then
          NewPS1 = True
          InitialPS1SN = PS1SN 'Set the new sn to initial
        Else
          NewPS1 = False
        EndIf  'didn't parse the string to only retrieve S/N because it's useful to know the brand and model.
      Case 5
        SDI12Recorder (PS1SN,PS1Com5,PSPressAddr,"I!",1.0,0) '"I!" command gets brand, model, serial number, firmware, etc. from pressure sensors.
        If PS1SN <> InitialPS1SN Then
          NewPS1 = True
          InitialPS1SN = PS1SN 'Set the new sn to initial
        Else
          NewPS1 = False
        EndIf                                      'didn't parse the string to only retrieve S/N because it's useful to know the brand and model.
      EndSelect
      Select Case PSpress2Port
      Case 3
        SDI12Recorder (PS2SN,PS2Com3,PSpress2Addr,"I!",1.0,0) '"I!" command gets brand, model, serial number, firmware, etc. from pressure sensors.
        If PS2SN <> InitialPS2SN Then
          NewPS2 = True
          InitialPS2SN = PS2SN 'Set the new sn to initial
        Else
          NewPS2 = False
        EndIf                                     'didn't parse the string to only retrieve S/N because it's useful to know the brand and model.
      Case 5
        SDI12Recorder (PS2SN,PS2Com5,PSpress2Addr,"I!",1.0,0) '"I!" command gets brand, model, serial number, firmware, etc. from pressure sensors.
        If PS2SN <> InitialPS2SN Then
          NewPS2 = True
          InitialPS2SN = PS2SN 'Set the new sn to initial
        Else
          NewPS2 = False
        EndIf                                     'didn't parse the string to only retrieve S/N because it's useful to know the brand and model.
      EndSelect
    EndIf 'end if midnight
  EndSub

  '=================== STORE VEL, RSSI, CORR SPIKES TO CARD ===================
  ' This is for some testing if we can produce a DataQualityIndicator based on number
  ' of spikes for a given parameter over a 15min period.
  #If StoreAllToCard = True Then
    Sub CheckSpikes 'change name later
      ChkSpikeStart = Timer(DebugTimer,msec,4)
      ChkSpikeStart = ChkSpikeStart/1000
      'check the RSSI, Correlation, and velocity queues against incoming data for spikes.  Queues must be full before call
      'Outputs the spike data to a file on the Card.
      Dim BinCount As Long
      Dim BeamCount As Long
      Dim TimeOut As String * 25
      Dim RSSIStd As Float
      Dim RSSIAvg As Float
      Dim CorrStd As Float
      Dim CorrAvg As Float
      Dim VelStd As Float
      Dim DataLine As String * 500
      Dim velAvg As Float
      Dim Top As Float = 0
      Dim Bottom As Float = 0
      Dim QueueCorrSpikes As Long = 0
      Dim QueueRSSISpikes As Long = 0
      Dim QueueVelSpikes As Long = 0
      Dim RSSITemp(16) As Float
      Dim CorrTemp(16) As Float
      Dim VelTemp(16) As Float
      #If SeeAllVel = True Then
        Public Binspikes(MaxBins) As Long
        Public BinResults(2) As Long
      #Else
        Dim Binspikes(MaxBins) As Long
        Public BinResults(2) As Long
      #EndIf
      Dim n As Long
      'Dim QueueTotalSpikes As Long = 0
      Dim QueueAvgStage As Float = 0
      Dim QueueVel As Float = 0
      'Dim QueueAvgVel As Float = 0
      FTimeIn = 4 'Set input argument for FTime to use "Spike Data" time formatting
      If InStr(1,Status.CardStatus,"No Card",2) = 0 Then 'if the cards not there no point in checking spikes
        SpikeFileName = "CRD:VmSpikes-" & SiteID & ".csv"
        FileHandle = FileOpen (SpikeFileName,"a+b",-1)'open the spike file here
        If SendHeader Then
          '---------------commented out for spike test
          'FileHeader = "Spike: ," & "Timestamp" & "," & "Type" & "," & "Value" & "," & "Bin" & "," & "Beam" & "," & "STD last 15" & "," & "Mean last 15" & "," & "Threshold (n*std)" & "," & "Ivel" & "," & "StagePrime"
          'write file header, otherwise just write to file below
          'FileWrite (FileHandle, FileHeader & CHR(13) & CHR(10),0)
          'DataLine = "Stats: ," & TimeOut & "," & "Ivel = " & IVel & "," & "StageAvg = " & QueueAvgStage & "," & "CorrSpikes = " & QueueCorrSpikes & "," & "RSSI Spikes = " & QueueRSSISpikes & "," & "Vel Spikes = " & QueueVelSpikes & "," & "DQI = " & QueueDQI
          'FileHeader = "Stats: ," & "Timestamp" & "," & "Ive" & "," & "Stage Avg" & "," & "Corr spikes" & "," & "RSSI Spikes" & "," & "Vel Spikes" & "," & "DQI = " & QueueDQI
          '-----------------------------------------------
          FileHeader = "Type," & "Timestamp," & "NumBeams," & "NumBins," & "StartBin,"& "EndBin,"& "BinSize," & "Ivel," & "Stage Avg,"& "Corr spikes," & "RSSI Spikes," & "Vel Spikes," & "DQI," & ">1 spikes," & "Bin"
          FileWrite (FileHandle, FileHeader & CHR(13) & CHR(10),0)
          SendHeader = False
        EndIf
        QueueCorrSpikes = 0
        QueueRSSISpikes = 0
        QueueVelSpikes = 0
        QueueAvgStage = 0
        QueueDQI = 0
        QueueVel = 0
        Erase Binspikes()
        ' Dim SampleCount As Long
        'should use startbin to endbin to eliminate unwanted spikes
        For BinCount = StartBin To EndBin
          For BeamCount = 1 To NumBeams
            Erase RSSITemp()
            Erase VelTemp()
            Erase CorrTemp()
            For n = 1 To 16
              RSSITemp(n) = RSSIspike(BinCount,BeamCount,n)
              Veltemp(n) = Velspike(BinCount,BeamCount,n)
              CorrTemp(n)= Corrspike(BinCount,BeamCount,n)
            Next n
            'StdDevSpa(RSSIStd,15,RSSIspike(BinCount,BeamCount,1) 'compute standard deviation of RSSI Queue
            StdDevSpa(RSSIStd,15,rssitemp(1))
            If RSSIStd = 0 Then RSSIStd = 0.1 'set to minimum if zero
            'AvgSpa(RSSIAvg,15,RSSIspike(BinCount,BeamCount,1)
            AvgSpa(RSSIAvg,15,RSSITemp(1))
            Top = RSSIAvg + (RSSIStd * RSSIStdNo)
            Bottom = RSSIAvg - (RSSIStd * RSSIStdNo)
            If (ensRSSI(BinCount,BeamCount) < Bottom) OR (ensRSSI(BinCount,BeamCount) > Top) Then
              SpikeCounter = SpikeCounter + 1
              Binspikes(BinCount) = Binspikes(BinCount) + 1
              QueueRSSISpikes = QueueRSSISpikes + 1
              TimeOut = Ftime(Public.Timestamp)
              TestTime = TimeOut
              'commented out for spike test-----------------------------------------
              'DataLine = "Spike: ," & TimeOut & "," & "RSSI" & "," & ensRSSI(BinCount,BeamCount) & "," & BinCount & "," & BeamCount & "," & Round(RSSIStd,2) & "," & Round(RSSIAvg,2) & "," & RSSIStdNo & "," & Round(iVel,3) & "," & Round(StagePrime,2)
              'FileWrite (FileHandle,DataLine & CHR(13) & CHR(10),0)
            EndIf
            'StdDevSpa(CorrStd,15,Corrspike(BinCount,BeamCount,1) 'compute standard deviation of Correlation Queue
            StdDevSpa(CorrStd,15,corrtemp(1))
            If CorrStd = 0 Then CorrStd = 0.1 'set to minimum if zero
            'AvgSpa(CorrAvg,15,Corrspike(BinCount,BeamCount,1)
            AvgSpa(CorrAvg,15,CorrTemp(1))
            Top = CorrAvg + (CorrStd * CorrStdNo)
            Bottom = CorrAvg - (CorrStd * CorrStdNo)
            If (ensCorr(BinCount,BeamCount) < Bottom) OR (ensCorr(BinCount,BeamCount) > Top) Then
              SpikeCounter = SpikeCounter + 1
              Binspikes(BinCount) = Binspikes(BinCount) + 1
              QueueCorrSpikes = QueueCorrSpikes + 1
              TimeOut = Ftime(Public.Timestamp)
              'commented out for spike test----------------------------------------
              'DataLine = "Spike: ," & TimeOut & "," & "Corr" & "," & ensCorr(BinCount,BeamCount) & "," & BinCount & "," & BeamCount & "," & Round(CorrStd,2) & "," & Round(CorrAvg,2) & "," & CorrStdNo & "," & Round(iVel,3) & "," & Round(StagePrime,2)
              'FileWrite (FileHandle,DataLine & CHR(13) & CHR(10),0)
            EndIf
            StdDevSpa(VelStd,15,veltemp(1))
            If VelStd = 0 Then VelStd = .1
            'AvgSpa(velAvg,15,Velspike(BinCount,BeamCount,1) 'Velocity average for Queue
            AvgSpa(velAvg,15,veltemp(1))
            Top = velAvg + (VelStd * VelStdNo)
            Bottom = velAvg - (VelStd * VelStdNo)
            If (EnsVelocity(BinCount,BeamCount) < Bottom) OR (EnsVelocity(BinCount,BeamCount) > Top) Then
              'for future use, we can set the disable variables here, but we need to call this before calling the velocity output table
              SpikeCounter = SpikeCounter + 1
              Binspikes(BinCount) = Binspikes(BinCount) + 1
              QueueVelSpikes = QueueVelSpikes + 1
              TimeOut = Ftime(Public.Timestamp)
              'commented out for spike test------------------------------------------------
              'DataLine = "Spike: ," & TimeOut & "," & "Velocity" & "," & Round(ensVelocity(BinCount,BeamCount),2) & "," & BinCount & "," & BeamCount & "," & Round(VelStd,2) & "," & Round(velAvg,2) & "," & VelStdNo & "," & Round(iVel,3) & "," & Round(StagePrime,2)
              'FileWrite (FileHandle,DataLine & CHR(13) & CHR(10),0)
            EndIf
            'StdDevSpa(VelStd,15,Velspike(BinCount,BeamCount,1) 'compute standard deviation of Velocity Queue

            'need to output Velocity average here every 15 mins regardless of spikes to provide a velocity scale for visualization
          Next BeamCount
        Next BinCount
        QueueDQI = (QueueCorrSpikes + QueueRSSISpikes + QueueVelSpikes)/15 'number of ensembles per period
        QueueDQI = Round(QueueDQI,2)
        velAvg = Round(velAvg,2)
        AvgSpa(QueueAvgStage,15,StageSpike(1)
        QueueAvgStage = Round(QueueAvgStage,2)
        QueueVel = Round(IndexVel,2)
        TimeOut = Ftime(Public.Timestamp)
        MaxSpa(BinResults(),MaxBins,Binspikes())
        If BinResults(1) < 2 Then
          BinResults(1) = 0
          BinResults(2) = 0
        EndIf
        'DataLine = "Stats: ," & TimeOut & "," & velAvg & "," & QueueAvgStage & "," & QueueCorrSpikes & "," & QueueRSSISpikes & "," & QueueVelSpikes & "," & QueueDQI
        DataLine = "Stats: ," & TimeOut & "," & NumBeams & "," & Numbins & "," & StartBin & "," & EndBin & "," & BinSize & ","& QueueVel & "," & QueueAvgStage & "," & QueueCorrSpikes & "," & QueueRSSISpikes & "," & QueueVelSpikes & "," & QueueDQI & "," & BinResults(1) & "," & BinResults(2)
        FileWrite (FileHandle,DataLine & CHR(13) & CHR(10),0)
        FileClose(FileHandle)
      EndIf
      CardError = Status.CardStatus
      ChkSpikeEnd = Timer(DebugTimer,msec,4)
      ChkSpikeEnd = ChkSpikeEnd/1000
      ChkSpikeTotTime = ChkSpikeEnd - ChkSpikeStart
    EndSub

    Sub AddSpikes
      AddSpikeStart = Timer(DebugTimer,msec,4)
      AddSpikeStart = AddSpikeStart/1000
      Dim BinCount As Long
      Dim BeamCount As Long
      Dim SampleCount As Long
      If BadVelFlag Then Exit Sub
      For BinCount = 1 To Numbins 'get all bins for storage
        For BeamCount = 1 To NumBeams
          Corrspike(BinCount,BeamCount,16) = ensCorr(BinCount,BeamCount) 'add new to end
          RSSIspike(BinCount,BeamCount,16) = ensRSSI(BinCount,BeamCount) 'add new to end
          Velspike(BinCount,BeamCount,16) = EnsVelocity(BinCount,BeamCount) 'add new to end
          For SampleCount = 1 To 15
            'Jack out first and copy in last
            Corrspike(BinCount,BeamCount,SampleCount) = Corrspike(BinCount,BeamCount,SampleCount + 1)
            RSSIspike(BinCount,BeamCount,SampleCount)=RSSIspike(BinCount,BeamCount,SampleCount + 1)
            Velspike(BinCount,BeamCount,SampleCount) = Velspike(BinCount,BeamCount,SampleCount + 1)
          Next SampleCount
        Next BeamCount
      Next BinCount
      'add stage to stagespike queue
      StageSpike(16) = StagePrime
      For SampleCount = 1 To 15
        StageSpike(SampleCount) = StageSpike(SampleCount + 1)
      Next SampleCount
      AddSpikeEnd = Timer(DebugTimer,msec,4)
      AddSpikeEnd = AddSpikeEnd/1000
      AddSpikeTotTime = AddSpikeEnd-AddSpikeStart
    EndSub

    Sub StoreAllData
      StoreToCrdStart = Timer(DebugTimer,msec,4)
      StoreToCrdStart = StoreToCrdStart/1000
      Dim CorrDataLine As String * 1000
      Dim VelDataLine As String * 1000
      Dim RSSIDataLine As String * 1000
      Dim BeamCount As Long
      Dim BinCount As Long
      If InStr(1,Status.CardStatus,"Card OK.",2) = 0 Then 'if the cards not there no point in checking spikes
        CardBadCount = CardBadCount + 1
        ExitSub
      Else
        CardOkCount = CardOkCount + 1
        SpikeFileName = "CRD:VmSpikes-" & SiteID & ".csv"
        FileHandle = FileOpen (SpikeFileName,"a+b",-1)'open the spike file here
        'compose dataline and write here.
        For BeamCount = 1 To NumBeams
          Erase CorrDataLine
          Erase VelDataLine
          Erase RSSIDataLine
          CorrDataLine = CorrDataLine & "Corr: ," & BeamCount
          VelDataLine = VelDataLine & "Velocity: ," & BeamCount
          RSSIDataLine = RSSIDataLine & "RSSI: ," & BeamCount
          For BinCount = 1 To Numbins
            CorrDataLine = CorrDataLine & "," & ensCorr(BinCount,BeamCount)
            VelDataLine = VelDataLine & "," & Round(EnsVelocity(BinCount,BeamCount),3)
            RSSIDataLine = RSSIDataLine & "," & ensRSSI(BinCount,BeamCount)
          Next BinCount
          FileWrite (FileHandle,RSSIDataLine & CHR(13) & CHR(10),0)
          FileWrite (FileHandle,CorrDataLine & CHR(13) & CHR(10),0)
          FileWrite (FileHandle,VelDataLine & CHR(13) & CHR(10),0)
        Next BeamCount
        FileClose(FileHandle)
      EndIf
      CardError = Status.CardStatus
      StoreToCrdEnd = Timer(DebugTimer,msec,4)
      StoreToCrdEnd = StoreToCrdEnd/1000
      StoreToCrdTotTime = StoreToCrdEnd-StoreToCrdStart
    EndSub
  #EndIf 'If StoreAllToCard = True
#EndIf 'If HasVM or Pressure Sensors

'=======================================================================================
'------------------------- WQ SPECIFIC SUBS --------------------------------------------
'=======================================================================================
#If WqSonde <> "NONE" Then

  '================= Turn Power On ============================
  Sub WqPwrOn
    #If LoggerType = CR1000 Then
      If IsWqNClosed Then
        PortSet(WqSwitchPort,0)
      Else
        PortSet(WqSwitchPort,1)
      EndIf 'is normally closed
    #ElseIf LoggerType = CR6 Then
      If  UseSW12_2_forWQ Then 'using SW12 port 2
        SW12(2,1)
      Else
        If IsWqNClosed Then
          PortSet(WqSwitchPort,0)
        Else
          PortSet(WqSwitchPort,1)
        EndIf
      EndIf
      #If TopBottom = True Then 'only using CR6 for now.
        If IsBtmWqNClosed = True Then
          PortSet(BtmWqSwitchPort,0)
        Else
          PortSet(BtmWqSwitchPort,1)
        EndIf
      #EndIf 'Top/bottom
    #EndIf 'If Logger determination
  EndSub

  '====================== OPEN WQ SERIAL PORTS =============================
  Sub OpenWQPort
    #If LoggerType = CR6 'For a CR6 the port require a different configuration from a CR1000
      If UseCommsOneForSonde = True Then
        SerialOpen (WqSerialPort,WqBaud,19,0,7000,1)'Max232 requires us to use TTL language, use comms mode one.The Max232 also converts to a binary like signal and requires serial open format of 19 to function. Standard code zero results in a communication error.
      ElseIf UseCommsZeroForSonde = True Then
        SerialOpen (WqSerialPort,WqBaud,0,0,7000,0)'No Max232 is present so we uses standard RS232 language
      Else
        SerialOpen (WqSerialPort,WqBaud,0,0,7000)'In case we use a non-stanadard port configuration this is the generic code
      EndIf
      #If TopBottom = True Then 'If second sonde present
        If BtmWqSerialPort = ComRS232 Then
          SerialOpen (BtmWqSerialPort,WqBaud,0,0,7000,0)
        EndIf
        '        If UseCommsOneForBtmSonde = True Then
        '          SerialOpen (BtmWqSerialPort,WqBaud,19,0,7000,1)'Max232 requires us to use TTL language, use comms mode one.The Max232 also converts to a binary like signal and requires serial open format of 19 to function. Standard code zero results in a communication error.
        '        ElseIf UseCommsZeroForBtmSonde = True Then
        '          SerialOpen (BtmWqSerialPort,WqBaud,0,0,7000,0)'No Max232 is present so we uses standard RS232 language
        '        Else
        '          SerialOpen (BtmWqSerialPort,WqBaud,0,0,7000)'In case we use a non-stanadard port configuration this is the generic code
        '        EndIf
      #EndIf 'end top/bottom
    #Else 'else it is a CR1000
      If (IsWqMax232 = True) AND (WqSerialPort <> ComME) Then
        SerialOpen (WqSerialPort,WqBaud,19,0,7000)'need to use TTL if Max232 is present
      Else
        SerialOpen (WqSerialPort,WqBaud,0,0,7000)'standard RS232 language works if no Max232 is present
      EndIf
      #If TopBottom = True Then
        If (IsWqMax232 = True) AND (BtmWqSerialPort <> ComME) Then
          SerialOpen (BtmWqSerialPort,WqBaud,19,0,7000)'need to use TTL if Max232 is present
        Else
          SerialOpen (BtmWqSerialPort,WqBaud,0,0,7000)'standard RS232 language works if no Max232 is present
        EndIf
      #EndIf
    #EndIf 'Datalogger declaration
  EndSub

  '======================= SET SONDE TIME ========================================
  Sub SetEXOTime
    FTimeIn = 5 'Set Ftime input argument to EXO timestamp formatting
    EXOTimeString = Ftime(Public.Timestamp)
    SerialFlush(WqSerialPort)
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"time " + EXOTimeString + CHR(13) + CHR(10),"OK",3,50)
    #If TopBottom = True Then
      EXOTimeString = Ftime(Public.Timestamp)
      SerialFlush(BtmWqSerialPort)
      SerialOut (BtmWqSerialPort,"0" + CHR(13),"?Command",3,10)
      Delay (1,10,mSec)
      SerialOut (BtmWqSerialPort,"time " + EXOTimeString + CHR(13) + CHR(10),"OK",3,50)
    #EndIf
    SetEXOTimeFlg = False
  EndSub

  '======================= GET PARAMETER LIST FROM SONDE ===============================
  Sub RedeploySonde 'checks parameters/sets delimiter and defines parameter orders
    Dim i

    If Redeploy = True OR WqParamOrder(1) = BadDataIndicator Then 'If standard sonde needs to be set up
      RedeployStart = Timer(DebugTimer,mSec,4)
      RedeployStart = RedeployStart/1000
      SerialFlush(WqSerialPort)
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10) 'a zero is required to wake up the sonde for other commands to be recieved. if not sonde will respond with"command?"
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"para" + CHR(13) + CHR(10),"",1,0)'gives the parameter order
      Delay (1,300,mSec)
      SerialIn (WqIn,WqSerialPort,100,&H0D0A,200)
      WqIn = Trim(WqIn)
      SplitStr (WqParamOrder,WqIn,CHR(32),WqNParams,0)
      NoSondeTrig = InStr(1,WqIn,"Sonde",2)
      Delay (1,20,mSec)
      SerialFlush(WqSerialPort)
      '---------------------------------Set Delimiter------------------------------
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"setdelim 2" + CHR(13) + CHR(10),"OK",3,50) 'set to comma delimited
      Delay (1,300,mSec)
      SerialIn (WqIn,WqSerialPort,100,&H0D0A,200)
      NoSondeTrig = InStr(1,WqIn,"Sonde",2)
      Delay (1,20,mSec)
      SerialFlush(WqSerialPort)
      '------------------------------- Set "Locs" based on Parameter check -----------------------
      For i = 1 To WqNParams
        If WqParamOrder(i) = 52 Then WqLocDate = i 'Date,MMDDYY
        If WqParamOrder(i) = 54 Then WqLocTime = i 'Time,HHMMSS
        If WqParamOrder(i) = 1 Then WqLocTempC = i 'Temp C
        If WqParamOrder(i) = 2 Then WqLocTempF = i 'Temp F
        If WqParamOrder(i) = 7 Then WqLocSpCond = i 'SpC uS/cm
        If WqParamOrder(i) = 223 Then WqLocTurbFNU = i 'Turbidity FNU
        If WqParamOrder(i) = 211 Then WqLocDOSat = i 'ODO, %Sat
        If WqParamOrder(i) = 212 Then WqLocDOmgL = i 'ODO, mg/L
        If WqParamOrder(i) = 22 Then WqLocDepthM = i 'Depth meters
        If WqParamOrder(i) = 23 Then WqLocDepthFt = i 'Depth Feet
        If WqParamOrder(i) = 28 Then WqLocBatt = i 'Battery, V
        If WqParamOrder(i) = 18 Then WqLocpH = i 'pH units
        If WqParamOrder(i) = 17 Then WqLocpHmV = i 'pH millivolts
        If WqParamOrder(i) = 193 Then WqLocChlugL = i 'Chlorophyll, ug/L
        If WqParamOrder(i) = 194 Then WqLocChlRFU = i 'Chlorophyll, RFU
        If WqParamOrder(i) = 216 Then WqLocBGApcRFU = i 'Blue-Green Algae-PC, RFU
        If WqParamOrder(i) = 225 Then WqLocBGApcugL = i 'Blue-Green Algae-PC, ug/L
        If WqParamOrder(i) = 227 Then WqLocFDomRFU = i 'Dissolved Organic Matter, RFU
        If WqParamOrder(i) = 228 Then WqLocFDomQSU = i 'Dissloved Organic Matter, QSU
        If WqParamOrder(i) = 19 Then WqLocORPmV = i 'ORP mV
        If WqParamOrder(i) = 48 Then WqLocNH4mgL = i 'Ammonium, mg/L
        If WqParamOrder(i) = 112 Then WqLocCLmgL = i 'Chloride, mg/L
        If WqParamOrder(i) = 106 Then WqLocNO3mgL = i 'Nitrate, mg/L
        If WqParamOrder(i) = 229 Then WqLocWiperPos = i 'Wiper position voltage
      Next i 'Loop through to check where parameter codes appear
      Redeploy = False
      RedeployEnd = Timer(DebugTimer,mSec,4)
      RedeployEnd = RedeployEnd/1000
      RedeployTot = RedeployEnd - RedeployStart
    EndIf
    #If TopBottom = True Then
      If BtmRedeploy = True OR BtmWqParamOrder(1) = BadDataIndicator Then
        BtmRedeployStart = Timer(DebugTimer,mSec,4)
        BtmRedeployStart = BtmRedeployStart/1000
        SerialFlush(BtmWqSerialPort)
        SerialOut (BtmWqSerialPort,"0" + CHR(13),"?Command",3,10) 'a zero is required to wake up the sonde for other commands to be recieved. if not sonde will respond with"command?"
        Delay (1,10,mSec)
        SerialOut (BtmWqSerialPort,"para" + CHR(13) + CHR(10),"",1,0)'gives the parameter order
        Delay (1,300,mSec)
        SerialIn (BtmWqIn,BtmWqSerialPort,100,&H0D0A,200)
        BtmWqIn = Trim(BtmWqIn)
        SplitStr (BtmWqParamOrder,BtmWqIn,CHR(32),WqNParams,0)
        BtmNoSondeTrig = InStr(1,BtmWqIn,"Sonde",2)
        Delay (1,200,mSec)
        SerialFlush(BtmWqSerialPort)
        '---------------------------------Set Delimiter------------------------------
        SerialOut (BtmWqSerialPort,"0" + CHR(13),"?Command",3,10)
        Delay (1,10,mSec)
        SerialOut (BtmWqSerialPort,"setdelim 2" + CHR(13) + CHR(10),"OK",3,50) 'set to comma delimited
        Delay (1,300,mSec)
        SerialIn (BtmWqIn,BtmWqSerialPort,100,&H0D0A,200)
        BtmNoSondeTrig = InStr(1,BtmWqIn,"Sonde",2)
        Delay (1,20,mSec)
        SerialFlush(BtmWqSerialPort)
        '------------------------------- Set "Locs" based on Parameter check -----------------------
        For i = 1 To WqNParams
          If BtmWqParamOrder(i) = 52 Then BtmWqLocDate = i 'Date,MMDDYY
          If BtmWqParamOrder(i) = 54 Then BtmWqLocTime = i 'Time,HHMMSS
          If BtmWqParamOrder(i) = 1 Then BtmWqLocTempC = i 'Temp C
          If BtmWqParamOrder(i) = 2 Then BtmWqLocTempF = i 'Temp F
          If BtmWqParamOrder(i) = 7 Then BtmWqLocSpCond = i 'SpC uS/cm
          If BtmWqParamOrder(i) = 223 Then BtmWqLocTurbFNU = i 'Turbidity FNU
          If BtmWqParamOrder(i) = 211 Then BtmWqLocDOSat = i 'ODO, %Sat
          If BtmWqParamOrder(i) = 212 Then BtmWqLocDOmgL = i 'ODO, mg/L
          If BtmWqParamOrder(i) = 22 Then BtmWqLocDepthM = i 'Depth meters
          If BtmWqParamOrder(i) = 23 Then BtmWqLocDepthFt = i 'Depth Feet
          If BtmWqParamOrder(i) = 28 Then BtmWqLocBatt = i 'Battery, V
          If BtmWqParamOrder(i) = 18 Then BtmWqLocpH = i 'pH units
          If BtmWqParamOrder(i) = 17 Then BtmWqLocpHmV = i 'pH millivolts
          If BtmWqParamOrder(i) = 193 Then BtmWqLocChlugL = i 'Chlorophyll, ug/L
          If BtmWqParamOrder(i) = 194 Then BtmWqLocChlRFU = i 'Chlorophyll, RFU
          If BtmWqParamOrder(i) = 216 Then BtmWqLocBGApcRFU = i 'Blue-Green Algae-PC, RFU
          If BtmWqParamOrder(i) = 225 Then BtmWqLocBGApcugL = i 'Blue-Green Algae-PC, ug/L
          If BtmWqParamOrder(i) = 227 Then BtmWqLocFDomRFU = i 'Dissolved Organic Matter, RFU
          If BtmWqParamOrder(i) = 228 Then BtmWqLocFDomQSU = i 'Dissloved Organic Matter, QSU
          If BtmWqParamOrder(i) = 19 Then BtmWqLocORPmV = i 'ORP mV
          If BtmWqParamOrder(i) = 48 Then BtmWqLocNH4mgL = i 'Ammonium, mg/L
          If BtmWqParamOrder(i) = 112 Then BtmWqLocCLmgL = i 'Chloride, mg/L
          If BtmWqParamOrder(i) = 106 Then BtmWqLocNO3mgL = i 'Nitrate, mg/L
          If BtmWqParamOrder(i) = 229 Then BtmWqLocWiperPos = i 'Wiper position voltage
        Next i 'Loop through to check where parameter codes appear for bottom
        BtmRedeploy = False
        BtmRedeployEnd = Timer(DebugTimer,mSec,4)
        BtmRedeployEnd = BtmRedeployEnd/1000
        BtmRedeployTot = BtmRedeployEnd - BtmRedeployStart
      EndIf
    #EndIf
  EndSub

  '==============================================================================
  '---------------------- GET SINGLE WQ DATA POINT ------------------------------
  '==============================================================================
  Sub GetWQData
    GetWqStart = Timer(DebugTimer,mSec,4)
    GetWqStart = GetWqStart/1000
    SerialFlush(WqSerialPort)
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"data" + CHR(13) + CHR(10),CHR(13)+CHR(10),3,10)'retrieve single instant data point
    #If TopBottom = True Then
      BtmGetWqStart = Timer(DebugTimer,mSec,4)
      BtmGetWqStart = BtmGetWqStart/1000
      SerialFlush(BtmWqSerialPort)
      SerialOut (BtmWqSerialPort,"0" + CHR(13),"?Command",3,10)
      Delay (1,10,mSec)
      SerialOut (BtmWqSerialPort,"data" + CHR(13) + CHR(10),CHR(13)+CHR(10),3,10)'retrieve single instant data point
    #EndIf 'if top/bottom
  EndSub

  Sub PullWqData
    SerialInRecord(WqSerialPort,WqIn,0,0,&H0023,WqBytes,10)
    WqIn = Trim(WqIn)
    SplitStr (WqData,WqIn,",",WqNParams,0)
    NoSondeTrig = InStr(1,WqIn,"Sonde",2)
    Delay (1,10,mSec)
    SerialFlush(WqSerialPort)
    #If TopBottom = True Then
      SerialInRecord(BtmWqSerialPort,BtmWqIn,0,0,&H0023,BtmWqBytes,10)
      BtmWqIn = Trim(BtmWqIn)
      SplitStr (BtmWqData,BtmWqIn,",",WqNParams,0)
      NoSondeTrig = InStr(1,BtmWqIn,"Sonde",2)
      Delay (1,10,mSec)
      SerialFlush(BtmWqSerialPort)
    #EndIf
  EndSub

  '======================= PARSE SINGLE DATA POINT TO CORRECT LOCATIONS =============================
  Sub ParseWQData
    If (WqData(WqLocDate) <> NAN) AND (WqData(WqLocDate)<> 0) AND (WqData(WqLocTime)<> OldEXOTime) Then
      OldEXOTime = WqData(WqLocTime)
      WqError = False
      WqDead = False
      WqErrCount = 0
      #If HasHMS = True Then
        HMS_WQcount = 0
        HMS_WqFlag = False
      #EndIf
    Else
      WqError = True
      OldEXOTime = WqData(WqLocTime)
      WqErrCount = WqErrCount + 1
      WqTotErrs = WqTotErrs + 1
      WqPwrCycleWait = WqPwrCycleWait + 1
      #If HasHMS = True Then
        HMS_WQcount = HMS_WQcount + 1
        If HMS_WQcount >= HMS_BadThresh Then
          HMS_WqFlag = True
        EndIf
      #EndIf
      If WqErrCount >= WQDeadCntMax Then
        WqDead = True
        WqParamOrder() = BadDataIndicator
        WqLocs() = BadDataIndicator
      EndIf
      #If DWRSonde = False Then
        GetWqEnd = Timer(DebugTimer,mSec,4)
        GetWqEnd = GetWqEnd/1000
        GetWqTot = GetWqEnd - GetWqStart
        Call WQ_Mark_Bad
        Exit Sub
      #EndIf
    EndIf
    If WqLocDate > 0 Then WqDate = WqData(WqLocDate)
    If WqLocTime > 0 Then WqTime = WqData(WqLocTime)
    If WqLocTempC > 0 Then WqTempC = WqData(WqLocTempC)
    If WqLocTempF > 0 Then WqTempF = WqData(WqLocTempF)
    If WqLocSpCond > 0 Then WqSpCond = WqData(WqLocSpCond)
    If WqLocTurbFNU > 0 Then WqTurbFNU = WqData(WqLocTurbFNU)
    If WqLocDOSat > 0 Then WqDOSat = WqData(WqLocDOSat)
    If WqLocDOmgL > 0 Then WqDOmgL = WqData(WqLocDOmgL)
    If WqLocDepthFt > 0 Then WqDepthFt = WqData(WqLocDepthFt)
    If WqLocDepthM > 0 Then WqDepthM = WqData(WqLocDepthM)
    If WqLocBatt > 0 Then WqBatt = WqData(WqLocBatt)
    If WqLocpH > 0 Then WqpH = WqData(WqLocpH)
    If WqLocpHmV > 0 Then WqpHmV = WqData(WqLocpHmV)
    If WqLocORPmV > 0 Then WqORPmV = WqData(WqLocORPmV)
    If WqLocChlugL > 0 Then WqChlugL = WqData(WqLocChlugL)
    If WqLocChlRFU > 0 Then WqChlRFU = WqData(WqLocChlRFU)
    If WqLocBGApcRFU > 0 Then WqBGApcRFU = WqData(WqLocBGApcRFU)
    If WqLocBGApcugL > 0 Then WqBGApcugL = WqData(WqLocBGApcugL)
    If WqLocFDomRFU > 0 Then WqFDomRFU = WqData(WqLocFDomRFU)
    If WqLocFDomQSU > 0 Then WqFDomQSU = WqData(WqLocFDomQSU)
    If WqLocNH4mgL > 0 Then WqNH4mgL = WqData(WqLocNH4mgL)
    If WqLocNO3mgL > 0 Then WqNO3mgL = WqData(WqLocNO3mgL)
    If WqLocCLmgL > 0 Then WqCLmgL = WqData(WqLocCLmgL)
    If WqLocWiperPos > 0 Then WqWiperPos = WqData(WqLocWiperPos)
    GetWqEnd = Timer(DebugTimer,mSec,4)
    GetWqEnd = GetWqEnd/1000
    GetWqTot = GetWqEnd - GetWqStart
    #If TopBottom Then
      If (BtmWqData(BtmWqLocDate) <> NAN) AND (BtmWqData(BtmWqLocDate)<> 0) AND (BtmWqData(BtmWqLocTime)<> BtmOldEXOTime)  Then
        BtmOldEXOTime = BtmWqData(BtmWqLocTime)
        BtmWqError = False
        BtmWqDead = False
        BtmWqErrCount = 0
        #If HasHMS = True Then
          HMS_BtmWQCount = 0
          HMS_BtmWqFlag = False
        #EndIf
      Else
        BtmWqError = True
        BtmOldEXOTime = BtmWqData(BtmWqLocTime)
        BtmWqErrCount = BtmWqErrCount + 1
        BtmWqTotErrs = BtmWqTotErrs + 1
        BtmWqPwrCycleWait = BtmWqPwrCycleWait + 1
        #If HasHMS = True Then
          HMS_BtmWQCount = HMS_BtmWQCount + 1
          If HMS_BtmWQCount >= HMS_BadThresh Then
            HMS_BtmWqFlag = True
          EndIf
        #EndIf
        If BtmWqErrCount >= WQDeadCntMax Then
          BtmWqDead = True
          BtmWqParamOrder() = BadDataIndicator
          BtmWqLocs() = BadDataIndicator
        EndIf
        #If DWRSonde = False Then
          Call Btm_WQ_Mark_Bad
          BtmGetWqEnd = Timer(DebugTimer,mSec,4)
          BtmGetWqEnd = BtmGetWqEnd/1000
          BtmGetWqTot = BtmGetWqEnd - BtmGetWqStart
          Exit Sub
        #EndIf ' if DWR sonde
      EndIf
      If BtmWqLocDate > 0 Then BtmWqDate = BtmWqData(BtmWqLocDate)
      If BtmWqLocTime > 0 Then BtmWqTime = BtmWqData(BtmWqLocTime)
      If BtmWqLocTempC > 0 Then BtmWqTempC = BtmWqData(BtmWqLocTempC)
      If BtmWqLocTempF > 0 Then BtmWqTempF = BtmWqData(BtmWqLocTempF)
      If BtmWqLocSpCond > 0 Then BtmWqSpCond = BtmWqData(BtmWqLocSpCond)
      If BtmWqLocTurbFNU > 0 Then BtmWqTurbFNU = BtmWqData(BtmWqLocTurbFNU)
      If BtmWqLocDOSat > 0 Then BtmWqDOSat = BtmWqData(BtmWqLocDOSat)
      If BtmWqLocDOmgL > 0 Then BtmWqDOmgL = BtmWqData(BtmWqLocDOmgL)
      If BtmWqLocDepthFt > 0 Then BtmWqDepthFt = BtmWqData(BtmWqLocDepthFt)
      If BtmWqLocDepthM > 0 Then BtmWqDepthM = BtmWqData(BtmWqLocDepthM)
      If BtmWqLocBatt > 0 Then BtmWqBatt = BtmWqData(BtmWqLocBatt)
      If BtmWqLocpH > 0 Then BtmWqpH = BtmWqData(BtmWqLocpH)
      If BtmWqLocpHmV > 0 Then BtmWqpHmV = BtmWqData(BtmWqLocpHmV)
      If BtmWqLocORPmV > 0 Then BtmWqORPmV = BtmWqData(BtmWqLocORPmV)
      If BtmWqLocChlugL > 0 Then BtmWqChlugL = BtmWqData(BtmWqLocChlugL)
      If BtmWqLocChlRFU > 0 Then BtmWqChlRFU = BtmWqData(BtmWqLocChlRFU)
      If BtmWqLocBGApcRFU > 0 Then BtmWqBGApcRFU = BtmWqData(BtmWqLocBGApcRFU)
      If BtmWqLocBGApcugL > 0 Then BtmWqBGApcugL = BtmWqData(BtmWqLocBGApcugL)
      If BtmWqLocFDomRFU > 0 Then BtmWqFDomRFU = BtmWqData(BtmWqLocFDomRFU)
      If BtmWqLocFDomQSU > 0 Then BtmWqFDomQSU = BtmWqData(BtmWqLocFDomQSU)
      If BtmWqLocNH4mgL > 0 Then BtmWqNH4mgL = BtmWqData(BtmWqLocNH4mgL)
      If BtmWqLocNO3mgL > 0 Then BtmWqNO3mgL = BtmWqData(BtmWqLocNO3mgL)
      If BtmWqLocCLmgL > 0 Then BtmWqCLmgL = BtmWqData(BtmWqLocCLmgL)
      If BtmWqLocWiperPos > 0 Then BtmWqWiperPos = BtmWqData(BtmWqLocWiperPos)
      BtmGetWqEnd = Timer(DebugTimer,mSec,4)
      BtmGetWqEnd = BtmGetWqEnd/1000
      BtmGetWqTot = BtmGetWqEnd - BtmGetWqStart
    #EndIf 'if top/bottom
    #If HasVM = True Then 'we have stage being populated
      If WqLocDepthFt <> 0 Then
        WqElevation = StagePrime - WqDepthFt
      ElseIf WqLocDepthM <> 0 Then
        WqElevation = StagePrime - (WqDepthM*3.281)
      EndIf
      #If TopBottom = True Then
       If BtmWqLocDepthFt <> 0 Then
        BtmWqElevation = StagePrime - BtmWqDepthFt
      ElseIf BtmWqLocDepthM <> 0 Then
        BtmWqElevation = StagePrime - (BtmWqDepthM*3.281)
      EndIf
      #EndIf
    #EndIf
  EndSub

  '==================== SEND WIPE COMMAND TO EXOs ==================================
  Sub WipeWq
    SerialOut(WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"twipeb" + CHR(13) + CHR(10),"",1,0)
    SerialIn (WqIn,WqSerialPort,100,&H0D0A,200)
    SplitStr (WqDelay,WqIn,"",1,0)
    SerialFlush (WqSerialPort)
    WipeTime = Status.TimeStamp(0,1)
    #If TopBottom = True Then
      SerialOut(BtmWqSerialPort,"0" + CHR(13),"?Command",3,10)
      Delay (1,10,mSec)
      SerialOut (BtmWqSerialPort,"twipeb" + CHR(13) + CHR(10),"",1,0)
      SerialIn (WqIn,BtmWqSerialPort,100,&H0D0A,200)
      SplitStr (BtmWqDelay,WqIn,"",1,0)
      SerialFlush (BtmWqSerialPort)
      BtmWipeTime = Status.TimeStamp(0,1)
    #EndIf
  EndSub

  #If DWRSonde = False Then 'not DWR sonde
    Sub WQ_Mark_Bad 'if WQerror then Zero all wqdata
      WqDataArray() = BadDataIndicator
    EndSub
    #If TopBottom Then
      Sub Btm_WQ_Mark_Bad
        BtmWqDataArray() = BadDataIndicator
      EndSub
    #EndIf 'top bottom
  #EndIf 'IF not DWR sonde

  Sub CycleWQPower
    If WqDead = True OR WqManualCycle = True Then
      If WqPwrCycleWait >= WQDeadCntMax OR WqManualCycle = True Then
        #If LoggerType = CR1000 Then
          If IsWqNClosed Then
            PortSet(WqSwitchPort,1)
          Else
            PortSet(WqSwitchPort,0)
          EndIf 'is normally closed
        #ElseIf LoggerType = CR6 Then
          If  UseSW12_2_forWQ Then 'using SW12 port 2
            SW12(2,0)
          Else
            If IsWqNClosed Then
              PortSet(WqSwitchPort,1)
            Else
              PortSet(WqSwitchPort,0)
            EndIf
          EndIf
          WqPwrCycleWait = 0
          WqManualCycle = False
          WqPwrCycleTries = WqPwrCycleTries + 1
          ErrorEvent = "Cycle Sonde Power"
          Redeploy = True
          CallTable SiteVisit
        EndIf
      EndIf
      #If TopBottom = True Then
        If BtmWqDead = True OR BtmWqManualCycle = True Then
          If BtmWqPwrCycleWait >= WQDeadCntMax OR BtmWqManualCycle Then
            If IsBtmWqNClosed = True Then
              PortSet(BtmWqSwitchPort,1)
            Else
              PortSet(BtmWqSwitchPort,0)
            EndIf
            BtmWqPwrCycleWait = 0
            BtmWqManualCycle = False
            BtmWqPwrCycleTries = BtmWqPwrCycleTries + 1
            ErrorEvent = "Cycle Btm Sonde Power"
            BtmRedeploy = True
            CallTable SiteVisit
          EndIf
        EndIf
      #EndIf 'Top/bottom
    #EndIf 'If Logger determination
  EndSub

  #If WqSonde = "WQ_SERIAL_BURST" Then
    Sub SetBurst
      SetBurstStart = Timer(DebugTimer,mSec,4)
      SetBurstStart = SetBurstStart/1000
      If WqParamOrder(1) <> BadDataIndicator Then 'We have a good parameter order, move forward with burst
        SerialFlush(WqSerialPort)
        SerialOut(WqSerialPort,"0"+CHR(13),"?Command",3,10) 'wake up instrument
        Delay(1,10,mSec)
        SerialOut (WqSerialPort,"setperiod" + " " + BurstPeriod + CHR(13)+CHR(10),"OK",3,50) 'set time between samples, (default of 1000 = 1Hz)
        Delay(1,10,mSec)
        SerialOut (WqSerialPort,"#" + CHR(13),"#" + CHR(13),3,100)
        SerialOut (WqSerialPort,"run" + CHR(13),"run" + CHR(13),3,10) 'Starts the sampling at "BurstPeriod" (Default = 1Hz)
      EndIf
      SetBurstEnd = Timer(DebugTimer,mSec,4)
      SetBurstEnd = SetBurstEnd/1000
      SetBurstTot = SetBurstEnd - SetBurstStart
      #If TopBottom = True Then
        BtmSetBurstStart = Timer(DebugTimer,mSec,4)
        BtmSetBurstStart = BtmSetBurstStart/1000
        If BtmWqParamOrder(1) <> BadDataIndicator Then 'we have a good parameter order, move forward with burst
          SerialFlush(BtmWqSerialPort)
          SerialOut(BtmWqSerialPort,"0"+CHR(13),"?Command",3,10) 'wake up instrument
          Delay(1,10,mSec)
          SerialOut (BtmWqSerialPort,"setperiod" + " " + BurstPeriod + CHR(13)+CHR(10),"OK",3,50) 'set time between samples, (default of 1000 = 1Hz)
          Delay(1,10,mSec)
          SerialOut (BtmWqSerialPort,"#" + CHR(13),"#" + CHR(13),3,100)
          SerialOut (BtmWqSerialPort,"run" + CHR(13),"run" + CHR(13),3,10) 'Starts the sampling at "BurstPeriod" (Default = 1Hz)
        EndIf
        BtmSetBurstEnd = Timer(DebugTimer,mSec,4)
        BtmSetBurstEnd = BtmSetBurstEnd/1000
        BtmSetBurstTot = BtmSetBurstEnd - BtmSetBurstStart
      #EndIf 'top/bottom
    EndSub

    Sub FillWqBurstArray
      Dim i
      FillBurstStart = Timer(DebugTimer,mSec,4)
      FillBurstStart = FillBurstStart/1000
      For i = 1 To MaxBurstCnt
        SerialInRecord(WqSerialPort,BurstIn,&H0023,0,&H0D0A,WqBytes,11)
        If BurstIn = "" Then
          WqError = True
          ExitFor
        EndIf
        BurstIn = Replace(BurstIn,"-nan","-9999")
        SplitStr(BurstArray(i,1),BurstIn,CHR(32),WqNParams,0)
        Erase(BurstIn)
      Next i
      FillBurstEnd = Timer(DebugTimer,mSec,4)
      FillBurstEnd = FillBurstEnd/1000
      FillBurstTot = FillBurstEnd - FillBurstStart
      #If TopBottom = True Then
        BtmFillBurstStart = Timer(DebugTimer,mSec,4)
        BtmFillBurstStart = BtmFillBurstStart/1000
        For i = 1 To MaxBurstCnt
          SerialInRecord(BtmWqSerialPort,BurstIn,&H0023,0,&H0D0A,BtmWqBytes,11)
          If BurstIn = "" Then
            BtmWqError = True
            ExitFor
          EndIf
          BurstIn = Replace(BurstIn,"-nan","-9999")
          SplitStr(BtmBurstArray(i,1),BurstIn,CHR(32),WqNParams,0)
          Erase(BurstIn)
        Next i
        BtmFillBurstEnd = Timer(DebugTimer,mSec,4)
        BtmFillBurstEnd = BtmFillBurstEnd/1000
        BtmFillBurstTot = BtmFillBurstEnd - BtmFillBurstStart
      #EndIf 'if top/bottom
    EndSub

    '=============== PULL DATA FROM MULTI-DIMENSION ARRAY TO SINGLE-DIMENSION ARRAY ===========
    Sub SortBurst
      Dim jCount
      Dim kCount
      ProcBurstStart = Timer(DebugTimer,mSec,4)
      ProcBurstStart = ProcBurstStart/1000
      BurstCount = 0
      TotalBurstVals = 0
      BurstErrCnt = 0
      For jCount = 1 To MaxBurstCnt 'This loop is parsing out number of samples
        For kCount = 1 To WqNParams 'This loop is to sort parameters
          BurstData(kCount) = BurstArray(jCount,kCount) 'get one parameter stored in k-th variable in array
        Next kCount 'loop through to put next value in next variable
        Call ParseTopBurst 'Parse the WqBurstData() into properly labeled variables
        If WqError = True Then 'something wrong with the sample
          WqBadData = True 'Set flag to bad data
          BurstErrCnt = BurstErrCnt + 1 'increase error counter used to calculate number of values in calculations
        Else
          WqBadData = False 'otherwise, we're good
          BurstErrCnt = BurstErrCnt
        EndIf
        BurstCount = BurstCount+1 'burst count increase
        If BurstErrCnt > BurstMaxErrCnt Then 'if we have more errors than the threshold
          TotalBurstVals = jCount - BurstErrCnt 'the total number of values used for the burst should be jCount - number of errors
          ExitFor 'if error occurs more than a threshold, exit the loop
        EndIf
        If BurstCount >= MaxBurstCnt Then 'if our burst count has reached our threshold
          TotalBurstVals = jCount - BurstErrCnt 'if there's an interuption during the burst but it comes back online, we need to subtract how many times error happened to calculate a total number of values
          BurstMissed = False 'we had good values coming in, so Make sure disable variable is set to false so the values get processed
          RecBurstFlag = True 'set our output flag to true
          CallTable SecBurst 'call the table that stores individual 1sec values
          CallTable Burst 'call the burst table
        ElseIf BurstCount < MaxBurstCnt AND WqError = True Then
          BurstMissed = False 'we have good values
          RecBurstFlag = False 'don't set the output flag because we haven't reached our threshold
          CallTable SecBurst 'store the next 1sec value
        ElseIf BurstCount < MaxBurstCnt AND WqError = False Then
          BurstMissed = False
          RecBurstFlag = False
          CallTable SecBurst
          CallTable Burst 'Need to call table to store the values in the table memory until the output flag (RecBurstFlag) is true
        EndIf
      Next jCount 'restart the loop until we reach max burst count
      If BurstCount < MaxBurstCnt Then 'didn't reach our burst threshold, so let's Call and output SecBurst and Burst Tables
        BurstMissed = True 'Disable processing of Median values in burst table
        RecBurstFlag = True 'set the output flag to true
        CallTable SecBurst 'store the final value in the SecBurst table
        CallTable Burst 'Call the burst table to output median values no with however many 1sec values were collected
      EndIf
      ProcBurstEnd = Timer(DebugTimer,mSec,4)
      ProcBurstEnd = ProcBurstEnd/1000
      ProcBurstTot = ProcBurstEnd - ProcBurstStart
      #If TopBottom = True Then 'parse the second sonde's burst data
        BtmProcBurstStart = Timer(DebugTimer,mSec,4)
        BtmProcBurstStart = ProcBurstStart/1000
        BtmBurstCount = 0
        BtmTotalBurstVals = 0
        BtmBurstErrCnt = 0
        For jCount = 1 To MaxBurstCnt 'This loop is parsing out number of samples
          For kCount = 1 To WqNParams 'This loop is to sort parameters
            BtmBurstData(kCount) = BtmBurstArray(jCount,kCount) 'get one parameter stored in k-th variable in array
          Next kCount 'loop through to put next value in next variable
          Call ParseBtmBurst 'Parse the WqBurstData() into properly labeled variables
          If BtmWqError = True Then 'something wrong with the sample
            BtmWqBadData = True 'Set flag to bad data
            BtmBurstErrCnt = BtmBurstErrCnt + 1 'increase error counter used to calculate number of values in calculations
          Else
            WqBadData = False 'otherwise, we're good
            BtmBurstErrCnt = BtmBurstErrCnt
          EndIf
          BtmBurstCount = BtmBurstCount+1 'burst count increase
          If BtmBurstErrCnt > BurstMaxErrCnt Then 'if we have more errors than the threshold
            BtmTotalBurstVals = jCount - BtmBurstErrCnt 'the total number of values used for the burst should be jCount - number of errors
            ExitFor 'if error occurs more than a threshold, exit the loop
          EndIf
          If BtmBurstCount >= MaxBurstCnt Then 'if our burst count has reached our threshold
            BtmTotalBurstVals = jCount - BtmBurstErrCnt 'if there's an interuption during the burst but it comes back online, we need to subtract how many times error happened to calculate a total number of values
            BtmBurstMissed = False 'we had good values coming in, so Make sure disable variable is set to false so the values get processed
            BtmRecBurstFlag = True 'set our output flag to true
            CallTable BtmSecBurst 'call the table that stores individual 1sec values
            CallTable BtmBurst 'call the burst table
          ElseIf BtmBurstCount < MaxBurstCnt AND BtmWqError = True Then
            BtmBurstMissed = False 'we have good values
            BtmRecBurstFlag = False 'don't set the output flag because we haven't reached our threshold
            CallTable BtmSecBurst 'store the next 1sec value
          ElseIf BtmBurstCount < MaxBurstCnt AND BtmWqError = False Then
            BtmBurstMissed = False
            BtmRecBurstFlag = False
            CallTable BtmSecBurst
            CallTable BtmBurst 'Need to call table to store the values in the table memory until the output flag (RecBurstFlag) is true
          EndIf
        Next jCount 'restart the loop until we reach max burst count
        If BtmBurstCount < MaxBurstCnt Then 'didn't reach our burst threshold, so let's Call and output SecBurst and Burst Tables
          BtmBurstMissed = True 'Disable processing of Median values in burst table
          BtmRecBurstFlag = True 'set the output flag to true
          CallTable BtmSecBurst 'store the final value in the SecBurst table
          CallTable BtmBurst 'Call the burst table to output median values no with however many 1sec values were collected
        EndIf
        BtmProcBurstEnd = Timer(DebugTimer,mSec,4)
        BtmProcBurstEnd = BtmProcBurstEnd/1000
        BtmProcBurstTot = BtmProcBurstEnd - BtmProcBurstStart
      #EndIf 'if top/bottom
    EndSub

    Sub ParseTopBurst 'Parses burst data into correct locations
      If (WqBurstData(WqLocDate) <> NAN) AND (WqBurstData(WqLocDate) <> 0) Then
        WqError = False
        WqDead = False
        WqErrCount = 0
      Else
        WqError = True
        WqErrCount = WqErrCount + 1
        WqTotErrs = WqTotErrs + 1
      EndIf
      If WqLocDate > 0 Then BurstDate = BurstData(WqLocDate)
      If WqLocTime > 0 Then BurstTime = BurstData(WqLocTime)
      If WqLocTempC > 0 Then BurstTempC = BurstData(WqLocTempC)
      If WqLocTempF > 0 Then BurstTempF = BurstData(WqLocTempF)
      If WqLocSpCond > 0 Then BurstSpCond = BurstData(WqLocSpCond)
      If WqLocTurbFNU > 0 Then BurstTurbFNU = BurstData(WqLocTurbFNU)
      If WqLocDOSat > 0 Then BurstDOSat = BurstData(WqLocDOSat)
      If WqLocDOmgL > 0 Then BurstDOmgL = BurstData(WqLocDOmgL)
      If WqLocDepthFt > 0 Then BurstDepthFt = BurstData(WqLocDepthFt)
      If WqLocDepthM > 0 Then BurstDepthM = BurstData(WqLocDepthM)
      If WqLocBatt > 0 Then BurstBatt = BurstData(WqLocBatt)
      If WqLocpH > 0 Then BurstpH = BurstData(WqLocpH)
      If WqLocpHmV > 0 Then BurstpHmV = BurstData(WqLocpHmV)
      If WqLocORPmV > 0 Then BurstORPmV = BurstData(WqLocORPmV)
      If WqLocChlugL > 0 Then BurstChlugL = BurstData(WqLocChlugL)
      If WqLocChlRFU > 0 Then BurstChlRFU = BurstData(WqLocChlRFU)
      If WqLocBGApcRFU > 0 Then BurstBGApcRFU = BurstData(WqLocBGApcRFU)
      If WqLocBGApcugL > 0 Then BurstBGApcugL = BurstData(WqLocBGApcugL)
      If WqLocFDomRFU > 0 Then BurstFDomRFU = BurstData(WqLocFDomRFU)
      If WqLocFDomQSU > 0 Then BurstFDomQSU = BurstData(WqLocFDomQSU)
      If WqLocNH4mgL > 0 Then BurstNH4mgL = BurstData(WqLocNH4mgL)
      If WqLocNO3mgL > 0 Then BurstNO3mgL = BurstData(WqLocNO3mgL)
      If WqLocCLmgL > 0 Then BurstCLmgL = BurstData(WqLocCLmgL)
      If WqLocWiperPos > 0 Then BurstWiperPos = BurstData(WqLocWiperPos)
    EndSub
    #If TopBottom Then
      Sub ParseBtmBurst
        If (BtmBurstData(BtmWqLocDate) <> NAN) AND (BtmBurstData(BtmWqLocDate) <> 0) Then
          BtmWqError = False
          BtmWqDead = False
          BtmWqErrCount = 0
        Else
          BtmWqError = True
          BtmWqErrCount = BtmWqErrCount + 1
          BtmWqTotErrs = BtmWqTotErrs + 1
        EndIf
        If BtmWqLocDate > 0 Then BtmBurstDate = BtmBurstData(BtmWqLocDate)
        If BtmWqLocTime > 0 Then BtmBurstTime = BtmBurstData(BtmWqLocTime)
        If BtmWqLocTempC > 0 Then BtmBurstTempC = BtmBurstData(BtmWqLocTempC)
        If BtmWqLocTempF > 0 Then BtmBurstTempF = BtmBurstData(BtmWqLocTempF)
        If BtmWqLocSpCond > 0 Then BtmBurstSpCond = BtmBurstData(BtmWqLocSpCond)
        If BtmWqLocTurbFNU > 0 Then BtmBurstTurbFNU = BtmBurstData(BtmWqLocTurbFNU)
        If BtmWqLocDOSat > 0 Then BtmBurstDOSat = BtmBurstData(BtmWqLocDOSat)
        If BtmWqLocDOmgL > 0 Then BtmBurstDOmgL = BtmBurstData(BtmWqLocDOmgL)
        If BtmWqLocDepthFt > 0 Then BtmBurstDepthFt = BtmBurstData(BtmWqLocDepthFt)
        If BtmWqLocDepthM > 0 Then BtmBurstDepthM = BtmBurstData(BtmWqLocDepthM)
        If BtmWqLocBatt > 0 Then BtmBurstBatt = BtmBurstData(BtmWqLocBatt)
        If BtmWqLocpH > 0 Then BtmBurstpH = BtmBurstData(BtmWqLocpH)
        If BtmWqLocpHmV > 0 Then BtmBurstpHmV = BtmBurstData(BtmWqLocpHmV)
        If BtmWqLocORPmV > 0 Then BtmBurstORPmV = BtmBurstData(BtmWqLocORPmV)
        If BtmWqLocChlugL > 0 Then BtmBurstChlugL = BtmBurstData(BtmWqLocChlugL)
        If BtmWqLocChlRFU > 0 Then BtmBurstChlRFU = BtmBurstData(BtmWqLocChlRFU)
        If BtmWqLocBGApcRFU > 0 Then BtmBurstBGApcRFU = BtmBurstData(BtmWqLocBGApcRFU)
        If BtmWqLocBGApcugL > 0 Then BtmBurstBGApcugL = BtmBurstData(BtmWqLocBGApcugL)
        If BtmWqLocFDomRFU > 0 Then BtmBurstFDomRFU = BtmBurstData(BtmWqLocFDomRFU)
        If BtmWqLocFDomQSU > 0 Then BtmBurstFDomQSU = BtmBurstData(BtmWqLocFDomQSU)
        If BtmWqLocNH4mgL > 0 Then BtmBurstNH4mgL = BtmBurstData(BtmWqLocNH4mgL)
        If BtmWqLocNO3mgL > 0 Then BtmBurstNO3mgL = BtmBurstData(BtmWqLocNO3mgL)
        If BtmWqLocCLmgL > 0 Then BtmBurstCLmgL = BtmBurstData(BtmWqLocCLmgL)
        If BtmWqLocWiperPos > 0 Then BtmBurstWiperPos = BtmBurstData(BtmWqLocWiperPos)
      EndSub
    #EndIf 'if top/bottom

    '========================== RESET VARIABLES ==============================
    'Reset the values to NAN so it doesn't inadvertently populate previous data in AQ table
    Sub ResetMedBurstVars
      MedBurstData() = BadDataIndicator
      #If TopBottom = True Then
        BtmMedBurstData() = BadDataIndicator
      #EndIf 'if top bottom
    EndSub

    '========================== COPY VALUES =======================================
    ' This copies calculated values from the Burst Tables to new variables to be sampled by AQ table
    Sub CopyMedBurstVals
      MedBurstDate = Burst.BurstDate_Med
      MedBurstTime = Burst.BurstTime_Med
      MedBurstTime = Round(MedBurstTime,0) 'round the time because the median value of an even set of numbers is the average of the two median values
      MedTempC = Burst.BurstTempC_Med
      MedTempF = Burst.BurstTempF_Med
      MedSpCond = Burst.BurstSpCond_Med
      MedTurbFNU = Burst.BurstTurbFNU_Med
      MedDOSat = Burst.BurstDOSat_Med
      MedDOmgL= Burst.BurstDOmgL_Med
      MedORPmV= Burst.BurstORPmV_Med
      MedDepthFt = Burst.BurstDepthFt_Med
      MedDepthM = Burst.BurstDepthM_Med
      MedBatt= Burst.BurstBatt_Med
      MedpH= Burst.BurstpH_Med
      MedpHmV= Burst.BurstpHmV_Med
      MedChlugL= Burst.BurstChlugL_Med
      MedChlRFU= Burst.BurstChlRFU_Med
      MedBGApcRFU= Burst.BurstBGApcRFU_Med
      MedBGApcugL= Burst.BurstBGApcugL_Med
      MedFDomRFU= Burst.BurstFdomRFU_Med
      MedFDomQSU= Burst.BurstFDomQSU_Med
      MedNH4mgL= Burst.BurstNH4mgl_Med
      MedNO3mgL= Burst.BurstNO3mgl_Med
      MedCLmgL= Burst.BurstCLmgl_Med
      MedWiperPos= Burst.BurstWiperPos_Med
      #If TopBottom = True Then
        BtmMedBurstDate = BtmBurst.BtmBurstDate_Med
        BtmMedBurstTime = BtmBurst.BtmBurstTime_Med
        BtmMedBurstTime = Round(BtmMedBurstTime,0) 'round the time because the median value of an even set of numbers is the average of the two median values
        BtmMedTempC = BtmBurst.BtmBurstTempC_Med
        BtmMedTempF = BtmBurst.BtmBurstTempF_Med
        BtmMedSpCond = BtmBurst.BtmBurstSpCond_Med
        BtmMedTurbFNU = BtmBurst.BtmBurstTurbFNU_Med
        BtmMedDOSat = BtmBurst.BtmBurstDOSat_Med
        BtmMedDOmgL= BtmBurst.BtmBurstDOmgL_Med
        BtmMedORPmV= BtmBurst.BtmBurstORPmV_Med
        BtmMedDepthFt = BtmBurst.BtmBurstDepthFt_Med
        BtmMedDepthM = BtmBurst.BtmBurstDepthM_Med
        BtmMedBatt = BtmBurst.BtmBurstBatt_Med
        BtmMedpH= BtmBurst.BtmBurstpH_Med
        BtmMedpHmV= BtmBurst.BtmBurstpHmV_Med
        BtmMedChlugL= BtmBurst.BtmBurstChlugL_Med
        BtmMedChlRFU= BtmBurst.BtmBurstChlRFU_Med
        BtmMedBGApcRFU= BtmBurst.BtmBurstBGApcRFU_Med
        BtmMedBGApcugL= BtmBurst.BtmBurstBGApcugL_Med
        BtmMedFDomRFU= BtmBurst.BtmBurstFdomRFU_Med
        BtmMedFDomQSU= BtmBurst.BtmBurstFDomQSU_Med
        BtmMedNH4mgL= BtmBurst.BtmBurstNH4mgl_Med
        BtmMedNO3mgL= BtmBurst.BtmBurstNO3mgl_Med
        BtmMedCLmgL= BtmBurst.BtmBurstCLmgl_Med
        BtmMedWiperPos= BtmBurst.BtmBurstWiperPos_Med
      #EndIf 'if top bottom
    EndSub

  #EndIf 'If Burst
#EndIf 'If Sonde Present
'=======================================================================================

'=======================================================================================
'--------------------------- SUNA SPECIFIC SUBS ----------------------------------------
'=======================================================================================
#If HasSuna = True Then
  '----------------Copy processed data from "Stats" table to be sample by AQ table
  Sub CopySunaStats
    AvgSunaNitrateuM = SunaStats.SunaNitrateuM_Avg
    MedSunaNitrateuM = SunaStats.SunaNitrateuM_Med
    StdSunaNitrateuM = SunaStats.SunaNitrateuM_Std
    AvgSunaNitratemgL = SunaStats.SunaNitratemgL_Avg
    MedSunaNitratemgL = SunaStats.SunaNitratemgL_Med
    StdSunaNitratemgL = SunaStats.SunaNitratemgL_Std
    AvgSunaFittingResult = SunaStats.SunaFittingResult_Avg
    StdSunaFittingResult = SunaStats.SunaFittingResult_Std
    MedA254 = SunaStats.A254_Med
    MedA350 = SunaStats.A350_Med
    AvgSunaDarkAve = SunaStats.SunaDarkAve_Avg
    AvgSunaSpecAve = SunaStats.SunaSpecAve_Avg
    AvgTSpec = SunaStats.TSpec_Avg
    AvgTLamp = SunaStats.TLamp_Avg
    AvgSunaHumid = SunaStats.SunaHumid_Avg
    AvgSunaLampTime = SunaStats.SunaLampTime_Avg
    AvgSunaVoltMain = SunaStats.SunaVoltMain_Avg
    AvgSunaVoltLamp = SunaStats.SunaVoltLamp_Avg
  EndSub

  '----------------- Reset Values back to NAN ---------------------------------
  Sub ResetSunaStats
    AvgSunaNitrateuM = BadDataIndicator
    MedSunaNitrateuM = BadDataIndicator
    StdSunaNitrateuM = BadDataIndicator
    AvgSunaNitratemgL = BadDataIndicator
    MedSunaNitratemgL = BadDataIndicator
    StdSunaNitratemgL = BadDataIndicator
    AvgSunaFittingResult = BadDataIndicator
    StdSunaFittingResult = BadDataIndicator
    MedA254 = BadDataIndicator
    MedA350 = BadDataIndicator
    AvgSunaDarkAve = BadDataIndicator
    AvgSunaSpecAve = BadDataIndicator
    AvgTSpec = BadDataIndicator
    AvgTLamp = BadDataIndicator
    AvgSunaHumid = BadDataIndicator
    AvgSunaLampTime = BadDataIndicator
    AvgSunaVoltMain = BadDataIndicator
    AvgSunaVoltLamp = BadDataIndicator
    SunaNitrateuM = BadDataIndicator
    SunaNitratemgL = BadDataIndicator
    SunaFittingResult = BadDataIndicator
    A254 = BadDataIndicator
    A350 = BadDataIndicator
    SunaDarkAve = BadDataIndicator
    SunaSpecAve = BadDataIndicator
    TSpec = BadDataIndicator
    TLamp = BadDataIndicator
    SunaHumid = BadDataIndicator
    SunaLampTime = BadDataIndicator
    SunaVoltMain = BadDataIndicator
    SunaVoltLamp = BadDataIndicator
    SunaStringLen() = BadDataIndicator
    SunaBurstIn = BadDataIndicator
    RawSunaArray() = BadDataIndicator
    GoodSunaArray() = BadDataIndicator
    SunaBurstData() = BadDataIndicator
    SpectrumData() = BadDataIndicator
  EndSub
#EndIf 'if suna present
'=====================================================================================

'=====================================================================================
'------------------------ MODEM ERROR CHECK SUB -------------------------------------
'=====================================================================================
#If HasModem = True Then
  Sub ModemCheck
    ModemChkStart = Timer(DebugTimer,mSec,4)
    ModemChkStart = ModemChkStart/1000
    If IsSubmersed = True  Then
      ModemChkEnd = Timer(DebugTimer,mSec,4)
      ModemChkEnd = ModemChkEnd/1000
      ModemChkTotTime = ModemChkEnd - ModemChkStart
      ExitSub
    EndIf
    Select Case IsModemNClosed
    Case True'if relay exists
      If KeepModemOn = True Then 'if want CDMA on
        #If LoggerType = CR1000 Then
          SW12(0)
        #ElseIf LoggerType = CR6 Then
          SW12(1,0)
        #EndIf
        IsModemOn = True
      Else 'If want CDMA off except for window
        If TimeIntoInterval(0,60,min) Then
          #If LoggerType = CR1000 Then
            SW12(0)
          #ElseIf LoggerType = CR6 Then
            SW12(1,0)
          #EndIf
          IsModemOn = True
        EndIf
        If TimeIntoInterval(10,60,min) Then
          #If LoggerType = CR1000 Then
            SW12(1)
          #ElseIf LoggerType = CR6 Then
            SW12(1,1)
          #EndIf
          IsModemOn = False
        EndIf
      EndIf
    Case False 'if relay does not exist
      If KeepModemOn = True Then 'want CDMA to stay on
        #If LoggerType = CR1000 Then
          SW12(1)
        #ElseIf LoggerType = CR6 Then
          SW12(1,1)
        #EndIf
        IsModemOn = True
      Else 'want CDMA to turn off except for window
        If TimeIntoInterval(0,60,min) Then
          #If LoggerType = CR1000 Then
            SW12(1)
          #ElseIf LoggerType = CR6 Then
            SW12(1,1)
          #EndIf
          IsModemOn = True
        EndIf
        If TimeIntoInterval(10,60,min) Then
          #If LoggerType = CR1000 Then
            SW12(0)
          #ElseIf LoggerType = CR6 Then
            SW12(1,0)
          #EndIf
          IsModemOn = False
        EndIf
      EndIf
    EndSelect
    If CycleModemPwr = True Then
      If IsModemNClosed Then
        #If LoggerType = CR1000 Then
          SW12(1)
        #ElseIf LoggerType = CR6 Then
          SW12(1,1)
        #EndIf
      Else
        #If LoggerType = CR1000 Then
          SW12(0)
        #ElseIf LoggerType = CR6 Then
          SW12(1,0)
        #EndIf
      EndIf  'manual cycle power Open the circuit to the Modem
      IsModemOn = False
      CycleModemPwr = False
    EndIf
    PingResp = PingIP ("www.google.com",250)
    If PingResp > 0 Then
      ModemWorks = True
      ModemScans = 0
      ModemFailure = False
      #If HasHMS = True Then
        HMS_ModCount = 0
        HMS_ModFlag = False
      #EndIf

    Else 'cycle power to CDMA
      ModemWorks = False
      ModemScans = ModemScans + 1
      #If HasHMS = True Then
        HMS_ModCount = HMS_ModCount + 1
        If HMS_ModCount >= HMS_BadThresh Then
          HMS_ModFlag = True
        EndIf
      #EndIf
      If ModemScans >= ModemHrsOff * 60 Then 'Fastloop interval is no of Subscans per 15 min so * 4 is scans per hour
        If IsModemNClosed Then
          #If LoggerType = CR1000 Then
            SW12(1)
          #EndIf'turn off telemetery if a normally closed relay is present
          #If LoggerType = CR6 Then
            SW12(1,1)
          #EndIf
        Else
          #If LoggerType = CR1000 Then
            SW12(0)
          #EndIf 'turn off telemetery if NC relay is not present
          #If LoggerType = CR6 Then
            SW12(1,0)
          #EndIf
        EndIf  'cycle cdma off after 4 hours (Open the Circuit to the CDMA)
        IsModemOn = False
        ModemFailure = True
        ModemScans = 0
      EndIf
    EndIf
    ModemChkEnd = Timer(DebugTimer,mSec,4)
    ModemChkEnd = ModemChkEnd/1000
    ModemChkTotTime = ModemChkEnd - ModemChkStart
  EndSub
#EndIf 'Has modem

'=======================================================================
'----------------- PRESERVE/READ VARIABLES FROM USR --------------------
'=======================================================================
#If HasVM = True OR WqSonde <> "NONE" Then
  Sub CheckCase
        #If HasVM = True Then
      #If WqSonde = "NONE" Then
        #If UseAutoRange = False Then
          Const NumVars = 34
          UsrCase = 1
        #Else
          Const NumVars = 36
         ' Dim InVar(NumVars)
          UsrCase = 2
        #EndIf
      #ElseIf WqSonde = "WQ_SERIAL" Then
        #If UseAutoRange = False Then
          Const NumVars = 36
          UsrCase = 3
        #Else
          Const NumVars = 38
          UsrCase = 4
        #EndIf
      #ElseIf WqSonde = "WQ_SERIAL_BURST" Then
        #If UseAutoRange = False Then
          Const NumVars = 37
          UsrCase = 5
        #Else
          Const NumVars = 39
          UsrCase = 6
        #EndIf
      #EndIf
    #Else 'no VM
      #If WqSonde = "WQ_SERIAL" Then
        Const NumVars = 2
        UsrCase = 7
      #ElseIf WqSonde = "WQ_SERIAL_BURST" Then
        Const NumVars = 3
        UsrCase = 8
      #EndIf
    #EndIf 'VM determination
  EndSub  

  Sub ReadVariables
    Public PreserveHandle As Long
    Public PreserveFileLen As Long
    Public CloseError
    Dim InVar(NumVars)
    PreserveHandle = FileOpen("USR:VariableStore.txt","r",-1)
    PreserveFileLen = FileRead(PreserveHandle,PreserveFile,500)
    CloseError = FileClose(PreserveHandle)
    If PreserveFileLen = 0 Then
      '    'set error txt
      ExitSub
    EndIf
    SplitStr(InVar,PreserveFile,",",NumVars,0)
    Select Case UsrCase
    #If HasVM = True Then
    Case 1
      StartBin = InVar(1)
      EndBin = InVar(2)
      StartEbbBin = InVar(3)
      EndEbbBin = InVar(4)
      StartFldBin = InVar(5)
      EndFldBin = InVar(6)
      BiRating = InVar(7)
      BiRatTran = InVar(8)
      SelStgPrime = InVar(9)
      SelStgSecnd = InVar(10)
      UpBeamOffset = InVar(11)
      VMPressOffset = InVar(12)
      PS1Offset = InVar(13)
      PS2Offset = InVar(14)
      CalcQ = InVar(15)
      StgOffset = InVar(16)
      StgCoef = InVar(17)
      StgCoef2 = InVar(18)
      VelOffset = InVar(19)
      VelCoef = InVar(20)
      VelCoef2 = InVar(21)
      VelCoef3 = InVar(22)
      UpVelOffset = InVar(23)
      UpVelCoef = InVar(24)
      UpVelCoef2 = InVar(25)
      UpVelCoef3 = InVar(26)
      LowVelOffset = InVar(27)
      LowVelCoef = InVar(28)
      LowVelCoef2 = InVar(29)
      LowVelCoef3 = InVar(30)
      IsSubmersed = InVar(31)
      IsVMNClosed = InVar(32)
      FlowSign = InVar(33)
      OneMinConsistent= InVar(34) 'if you want constant 1min data this will keep it on in case of power cycle

    Case 2
      StartBin = InVar(1)
      EndBin = InVar(2)
      StartEbbBin = InVar(3)
      EndEbbBin = InVar(4)
      StartFldBin = InVar(5)
      EndFldBin = InVar(6)
      BiRating = InVar(7)
      BiRatTran = InVar(8)
      SelStgPrime = InVar(9)
      SelStgSecnd = InVar(10)
      UpBeamOffset = InVar(11)
      VMPressOffset = InVar(12)
      PS1Offset = InVar(13)
      PS2Offset = InVar(14)
      CalcQ = InVar(15)
      StgOffset = InVar(16)
      StgCoef = InVar(17)
      StgCoef2 = InVar(18)
      VelOffset = InVar(19)
      VelCoef = InVar(20)
      VelCoef2 = InVar(21)
      VelCoef3 = InVar(22)
      UpVelOffset = InVar(23)
      UpVelCoef = InVar(24)
      UpVelCoef2 = InVar(25)
      UpVelCoef3 = InVar(26)
      LowVelOffset = InVar(27)
      LowVelCoef = InVar(28)
      LowVelCoef2 = InVar(29)
      LowVelCoef3 = InVar(30)
      IsSubmersed = InVar(31)
      IsVMNClosed = InVar(32)
      FlowSign = InVar(33)
      OneMinConsistent= InVar(34) 'if you want constant 1min data this will keep it on in case of power cycle
      #If UseAutoRange = True Then
        RangeSource = InVar(35)
        DucerDepthOffset = InVar(36)
      #EndIf
    #EndIf
    Case 3
      #If HasVM = True Then
      StartBin = InVar(1)
      EndBin = InVar(2)
      StartEbbBin = InVar(3)
      EndEbbBin = InVar(4)
      StartFldBin = InVar(5)
      EndFldBin = InVar(6)
      BiRating = InVar(7)
      BiRatTran = InVar(8)
      SelStgPrime = InVar(9)
      SelStgSecnd = InVar(10)
      UpBeamOffset = InVar(11)
      VMPressOffset = InVar(12)
      PS1Offset = InVar(13)
      PS2Offset = InVar(14)
      CalcQ = InVar(15)
      StgOffset = InVar(16)
      StgCoef = InVar(17)
      StgCoef2 = InVar(18)
      VelOffset = InVar(19)
      VelCoef = InVar(20)
      VelCoef2 = InVar(21)
      VelCoef3 = InVar(22)
      UpVelOffset = InVar(23)
      UpVelCoef = InVar(24)
      UpVelCoef2 = InVar(25)
      UpVelCoef3 = InVar(26)
      LowVelOffset = InVar(27)
      LowVelCoef = InVar(28)
      LowVelCoef2 = InVar(29)
      LowVelCoef3 = InVar(30)
      IsSubmersed = InVar(31)
      IsVMNClosed = InVar(32)
      FlowSign = InVar(33)
      #EndIf
      OneMinConsistent= InVar(34) 'if you want constant 1min data this will keep it on in case of power cycle
      #If WqSonde <> "NONE" Then
        #If HasVM = True Then
        SondeOffset = InVar(35)
        #EndIf
        IsWqNClosed = InVar(36)
      #EndIf

    Case 4
      #If HasVM = True Then
      StartBin = InVar(1)
      EndBin = InVar(2)
      StartEbbBin = InVar(3)
      EndEbbBin = InVar(4)
      StartFldBin = InVar(5)
      EndFldBin = InVar(6)
      BiRating = InVar(7)
      BiRatTran = InVar(8)
      SelStgPrime = InVar(9)
      SelStgSecnd = InVar(10)
      UpBeamOffset = InVar(11)
      VMPressOffset = InVar(12)
      PS1Offset = InVar(13)
      PS2Offset = InVar(14)
      CalcQ = InVar(15)
      StgOffset = InVar(16)
      StgCoef = InVar(17)
      StgCoef2 = InVar(18)
      VelOffset = InVar(19)
      VelCoef = InVar(20)
      VelCoef2 = InVar(21)
      VelCoef3 = InVar(22)
      UpVelOffset = InVar(23)
      UpVelCoef = InVar(24)
      UpVelCoef2 = InVar(25)
      UpVelCoef3 = InVar(26)
      LowVelOffset = InVar(27)
      LowVelCoef = InVar(28)
      LowVelCoef2 = InVar(29)
      LowVelCoef3 = InVar(30)
      IsSubmersed = InVar(31)
      IsVMNClosed = InVar(32)
      FlowSign = InVar(33)
      #EndIf
      OneMinConsistent= InVar(34) 'if you want constant 1min data this will keep it on in case of power cycle
      #If HasVM = True Then
      #If UseAutoRange = True Then
        RangeSource = InVar(35)
        DucerDepthOffset = InVar(36)
      #EndIf
      #EndIf
      #If WqSonde <> "NONE" Then
        #If HasVM = True Then
        SondeOffset = InVar(37)
        #EndIf
        IsWqNClosed = InVar(38)
      #EndIf

    Case 5
      #If HasVM = True Then
      StartBin = InVar(1)
      EndBin = InVar(2)
      StartEbbBin = InVar(3)
      EndEbbBin = InVar(4)
      StartFldBin = InVar(5)
      EndFldBin = InVar(6)
      BiRating = InVar(7)
      BiRatTran = InVar(8)
      SelStgPrime = InVar(9)
      SelStgSecnd = InVar(10)
      UpBeamOffset = InVar(11)
      VMPressOffset = InVar(12)
      PS1Offset = InVar(13)
      PS2Offset = InVar(14)
      CalcQ = InVar(15)
      StgOffset = InVar(16)
      StgCoef = InVar(17)
      StgCoef2 = InVar(18)
      VelOffset = InVar(19)
      VelCoef = InVar(20)
      VelCoef2 = InVar(21)
      VelCoef3 = InVar(22)
      UpVelOffset = InVar(23)
      UpVelCoef = InVar(24)
      UpVelCoef2 = InVar(25)
      UpVelCoef3 = InVar(26)
      LowVelOffset = InVar(27)
      LowVelCoef = InVar(28)
      LowVelCoef2 = InVar(29)
      LowVelCoef3 = InVar(30)
      IsSubmersed = InVar(31)
      IsVMNClosed = InVar(32)
      FlowSign = InVar(33)
      #EndIf
      OneMinConsistent = InVar(34) 'if you want constant 1min data this will keep it on in case of power cycle
      #If WqSonde <> "NONE" Then
        #If HasVM = True Then
        SondeOffset = InVar(35)
        #EndIf
        IsWqNClosed = InVar(36)
        #If WqSonde = "WQ_SERIAL_BURST" Then
          BurstPeriod = InVar(37)
        #EndIf
      #EndIf

    Case 6
      #If HasVM = True Then
      StartBin = InVar(1)
      EndBin = InVar(2)
      StartEbbBin = InVar(3)
      EndEbbBin = InVar(4)
      StartFldBin = InVar(5)
      EndFldBin = InVar(6)
      BiRating = InVar(7)
      BiRatTran = InVar(8)
      SelStgPrime = InVar(9)
      SelStgSecnd = InVar(10)
      UpBeamOffset = InVar(11)
      VMPressOffset = InVar(12)
      PS1Offset = InVar(13)
      PS2Offset = InVar(14)
      CalcQ = InVar(15)
      StgOffset = InVar(16)
      StgCoef = InVar(17)
      StgCoef2 = InVar(18)
      VelOffset = InVar(19)
      VelCoef = InVar(20)
      VelCoef2 = InVar(21)
      VelCoef3 = InVar(22)
      UpVelOffset = InVar(23)
      UpVelCoef = InVar(24)
      UpVelCoef2 = InVar(25)
      UpVelCoef3 = InVar(26)
      LowVelOffset = InVar(27)
      LowVelCoef = InVar(28)
      LowVelCoef2 = InVar(29)
      LowVelCoef3 = InVar(30)
      IsSubmersed = InVar(31)
      IsVMNClosed = InVar(32)
      FlowSign = InVar(33)
      #EndIf
      OneMinConsistent= InVar(34) 'if you want constant 1min data this will keep it on in case of power cycle
      #If HasVM = True Then
      #If UseAutoRange = True Then
        RangeSource = InVar(35)
        DucerDepthOffset = InVar(36)
      #EndIf
      #EndIf
      #If WqSonde <> "NONE" Then
        #If HasVM = True Then
        SondeOffset = InVar(37)
        #EndIf
        IsWqNClosed = InVar(38)
        #If WqSonde = "WQ_SERIAL_BURST" Then
          BurstPeriod = InVar(39)
        #EndIf
      #EndIf

    Case 7
      OneMinConsistent = InVar(1)
      #If WqSonde <> "NONE" Then
        IsWqNClosed = InVar(2)
      #EndIf

    Case 8
      OneMinConsistent = InVar(1)
      #If WqSonde <> "NONE" Then
        IsWqNClosed = InVar(2)
        #If WqSonde = "WQ_SERIAL_BURST" Then
          BurstPeriod = InVar(3)
        #EndIf
      #EndIf

    End Select
  EndSub

  'Store Variables to USR File (preserve variables)
  '--------------------------------------------------
  Sub StoreVariables
    'store variables out
    Dim Var(NumVars) As String
    Public SendVarString As String * 500
    Public VarStringLen As Long
    Public VarHandle = Long
    Public Varbytes = Long
    Public StoreCloseErr As Long
    Dim VarCnt As Long

    Select Case UsrCase
      #If HasVM = True Then
    Case 1
      Var(1) = StartBin
      Var(2) = EndBin
      Var(3) = StartEbbBin
      Var(4) = EndEbbBin
      Var(5) = StartFldBin
      Var(6) = EndFldBin
      Var(7) = BiRating
      Var(8) = BiRatTran
      Var(9) = SelStgPrime
      Var(10) = SelStgSecnd
      Var(11) = UpBeamOffset
      Var(12) = VMPressOffset
      Var(13) = PS1Offset
      Var(14) = PS2Offset
      Var(15) = CalcQ
      Var(16) = StgOffset
      Var(17) = StgCoef
      Var(18) = StgCoef2
      Var(19) = VelOffset
      Var(20) = VelCoef
      Var(21) = VelCoef2
      Var(22) = VelCoef3
      Var(23) = UpVelOffset
      Var(24) = UpVelCoef
      Var(25) = UpVelCoef2
      Var(26) = UpVelCoef3
      Var(27) = LowVelOffset
      Var(28) = LowVelCoef
      Var(29) = LowVelCoef2
      Var(30) = LowVelCoef3
      Var(31) = IsSubmersed
      Var(32) = IsVMNClosed
      Var(33) = FlowSign
      Var(34) = OneMinConsistent

    Case 2
      Var(1) = StartBin
      Var(2) = EndBin
      Var(3) = StartEbbBin
      Var(4) = EndEbbBin
      Var(5) = StartFldBin
      Var(6) = EndFldBin
      Var(7) = BiRating
      Var(8) = BiRatTran
      Var(9) = SelStgPrime
      Var(10) = SelStgSecnd
      Var(11) = UpBeamOffset
      Var(12) = VMPressOffset
      Var(13) = PS1Offset
      Var(14) = PS2Offset
      Var(15) = CalcQ
      Var(16) = StgOffset
      Var(17) = StgCoef
      Var(18) = StgCoef2
      Var(19) = VelOffset
      Var(20) = VelCoef
      Var(21) = VelCoef2
      Var(22) = VelCoef3
      Var(23) = UpVelOffset
      Var(24) = UpVelCoef
      Var(25) = UpVelCoef2
      Var(26) = UpVelCoef3
      Var(27) = LowVelOffset
      Var(28) = LowVelCoef
      Var(29) = LowVelCoef2
      Var(30) = LowVelCoef3
      Var(31) = IsSubmersed
      Var(32) = IsVMNClosed
      Var(33) = FlowSign
      Var(34) = OneMinConsistent
      #If UseAutoRange = True Then
        Var(35) = RangeSource
        Var(36) = DucerDepthOffset
      #EndIf
    #EndIf
    Case 3
      #If HasVM = True Then
      Var(1) = StartBin
      Var(2) = EndBin
      Var(3) = StartEbbBin
      Var(4) = EndEbbBin
      Var(5) = StartFldBin
      Var(6) = EndFldBin
      Var(7) = BiRating
      Var(8) = BiRatTran
      Var(9) = SelStgPrime
      Var(10) = SelStgSecnd
      Var(11) = UpBeamOffset
      Var(12) = VMPressOffset
      Var(13) = PS1Offset
      Var(14) = PS2Offset
      Var(15) = CalcQ
      Var(16) = StgOffset
      Var(17) = StgCoef
      Var(18) = StgCoef2
      Var(19) = VelOffset
      Var(20) = VelCoef
      Var(21) = VelCoef2
      Var(22) = VelCoef3
      Var(23) = UpVelOffset
      Var(24) = UpVelCoef
      Var(25) = UpVelCoef2
      Var(26) = UpVelCoef3
      Var(27) = LowVelOffset
      Var(28) = LowVelCoef
      Var(29) = LowVelCoef2
      Var(30) = LowVelCoef3
      Var(31) = IsSubmersed
      Var(32) = IsVMNClosed
      Var(33) = FlowSign
      #EndIf
      Var(34) = OneMinConsistent
      #If WqSonde <> "NONE" Then
        #If HasVM = True Then
        Var(35) = SondeOffset
        #EndIf
        Var(36) = IsWqNClosed
      #EndIf

    Case 4
      #If HasVM = True Then
      Var(1) = StartBin
      Var(2) = EndBin
      Var(3) = StartEbbBin
      Var(4) = EndEbbBin
      Var(5) = StartFldBin
      Var(6) = EndFldBin
      Var(7) = BiRating
      Var(8) = BiRatTran
      Var(9) = SelStgPrime
      Var(10) = SelStgSecnd
      Var(11) = UpBeamOffset
      Var(12) = VMPressOffset
      Var(13) = PS1Offset
      Var(14) = PS2Offset
      Var(15) = CalcQ
      Var(16) = StgOffset
      Var(17) = StgCoef
      Var(18) = StgCoef2
      Var(19) = VelOffset
      Var(20) = VelCoef
      Var(21) = VelCoef2
      Var(22) = VelCoef3
      Var(23) = UpVelOffset
      Var(24) = UpVelCoef
      Var(25) = UpVelCoef2
      Var(26) = UpVelCoef3
      Var(27) = LowVelOffset
      Var(28) = LowVelCoef
      Var(29) = LowVelCoef2
      Var(30) = LowVelCoef3
      Var(31) = IsSubmersed
      Var(32) = IsVMNClosed
      Var(33) = FlowSign
      #EndIf
      Var(34) = OneMinConsistent
      #If HasVM = True Then
      #If UseAutoRange = True Then
        Var(35) = RangeSource
        Var(36) = DucerDepthOffset
      #EndIf
      #EndIf
      #If WqSonde <> "NONE" Then
        #If HasVM = True Then
        Var(37) = SondeOffset
        #EndIf
        Var(38) = IsWqNClosed
      #EndIf

    Case 5
      #If HasVM = True Then
      Var(1) = StartBin
      Var(2) = EndBin
      Var(3) = StartEbbBin
      Var(4) = EndEbbBin
      Var(5) = StartFldBin
      Var(6) = EndFldBin
      Var(7) = BiRating
      Var(8) = BiRatTran
      Var(9) = SelStgPrime
      Var(10) = SelStgSecnd
      Var(11) = UpBeamOffset
      Var(12) = VMPressOffset
      Var(13) = PS1Offset
      Var(14) = PS2Offset
      Var(15) = CalcQ
      Var(16) = StgOffset
      Var(17) = StgCoef
      Var(18) = StgCoef2
      Var(19) = VelOffset
      Var(20) = VelCoef
      Var(21) = VelCoef2
      Var(22) = VelCoef3
      Var(23) = UpVelOffset
      Var(24) = UpVelCoef
      Var(25) = UpVelCoef2
      Var(26) = UpVelCoef3
      Var(27) = LowVelOffset
      Var(28) = LowVelCoef
      Var(29) = LowVelCoef2
      Var(30) = LowVelCoef3
      Var(31) = IsSubmersed
      Var(32) = IsVMNClosed
      Var(33) = FlowSign
      #EndIf
      Var(34) = OneMinConsistent
      #If WqSonde <> "NONE" Then
        #If HasVM = True Then
        Var(35) = SondeOffset
        #EndIf
        Var(36) = IsWqNClosed
        #If WqSonde = "WQ_SERIAL_BURST" Then
          Var(37) = BurstPeriod
        #EndIf
      #EndIf

    Case 6
      #If HasVM = True Then
      Var(1) = StartBin
      Var(2) = EndBin
      Var(3) = StartEbbBin
      Var(4) = EndEbbBin
      Var(5) = StartFldBin
      Var(6) = EndFldBin
      Var(7) = BiRating
      Var(8) = BiRatTran
      Var(9) = SelStgPrime
      Var(10) = SelStgSecnd
      Var(11) = UpBeamOffset
      Var(12) = VMPressOffset
      Var(13) = PS1Offset
      Var(14) = PS2Offset
      Var(15) = CalcQ
      Var(16) = StgOffset
      Var(17) = StgCoef
      Var(18) = StgCoef2
      Var(19) = VelOffset
      Var(20) = VelCoef
      Var(21) = VelCoef2
      Var(22) = VelCoef3
      Var(23) = UpVelOffset
      Var(24) = UpVelCoef
      Var(25) = UpVelCoef2
      Var(26) = UpVelCoef3
      Var(27) = LowVelOffset
      Var(28) = LowVelCoef
      Var(29) = LowVelCoef2
      Var(30) = LowVelCoef3
      Var(31) = IsSubmersed
      Var(32) = IsVMNClosed
      Var(33) = FlowSign
      #EndIf
      Var(34) = OneMinConsistent
      #If HasVM = True Then
      #If UseAutoRange = True Then
        Var(35) = RangeSource
        Var(36) = DucerDepthOffset
      #EndIf
      #EndIf
      #If WqSonde <> "NONE" Then
        #If HasVM = True Then
        Var(37) = SondeOffset
        #EndIf
        Var(38) = IsWqNClosed
        #If WqSonde = "WQ_SERIAL_BURST" Then
          Var(39) = BurstPeriod
        #EndIf
      #EndIf

    Case 7
      Var(1) = OneMinConsistent
      #If WqSonde <> "NONE" Then
        Var(2) = IsWqNClosed
      #EndIf

    Case 8
      Var(1) = OneMinConsistent
      #If WqSonde <> "NONE" Then
        Var(2) = IsWqNClosed
        #If WqSonde = "WQ_SERIAL_BURST" Then
          Var(3) = BurstPeriod
        #EndIf
      #EndIf
    End Select

    'build send string
    SendVarString = Var(1)
    For VarCnt = 2 To NumVars
      SendVarString = SendVarString + "," + Var(VarCnt)
    Next VarCnt
    VarStringLen = Len(SendVarString)
    VarHandle = FileOpen("USR:VariableStore.txt","w",-1)
    Delay(1,100,mSec)
    Varbytes = FileWrite(VarHandle,SendVarString,VarStringLen + 50)
    StoreCloseErr = FileClose(VarHandle)
    StoreVariablesFlg = False
  EndSub
#EndIf
'=========================================================================
'---------------------- RADIO NETWORK SUBS -------------------------------
'=========================================================================
#If RadioNetwork = True Then
  '__________________________READ IN CURRENT SETTINGS OF RADIO_______________________
  Sub ReadRF
    RadOn = Settings.RadioEnable
    RadOpMode = Settings.RadioOpMode
    RadFreqKey = Settings.RadioFreqKey
    RadMaxPacket = Settings.RadioMaxPacket
    RadMinPacket = Settings.RadioMinPacket
    RadDataRate = Settings.RadioDataRate
    RadTxPwr = Settings.RadioTxPwr
    RadRetryTO = Settings.RadioRetryTimeout
    RadLowPwr = Settings.RadioLowPwr
    RadRepeaters = Settings.RadioRepeaters
    RadPacketRepeat = Settings.RadioPacketRepeat
    RadSlaveRetry = Settings.RadioSlaveRetry
    RadFreqRepeat = Settings.RadioFreqRepeat
    RadSlaveRepeat = Settings.RadioSlaveRepeat
    RadRxSubID = Settings.RadioRxSubID
    RadTxSubID = Settings.RadioTxSubID
    RadNetID = Settings.RadioNetID
    ReadRadSettings = False
  EndSub

  '_________________________STORE THE SETTINGS TO USR DRIVE BASED ON THE ABOVE SUBROUTINE VARIABLES___________________
  Sub StoreRadSettings
    Public RadVar(17) As String 'establish a placeholder array
    Public SendRadSetString As String * 256 'create a string that will be used to send to the USR drive
    Public RadStringLen As Long 'length of string being stored
    Public RadVarHandle As Long 'short name to be used in opening/reading/writing the User Radio Settings
    Public RadVarBytes As Long 'number of bytes successfully written to file
    Public StoreRadCloseErr 'variable to store whether file closure was a success or not. 0 = success, -1 = FileHandle referenced is not valid or if file was not previously opened/is already closed.
    Public RadVarCnt As Long 'counter to establish number of times For To loop needs to continue
    RadVar(1) = RadOn 'assign each value in RadVar() to a variable previously read in in the ReadRF subroutine
    RadVar(2) = RadOpMode
    RadVar(3) = RadFreqKey
    RadVar(4) = RadMaxPacket
    RadVar(5) = RadMinPacket
    RadVar(6) = RadDataRate
    RadVar(7) = RadTxPwr
    RadVar(8) = RadRetryTO
    RadVar(9) = RadLowPwr
    RadVar(10) = RadRepeaters
    RadVar(11) = RadPacketRepeat
    RadVar(12) = RadSlaveRetry
    RadVar(13) = RadFreqRepeat
    RadVar(14) = RadSlaveRepeat
    RadVar(15) = RadRxSubID
    RadVar(16) = RadTxSubID
    RadVar(17) = RadNetID
    SendRadSetString = RadVar(1) 'start writing the string out starting with the first value in the array
    For RadVarCnt = 2 To 17 'from RadVar(2) through RadVar(n) build the string using For To Next Loop
      SendRadSetString = SendRadSetString + "," + RadVar(RadVarCnt) 'SendRadSetString gets built using a comma for a delimiter for the entire length of the array
    Next RadVarCnt 'move to next variable in array until string is complete
    RadStringLen = Len(SendRadSetString) 'Len returns the length of the string in bytes
    RadVarHandle = FileOpen("USR:UserRadSettings.txt","w",-1) 'Establish the "FileHandle" by opening (or creating if first open call) the file "UserRadSettings.txt" in the USR drive.
    Delay (1,100,msec) 'delay processing to make sure file was opened
    RadVarBytes = FileWrite (RadVarHandle,SendRadSetString,RadStringLen + 15) 'record how many bytes were written to file. Added 15 bytes to the expected length to make sure nothing gets missed
    StoreRadCloseErr = FileClose(RadVarHandle) 'close the file, return whether closure was successful
  EndSub
  'EndSub

  '_______________________RESET RADIO TO FACTORY DEFAULT SETTINGS_______________________
  '__________Factory setting for RadioEnabled is True (On). I turn it off, as the purpose of this is to essentially reboot the radio system
  Sub ResetRadDefault
    SetSetting("RadioEnable",DefRadOn) 'SetSetting for the settings in quotes based on the Const values establish in variable declarations, Ex: DefRadOn = 0, DefOpMode = 2, etc.)
    SetSetting("RadioOpMode",DefOpMode)
    SetSetting("RadioFreqKey",DefFreqKey)
    SetSetting("RadioMaxPacket",DefMaxPacket)
    SetSetting("RadioMinPacket",DefMinPacket)
    SetSetting("RadioDataRate",DefDataRate)
    SetSetting("RadioTxPwr",DefTxPwr)
    SetSetting("RadioRetryTimeout",DefRetryTO)
    SetSetting("RadioLowPwr",DefLowPwr)
    SetSetting("RadioRepeaters",DefRepeaters)
    SetSetting("RadioPacketRepeat",DefPacketRepeat)
    SetSetting("RadioSlaveRetry",DefSlaveRetry)
    SetSetting("RadioFreqRepeat",DefFreqRepeat)
    SetSetting("RadioSlaveRepeat",DefSlaveRepeat)
    SetSetting("RadioRxSubID",DefRxSubID)
    SetSetting("RadioTxSubID",DefTxSubID)
    SetSetting("RadioNetID",DefNetID)
  EndSub

  '_________________________RESET RADIO BACK TO USER SETTINGS PREVIOUSLY STORED IN USR______________________
  '
  Sub SetRadSetting
    'Set Radio Settings to User settings from USR Drive
    Public UserRadSettings As String * 60 'Variable to store settings string from USR
    Public SetRadHandle As Long 'FileHandle of the "UserRadSettings.txt"
    Public SetRadFileLen As Long 'Length of the user settings file in bytes
    Public SetCloseErr 'If the file was closed successfully or not. 0 = successful, -1 = FileHandle not valid or handle was not opened
    Public RadFileClosure As String * 26 'Text to let User know whether reading settings was successful or not (based on number of bytes)
    SetRadHandle = FileOpen("USR:UserRadSettings.txt","r",-1) 'open saved user settings for radio
    Delay (1,30,mSec) 'delay processing
    SetRadFileLen = FileRead(SetRadHandle,UserRadSettings,500) 'read in the file, store it to the variable "UserRadSettings"
    SetCloseErr = FileClose(SetRadHandle) 'indicate whether the closure was successful
    If SetRadFileLen = 0 Then 'if FileLength = 0
      RadFileClosure = "Error: Settings not found!" 'Show text to user
      SetRadSettings = False 'Don't set radio settings
      ExitSub 'exit the subroutine
    EndIf
    Public InRadVar(17) As String 'create array to store the values from string once it's split
    SplitStr(InRadVar,UserRadSettings,",",17,0) 'split the "UserRadSettings" string into InRadVar(), comma delimited, n array size
    RadOn = InRadVar(1) 'fill each variable with appropriate value from array
    RadOpMode = InRadVar(2)
    RadFreqKey = InRadVar(3)
    RadMaxPacket = InRadVar(4)
    RadMinPacket = InRadVar(5)
    RadDataRate = InRadVar(6)
    RadTxPwr = InRadVar(7)
    RadRetryTO = InRadVar(8)
    RadLowPwr = InRadVar(9)
    RadRepeaters = InRadVar(10)
    RadPacketRepeat = InRadVar(11)
    RadSlaveRetry = InRadVar(12)
    RadFreqRepeat = InRadVar(13)
    RadSlaveRepeat = InRadVar(14)
    RadRxSubID = InRadVar(15)
    RadTxSubID = InRadVar(16)
    RadNetID = InRadVar(17)
    SetSetting("RadioEnable",RadOn) 'now, SetSetting to set the radio to the settings read in from USR
    SetSetting("RadioOpMode",RadOpMode)
    SetSetting("RadioFreqKey",RadFreqKey)
    SetSetting("RadioMaxPacket",RadMaxPacket)
    SetSetting("RadioMinPacket",RadMinPacket)
    SetSetting("RadioDataRate",RadDataRate)
    SetSetting("RadioTxPwr",RadTxPwr)
    SetSetting("RadioRetryTimeout",RadRetryTO)
    SetSetting("RadioLowPwr",RadLowPwr)
    SetSetting("RadioRepeaters",RadRepeaters)
    SetSetting("RadioPacketRepeat",RadPacketRepeat)
    SetSetting("RadioSlaveRetry",RadSlaveRetry)
    SetSetting("RadioFreqRepeat",RadFreqRepeat)
    SetSetting("RadioSlaveRepeat",RadSlaveRepeat)
    SetSetting("RadioRxSubID",RadRxSubID)
    SetSetting("RadioTxSubID",RadTxSubID)
    SetSetting("RadioNetID",RadNetID)
    SetRadSettings = False 'turn off flag
  EndSub

  '_____________________________Establish means of verifying successful communication

  #If IsMaster = True Then 'if it's the master in the network
    Sub CheckLinks 'follow this subroutine
      SendToNetwork = SendToNetwork + 1 'placeholder variable used to send to slave loggers
      If SendToNetwork >= 150 Then 'count to 150
        SendToNetwork = 0 'then reset (arbitrary numbers)
      EndIf
      #If NetworkSlaves = 1 Then 'if there's one slave in the network
        SendVariables (SendToAresult,COMRF,-1,NeighborApb,NeighborASecCode,0,"Public","MasterReceive",SendToNetwork,1) 'send "SendToNetwork Variable to Node "A".
        If SendToAresult <> 0 Then 'Result from above, 0 = successful comms, non-0 = failure of some sort.
          SendToAFailCnt = SendToAFailCnt + 1 'if comms failed, count up
        Else 'if comms successful
          SendToAFailCnt = 0 'reset counter
          LinkToAdead = False 'set "Dead" flag to false
          ResetMaster = False 'don't set flag to reset the radio
          RadResetAttempts = 0 'Set reset attempt counter back to 0
        EndIf
        If SendToAFailCnt >= MaxAFails 'if fail counter exceeds threshold
          LinkToAdead = True 'all links are dead
          ResetMaster = True 'set reset flag
          SendToAFailCnt = 0 'reset counter to 0, use counter to make sure radio doesn't continually attempt to reset once the link is considered dead
        EndIf
      #EndIf 'if 1 node
      #If NetworkSlaves = 2 Then 'if 2 slaves in the network, see comments above
        SendVariables (SendToAresult,COMRF,-1,NeighborApb,NeighborASecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave A
        If SendToAresult <> 0 Then
          SendToAFailCnt = SendToAFailCnt + 1
          RadResetAttempts = 0
        Else
          SendToAFailCnt = 0
          LinkToAdead = False
          ResetMaster = False 'don't set flag to reset the radio
        EndIf
        If SendToAFailCnt >= MaxAFails
          LinkToAdead = True
          SendToAFailCnt = 0
        EndIf
        SendVariables (SendToBresult,COMRF,-1,NeighborBpb,NeighborBSecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave B
        If SendToBresult <> 0 Then
          SendToBFailCnt = SendToBFailCnt + 1
        Else
          SendToBFailCnt = 0
          LinkToBdead = False
          ResetMaster = False 'don't set flag to reset the radio
          RadResetAttempts = 0
        EndIf
        If SendToBFailCnt >= MaxBFails
          LinkToBdead = True
        EndIf
        If LinkToAdead AND LinkToBdead Then 'only count towards fails if BOTH links are dead, something may be wrong with master.
          AllLinksDead = AllLinksDead + 1 'counter for how many times both links are dead
          If AllLinksDead >= MaxLinksDeadCnt Then 'if counter exceeds threshold
            ResetMaster = True 'set flag to reset master
            SendToAFailCnt = 0 'reset the counter for each slave
            SendToBFailCnt = 0
            AllLinksDead = 0 'reset the "AllLinksDead" counter
          EndIf
        EndIf
      #EndIf 'if 2 nodes
      #If NetworkSlaves = 3 Then 'if 3 slaves in network
        SendVariables (SendToAresult,COMRF,-1,NeighborApb,NeighborASecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave A
        If SendToAresult <> 0 Then
          SendToAFailCnt = SendToAFailCnt + 1
        Else
          SendToAFailCnt = 0
          LinkToAdead = False
          ResetMaster = False 'don't set flag to reset the radio
          RadResetAttempts = 0
        EndIf
        If SendToAFailCnt >= MaxAFails
          LinkToAdead = True
        EndIf
        SendVariables (SendToBresult,COMRF,-1,NeighborBpb,NeighborBSecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave B
        If SendToBresult <> 0 Then
          SendToBFailCnt = SendToBFailCnt + 1
        Else
          SendToBFailCnt = 0
          LinkToBdead = False
          ResetMaster = False 'don't set flag to reset the radio
          RadResetAttempts = 0
        EndIf
        If SendToBFailCnt >= MaxBFails
          LinkToBdead = True
        EndIf
        SendVariables (SendToCresult,COMRF,-1,NeighborCpb,NeighborCSecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave C
        If SendToCresult <> 0 Then
          SendToCFailCnt = SendToCFailCnt + 1
        Else
          SendToCFailCnt = 0
          LinkToCdead = False
          ResetMaster = False 'don't set flag to reset the radio
          RadResetAttempts = 0
        EndIf
        If SendToCFailCnt >= MaxCFails
          LinkToCdead = True
        EndIf
        If LinkToAdead AND LinkToBdead AND LinkToCdead Then 'only count towards fails if ALL links are dead, something may be wrong with master.
          AllLinksDead = AllLinksDead + 1
          If AllLinksDead >= MaxLinksDeadCnt Then
            ResetMaster = True
            SendToAFailCnt = 0
            SendToBFailCnt = 0
            SendToCFailCnt = 0
            AllLinksDead = 0
          EndIf
        EndIf
      #EndIf 'if 3 nodes
      #If NetworkSlaves = 4 Then '4 slaves in network
        SendVariables (SendToAresult,COMRF,-1,NeighborApb,NeighborASecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave A
        If SendToAresult <> 0 Then
          SendToAFailCnt = SendToAFailCnt + 1
        Else
          SendToAFailCnt = 0
          LinkToAdead = False
          ResetMaster = False 'don't set flag to reset the radio
          RadResetAttempts = 0
        EndIf
        If SendToAFailCnt >= MaxAFails
          LinkToAdead = True
        EndIf
        SendVariables (SendToBresult,COMRF,-1,NeighborBpb,NeighborBSecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave B
        If SendToBresult <> 0 Then
          SendToBFailCnt = SendToBFailCnt + 1
        Else
          SendToBFailCnt = 0
          LinkToBdead = False
          ResetMaster = False 'don't set flag to reset the radio
          RadResetAttempts = 0
        EndIf
        If SendToBFailCnt >= MaxBFails
          LinkToBdead = True
        EndIf
        SendVariables (SendToCresult,COMRF,-1,NeighborCpb,NeighborCSecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave C
        If SendToCresult <> 0 Then
          SendToCFailCnt = SendToCFailCnt + 1
        Else
          SendToCFailCnt = 0
          LinkToCdead = False
          ResetMaster = False 'don't set flag to reset the radio
          RadResetAttempts = 0
        EndIf
        If SendToCFailCnt >= MaxCFails
          LinkToCdead = True
        EndIf
        SendVariables (SendToDresult,COMRF,-1,NeighborDpb,NeighborDSecCode,0,"Public","MasterReceive",SendToNetwork,1) 'Slave D
        If SendToDresult <> 0 Then
          SendToDFailCnt = SendToDFailCnt + 1
        Else
          SendToDFailCnt = 0
          LinkToDdead = False
          ResetMaster = False 'don't set flag to reset the radio
          RadResetAttempts = 0
        EndIf
        If SendToDFailCnt >= MaxDFails
          LinkToDdead = True
        EndIf
        If LinkToAdead AND LinkToBdead AND LinkToCdead AND LinkToDdead Then 'only count towards fails if ALL links are dead, something may be wrong with master.
          AllLinksDead = AllLinksDead + 1
          If AllLinksDead >= MaxLinksDeadCnt Then
            ResetMaster = True
            SendToAFailCnt = 0
            SendToBFailCnt = 0
            SendToCFailCnt = 0
            SendToDFailCnt = 0
            AllLinksDead = 0
          EndIf
        EndIf
      #EndIf 'if 4 nodes
    EndSub
  #EndIf 'if IsMaster = True

  #If IsMaster = False Then 'if it's in a radio network, but not the master
    Sub CheckSlaveLink 'subroutine to run if it's a slave
      GetVariables (GetResult,COMRF,-1,MasterPB,MasterSecCode,0,"Public","SendToNetwork",MasterReceive,1) 'GetVariable "SendToNetwork" from master, store in MasterReceive
      If GetResult <> 0 Then 'if GetVariables was NOT successful (success = 0, fail <> 0)
        GetFailCnt = GetFailCnt + 1 'start counter
      Else 'if it was successful
        GetFailCnt = 0 'reset counter
        LinkDead = False 'link is not dead
        ResetSlave = False 'don't set flag to reset the radio
        RadResetAttempts = 0 'Set reset attempt counter to 0
      EndIf
      If GetFailCnt >= MaxGetFails Then 'if failure counter exceeds threshold
        LinkDead = True 'link is considered dead
      EndIf
      If LinkDead = True Then 'if the link is dead
        ResetSlave = True 'set flag to reset radio
        GetFailCnt = 0 'reset counter to 0
      EndIf
    EndSub
  #EndIf 'if IsMaster = False
#EndIf 'if radio network

#If HasIridium = True Then
  '___________________________________________Iridium SDI12 Output___________________
  Sub IridiumDataOut
    '  Create new variables to capture important data from the Aquarius field
    'these varialbes will always be present
    StationVolts_IRD = Aquarius.StationVolts_Min
    AvgPS1Stg_IRD = Aquarius.PS1Stg_Avg
    AvgPS2Stg_IRD = Aquarius.PS2Stg_Avg
    AvgUpBeamStg_IRD = Aquarius.UpBeamStg_Avg
    AvgIndexVel_IRD = Aquarius.IndexVel_Avg
    AvgVMTemp_IRD = Aquarius.VMTempC_Avg
    AvgVMPitch_IRD = Aquarius.VMPitch_Avg
    AvgVMRoll_IRD = Aquarius.VMRoll_Avg

    #If WqSonde = "WQ_SERIAL_BURST" Then 'burst WQ data
      MedBurstDate_IRD = Aquarius.MedBurstDate
      MedBurstTime_IRD = Aquarius.MedBurstTime
      MedTempC_IRD = Aquarius.MedTempC
      MedSpCond_IRD = Aquarius.MedSpCond
      MedTurbFNU_IRD = Aquarius.MedTurbFNU
      #If TopBottom = False Then
        WqBattV_Min_IRD = Aquarius.WqBatt_Min
      #Else
        BtmMedTempC_IRD = Aquarius.BtmMedTempC
        BtmMedSpCond_IRD = Aquarius.BtmMedSpCond
        BtmMedTurbFNU_IRD = Aquarius.BtmMedTurbFNU
      #EndIf
    #EndIf

    #If (WqSonde = "WQ_SERIAL") Then 'non-burst WQ data
      WqDate_IRD = Aquarius.WqDate
      WqTime_IRD = Aquarius.WqTime
      WqTempC_IRD = Aquarius.WqTempC
      WqSpCond_IRD = Aquarius.WqSpCond
      WqTurbFNU_IRD = Aquarius.WqTurbFNU
      #If TopBottom = False Then
        WqBattV_Min_IRD = Aquarius.WqBatt_Min
      #Else
        BtmTempC_IRD = Aquarius.BtmWqTempC
        BtmSpCond_IRD = Aquarius.BtmWqSpCond
        BtmTurbFNU_IRD = Aquarius.BtmWqTurbFNU
      #EndIf
    #EndIf
    'Build the array
    'with the data that will always be there
    IridiumOutArray(1) = StationVolts_IRD
    IridiumOutArray(2) = AvgIndexVel_IRD
    IridiumOutArray(3) = AvgPS1Stg_IRD
    IridiumOutArray(4) = AvgPS2Stg_IRD
    IridiumOutArray(5) = AvgUpBeamStg_IRD
    IridiumOutArray(6) = AvgVMTemp_IRD
    IridiumOutArray(7) = AvgVMPitch_IRD
    IridiumOutArray(8) = AvgVMRoll_IRD

    #If WqSonde = "WQ_SERIAL_BURST" Then 'add on the burst water quality data
      IridiumOutArray(9) = MedBurstDate_IRD
      IridiumOutArray(10) = MedBurstTime_IRD
      IridiumOutArray(11) = MedTempC_IRD
      IridiumOutArray(12) = MedSpCond_IRD
      IridiumOutArray(13) = MedTurbFNU_IRD
      #If TopBottom = False Then
        IridiumOutArray(14) = WqBattV_Min_IRD
      #Else
        IridiumOutArray(14) = BtmMedTempC_IRD
        IridiumOutArray(15) = BtmMedSpCond_IRD
        IridiumOutArray(16) = BtmMedTurbFNU_IRD
      #EndIf
    #EndIf

    #If WqSonde = "WQ_SERIAL" Then 'or just add on the non-burst WQ data
      IridiumOutArray(9) = WqDate_IRD
      IridiumOutArray(10) = WqTime_IRD
      IridiumOutArray(11) = WqTempC_IRD
      IridiumOutArray(12) = WqSpCond_IRD
      IridiumOutArray(13) = WqTurbFNU_IRD
      #If TopBottom = False Then
        IridiumOutArray(14) = WqBattV_Min_IRD
      #Else
        IridiumOutArray(14) = BtmTempC_IRD
        IridiumOutArray(15) = BtmSpCond_IRD
        IridiumOutArray(16) = BtmTurbFNU_IRD
      #EndIf
    #EndIf
  EndSub

  Sub CycleIridiumPower
    PortSet(IridiumSwitchPort,1)
    IridiumManualCycle = False
  EndSub
#EndIf

#If HasGPS = True Then
  Sub CycleGPSPower
    If DOW = 2 AND ModDay >= 0 AND ModDay < 46800 Then 'if Day of Week is Monday and time of day is between 00:00 and 13:00
      SW12(SW12_2,1) 'Power the GNSS receiver on
    Else
      SW12(SW12_2,0) 'Otherwise keep it off
    EndIf
  EndSub
#EndIf

#If HasHMS = True Then
  Sub HMS
    PortSet(HMS_OkPort,1) ' always send out an "OK" signal, this verifies we made it through a scan
    Delay(1,1,Sec)
    PortSet(HMS_OkPort,0)
    If HMS_Disable = True Then ExitSub
    #If HasVM = True Then
      If HMS_VMcount >= 670 Then 'if we've gone 12hr without VM data
        WeBad = True 'set our "catastrophy" flag true
      EndIf
    #EndIf
    #If WqSonde <> "NONE" Then
      If HMS_WQcount >= 1440 Then 'if we've gone 24hr without WQ data
        WeBad = True 'set flag
      EndIf
      #If TopBottom = True Then
        If HMS_BtmWQCount >= 1440 Then 'if we've gone 24hr without btm wq data
          WeBad = True 'set flag
        EndIf
      #EndIf
    #EndIf
    #If HasModem = True Then
      If HMS_ModCount >= 1440 Then 'if we've gone 24hr without modem
        WeBad = True 'set flag
      EndIf
      If HMS_ModFlag = True Then 'if we've gone at least 4hr without modem AND one of the following
        #If HasVM = True Then
          If HMS_VMFlag = True Then '4hr without VM
            WeBad = True 'set flag
          EndIf
        #EndIf
        #If WqSonde <> "NONE" Then
          If HMS_WqFlag = True Then 'OR 4hr without WQ
            WeBad = True 'set flag
          EndIf
          #If TopBottom = True Then
            If HMS_BtmWqFlag = True Then 'OR 4hr without btm wq
              WeBad = True 'set flag
            EndIf
          #EndIf
        #EndIf
      EndIf
      #EndIf
      If HMS_Manual = False Then 'if it's not a manual trigger check standard methods
        If WeBad = True AND HMS_24hrcount >= 1440 Then 'if we've met "catastrophy" failure status and it's been 24hr since logger reboot
          CallTable HMSTable 'call table so we can have a record of what caused the problem
          PortSet(HMS_ErrPort,1) 'flip our switch high/send signal to arduino
          Delay(1,1,Sec) 'delay for 1s (arduino is on a 0.5s "scan", 1s ensures signal to be heard)
          PortSet(HMS_ErrPort,0) 'set port back to low, in case arduino didn't catch it
          WeBad = False 'set flag back to false, in case arduino didn't flip the switch
          HMS_Manual = False
        EndIf
      Else 'if it is a manual trigger
        CallTable HMSTable 'call table so we can have a record of what caused the problem
        PortSet(HMS_ErrPort,1) 'flip our switch high/send signal to arduino
        Delay(1,1,Sec) 'delay for 1s (arduino is on a 0.5s "scan", 1s ensures signal to be heard)
        PortSet(HMS_ErrPort,0) 'set port back to low, in case arduino didn't catch it
        WeBad = False 'set flag back to false, in case arduino didn't flip the switch
        HMS_Manual = False
      EndIf
    EndSub
  #EndIf
  '========================================================================================
  '------------------------------- MAIN PROGRAM -------------------------------------------
  '========================================================================================
  PreserveVariables

  BeginProg
    SetStatus ("USRDriveSize",16384)
    #If HasVM = True OR WqSonde <> "NONE" Then
      Call CheckCase
    #EndIf
    Call UserDefaults 'formerly named "GetStartup"
    Call Initialize
    Call SetPorts
    #If HasVM = True Then
      Call OpenADCPPort
    #EndIf
    #If WqSonde <> "NONE" Then
      Call OpenWQPort
    #EndIf
    #If HasSuna = True Then 'programatically establish SunaPort as a ComPort before the scan. Otherwise, it waits until the 15th minute to allow a user to open/watch the port for in the emulator.
      SerialOpen(SunaPort,115200,0,0,6000)
      SerialFlush(SunaPort)
      SerialClose(SunaPort)
    #EndIf
    #If RadioNetwork = True Then
      ResetTryOK = True 'It's ok to try a reset once initial dead thresholds have been met, no need to wait.
      NextTryCnt = MaxNextTryCnt 'set nexttry to maxnexttry so we can reset the radio without waiting the first time.
    #EndIf

    '=========================================================================
    '---------------- SCAN STARTS HERE ---------------------------------------
    '=========================================================================
    Scan(ScanRate,ScanUnit,5,0) 'Start scan, default = 60sec scan rate
      Call GetSysInfo 'Get our system vitals and start timer for debugging
      CurrentDateTime = SecsSince1990(Status.Timestamp,1)
      CheckDateTime = SecsSince1990(AvgChangeTime,1)
      If CurrentDateTime >= CheckDateTime Then
        NewAvg = True
      Else
        NewAvg = False
      EndIf      
      #If HasVM = True OR WqSonde <> "NONE" Then
        If GetVariablesFlg = True Then
          Call ReadVariables
          GetVariablesFlg = False
        EndIf
      #EndIf
      #If HasVM = True Then 'if we have a VM make sure it's powered first thing
        Call ToggleVMPower 'Turn power on or off, based on user input
      #EndIf 'if we have VM
      #If WqSonde <> "NONE" Then
        Call WqPwrOn
      #EndIf
      RealTime(rTime) 'get time for start of scan. Note, this produces the timestamp at START of scan, no matter where it's placed within scan
      Call CalcMods 'calculate "Mod" times for timing intervals
      #If HasGPS Then
        Call CycleGPSPower
      #EndIf
      #If HasSuna = True Then
        If ManualSunaOn = True Then 'if user wants suna powered
          SerialOpen(SunaPort,115200,0,0,6000) 'open the port
          PortSet(SunaSwitch,1) 'turn it on
        Else
          SerialFlush(SunaPort) 'otherwise flush, close, and turn off
          SerialClose(SunaPort)
          PortSet(SunaSwitch,0)
        EndIf
        If Mod15Minutes = 840 Then '14th minute for suna stuff
          WipeSuna = True 'set a trigger to wipe the suna
          ManSunaWiper = False 'turn off the manual suna wiper
          ManualSunaOn = False 'turn off the manual suna power
          SerialFlush(SunaPort) 'flush port
          SerialClose(SunaPort) 'close port
          PortSet(SunaSwitch,0) 'turn power off to suna
        EndIf
        If Mod15Minutes = 0 Then 'top of 15th min for suna stuff
          ManSunaWiper = False 'keep manual wiper off
          PortSet(SunaSwitch,1) 'turn the suna on
          Timer(SunaSampleTimer,mSec,2) 'Start warmup timer
          SampleSuna = True 'Set flag for sampling routine
        ElseIf Mod15Minutes <> 0 AND ManualSunaOn = False Then
          PortSet(SunaSwitch,0) 'otherwise keep suna off
          SampleSuna = False 'don't trigger sampling routine
        EndIf
        If ManSunaWiper = True AND WipeSuna <> True AND SampleSuna <> True Then 'only allow user to turn wiper on outside of 14th and 15th min
          PortSet (SunaWipeSwitch,1)
        Else
          PortSet (SunaWipeSwitch,0)
        EndIf
      #EndIf
      If ModDay = 0 Then 'it's Midnight, so set flags to set instrument clocks at beginning of scan
        'StoreVariablesFlag = True 'Set flag to store critical variables to USR drive
        Rec24HrFlag = True
        #If HasVM = True Then 'if we have VM
          SetVMTimeFlg = True
        #EndIf 'if we have VM
        #If WqSonde <> "NONE" Then 'if serial sonde
          SetEXOTimeFlg = True 'set flag to set the flag at midnight
        #EndIf 'if sonde present
      Else 'not Midnight keep 24hr flag false
        Rec24HrFlag = False
      EndIf 'if it's midnight
      If Mod15Minutes = 0 Then 'at top of 15min interval ( hh:00, hh:15, hh:30, hh:45)
        FTimeIn = 1 'set Select Case value for FTime function
        TimeStamp15Min = FTime(Public.Timestamp) 'store timestamp to allow for centering vel/stage data in sample period
        #If WqSonde = "WQ_SERIAL_BURST" Then
          GetBurst = True
        #EndIf
      EndIf 'top of 15min interval
      #If WqSonde <> "NONE" Then
        If Mod15Minutes = 840 Then 'If 14th minute for EXO wipe
          WipeFlag = True
        Else
          WipeFlag = False
        EndIf
      #EndIf 'Make "WipeFlag" variable available for either Suna or Sonde. Both being wiped in 14min, just at different times.
      If NewAvg = True Then
      If Mod15Minutes = 420 Then 'at the 7th minute into a 15min interval. Use this to center vel and stage over sample period
        Rec15MinFlag = True 'set trigger for storage to 15min tables
      Else 'if not 7min in
        Rec15MinFlag = False
      EndIf 'determine time into 15min interval
      Else
        If Mod15Minutes = 0 Then
          Rec15MinFlag = True
          Else
            Rec15MinFlag = False
        EndIf
      EndIf
      If RecCalibData = True Then 'if we want 1 min data
        Rec1MinFlag = True
      Else 'if the user set it back to false
        Rec1MinFlag = False 'stop recording 1min data
        OneMinCount = 0 'reset the counter
      EndIf 'we don't want 1min data
      If OneMinCounterReset = True Then 'user wants to force a reset to the counter
        RecCalibData = True 'Verify RecCalibData gets turned back on in case we reset directly at 24hr
        Rec1MinFlag = True 'we want 1min data
        OneMinCount = 0 'reset the counter
      EndIf
      If Rec1MinFlag = True Then 'if 1min flag is set to true
        OneMinCount = OneMinCount + 1 'increase counter
        If OneMinCount > 1439 Then 'If 24hours has been recorded
          RecCalibData = False 'set to false
          Rec1MinFlag = False  'set to false
          OneMinCount = 0 'reset counter
        EndIf 'if we got 24hr of data
      EndIf 'if 1min flag is true

      '========================================================================
      '-------------------- CALL VM SUBS HERE --------------------------------
      '========================================================================

      #If HasVM = True Then 'if we have a VM
        VMTimeStart = Timer(DebugTimer,mSec,4)
        VMTimeStart = VMTimeStart/1000
        Call GetVMData 'Perform loops to pull data from buffer
        If ADCPDone = True Then 'only run checksum/decoders if loop got all data
          Call CheckSumCheck
          If CalcCheckSum <> EnsCheckSum OR CalcCheckSum = 0 Then 'if we had a bad checksum, no checksum, or 0 bytes
            VMdataIn = False
            BadEnsemble = BadEnsemble + 1
            BadCheckSum = BadCheckSum + 1
            VMDeadCount = VMDeadCount + 1
            #If HasHMS = True Then
              HMS_VMcount = HMS_VMcount + 1
              If HMS_VMcount >= HMS_BadThresh Then
                HMS_VMFlag = True
              EndIf
            #EndIf
            If VMDeadCount >= VMDeadCntMax Then 'if reached "dead" threshold
              WakeUpVM = True 'set flag to try to reset VM
            EndIf ' "dead" threshold check
            SerialFlush (AdcpPort) 'flush the port
          Else 'if we have good data based on check sum
            VMdataIn = True 'set flag to true
            VMDeadCount = 0 'set counter to 0
            #If HasHMS = True Then
              HMS_VMcount = 0
              HMS_VMFlag = False
            #EndIf
            Call MainDecode 'call the main decoder
            #If UseAutoRange = True Then 'if uplooker with autorange set
              Call CalcRangeBin 'calculate our ranged bin
            #EndIf 'autorange
            Call OneMinuteCalcs 'perform 1min vel calcs
          EndIf 'If good checksum
        EndIf 'If ADCP Loop is "Done"
        Call GetStage 'get/true our stage outside of good checksums because we sample Pressure sensors here too
        Call CalculateQ 'calculate discharge
        Call GetSN 'get serial numbers either way. If no VM, then SN = 0
        Call VMCenter 'get center of ADCP time after new ensemble comes in
        If SetVMTimeFlg = True OR SendTF = True Then 'if we want to set the time/set TF
          Call SetVMTime
        EndIf 'set time/TF
        #If GetNoiseFloor = True Then 'if we want noisefloor
          If SendPT3 = True AND TimeIntoInterval(PT3Time,1440,Min) AND OneMinConsistent = False AND RecCalibData = False Then 'at X min after midnight. Skip this if recording 1min data
            CMD = "PT3"
            SendCMD = True
          EndIf 'if automatic time for PT3
        #EndIf 'if we want noise floor
        If SendCMD = True Then Call SendSetup 'if we want to send a command via CMD variable
        Call GetVMFreeMem 'check workhorse memory
        #If StoreAllToCard = True Then 'if we want to store all 1min spikes to card
          If ScanNum >= 20 Then 'make sure buffer is full before checking spikes
            Call CheckSpikes 'check for spikes using rolling 15min data
            Call StoreAllData 'store the spikes to the card
          EndIf 'if we have 20 scans
          Call AddSpikes 'remove oldest data from buffer, fill with new value
        #EndIf 'if we want to store to card
        If WakeUpVM = True Then Call WakeVM 'Either user established or auto based on "VM Dead"
        VMTimeEnd = Timer(DebugTimer,mSec,4)
        VMTimeEnd = VMTimeEnd/1000
        VMTotTime = VMTimeEnd - VMTimeStart
      #EndIf 'If we have a velocity meter present
      '==================================================================================
      '------------------END OF VM SPECIFIC SUB CALLS -----------------------------------
      '==================================================================================

      '==================================================================================
      '------------------ START OF WQ SPECIFIC SUB CALLS --------------------------------
      '==================================================================================
      #If WqSonde <> "NONE" Then
        Call RedeploySonde 'Call the redeploy routine if Flag is set, need to get parameter order before pulling any data
        Call GetWqData
        Delay(1,2500,mSec) 'delay to give time for WQ data to show up in buffer from misbehaving sonde
        Call PullWqData
        #If WqSonde = "WQ_SERIAL_BURST" Then
          If GetBurst = True Then 'It's 15th minute, time to get the burst data
            Call SetBurst
          EndIf
        #EndIf 'has burst
        Call ParseWqData
      #EndIf
      #If WqSonde <> "NONE" OR HasSuna = True Then 'use same timers for WQ and SUNA for consistency
        If Mod15Minutes = 840 OR Mod15Minutes = 0 Then
          Do ' Start loop
            SampleTime = Timer(DebugTimer,mSec,4)
            SampleTime = SampleTime/1000
            Delay(1,250,mSec)
          Loop Until SampleTime > 15 'wait until we get to 15sec into minute, then proceed to wipe/flushing ports/sampling suna
        EndIf
      #EndIf
      #If WqSonde <> "NONE" Then 'if we have a sonde, in 14th minute, wipe, starting at 15s into minute. (Sondes wipe for 45s, will be ready for 15th min)
        If WipeFlag = True Then
          Call WipeWq
        EndIf
      #EndIf
      #If WqSonde = "WQ_SERIAL_BURST" Then
        SerialFlush(WqSerialPort) 'flush ports for WQ sondes so they can start filling buffer
        #If TopBottom = True
          SerialFlush(BtmWqSerialPort)
        #EndIf
      #EndIf
      '==================================================================================
      '----------------------- START SUNA SAMPLING HERE   -------------------------------
      '==================================================================================
      #If HasSuna = True Then
        If SampleSuna = True Then 'we're in 15th min
          ManSunaWiper = False 'turn off wiper, just in case user had it on
          PortSet(SunaWipeSwitch,0)
          Do 'start loop to check warm up time
            SunaTimer =Timer(SunaSampleTimer,mSec,4)
            SunaTimer = SunaTimer/1000
            If SunaTimer >= 15 Then 'if it's been 15s since power up
              SunaReady = True 'we're ready to sample
              ExitDo
            Else
              SunaReady = False
            EndIf
            Delay(1,100,mSec) 'delay 0.1s before checking again
          Loop
          If SunaReady = True Then
            SerialOpen(SunaPort,115200,0,0,6000) 'open the serial port with enough buffer to hold 3 full strings
            oCount = 0 'start a counter at 0
            SunaSampleStart = Timer (SunaSampleTimer,mSec,4)
            SunaSampleStart = SunaSampleStart/1000
            LFrameCnt = 0 'Reset good values counter to 0
            DFrameCnt = 0
            BadSunaVals = 0 'Reset bad values counter to 0
            'For Lcount = 1 To MaxSunaBurst 'start For/Next loop to continue for "MaxSunaBurst" times
            Do 'Start loop to collect Suna Data. Loop until LFrameThreshold is met OR timer >= 55sec
              SunaMissedCnt = 0 'set the missed count to 0
              SunaTimer = Timer(DebugTimer,Sec,4) 'read the timer started at the beginning of the scan
              If SunaTimer >= 53 Then 'if we didn't complete all samples by 53 seconds, exit the loop to avoid skipping scans. SerialIn below has a timeout of 2s per attempt, totalling 6s until flagged as bad
                ExitDo
              EndIf 'Check Timer
              oCount = oCount + 1 'if we've proceeded into data acquisition and didn't time out, increase the count.
              Do 'start Do/Loop
                LFrame = False 'Force all trigger flags to false to make sure we stay in the loop appropriately
                DFrame = False
                SunaMissed = False
                LampWarn = False
                MemWarn = False
                SunaWarning = ""
                SerialIn(SunaBurstIn,SunaPort,200,CHR(13)+CHR(10),2000) 'read data into SunaBurstIn string - 20191022, TV increased timeout from 50 to 200 to account for differences in integration times
                SunaStringLen(oCount) = Len(SunaBurstIn) 'get the length of the string
                If SunaStringLen(oCount) > 1000 Then 'if the string is longer than 1000 bytes, DarkFrames are around 1100, Light frames around 1600+
                  LocLF = InStr (1,SunaBurstIn,"L",2) 'search the string for an L (to store LightFrames and do calculations)
                  LocDF = InStr (1,SunaBurstIn,"D",2) 'search the string for a D (to store raw dark frames)
                  Delay (1,50,mSec) 'delay 50 millisec
                  If LocLF = 5 Then 'if the L is found at byte 5
                    If InStr(1,SunaBurstIn,"-1",2) <> 0 AND InStr(1,SunaBurstIn,"-1",2) < 40 Then 'if a -1 occurs early in the light frame, it's bad
                      LFrame = True 'we know it's a LightFrame
                      DFrame = False
                      LampWarn = False
                      MemWarn = False
                      SunaWarning = "-1 found at byte " + InStr(1,SunaBurstIn,"-1",2) + ". Assume lamp problem."
                    Else
                      LFrame = True
                      DFrame = False
                      LampWarn = False
                      MemWarn = False
                      SunaWarning = ""
                    EndIf
                  ElseIf LocDF = 5 Then 'if D is found at byte 5
                    LFrame = False 'not a light frame
                    DFrame = True 'it is a dark frame
                    LampWarn = False
                    MemWarn = False
                    SunaWarning = ""
                  ElseIf LocLF <> 5 AND LocDF <> 5 Then 'other wise, if D or L is not found at byte 5 but we have >1000 bytes
                    LFrame = False 'not light or dark frame
                    DFrame = False
                    LampWarn = False
                    MemWarn = False
                    SunaWarning = ""
                    SunaMissedCnt = SunaMissedCnt + 1 'something went wrong, data didn't populate appropriately
                  EndIf 'if > 1000 bytes checks
                Else 'if less than 1000 bytes came through
                  LocSunaProb = InStr (1,SunaBurstIn,CHR(91),2) 'Search for a "[" (ASCII Decimal Code 91), All errors contain bracketed timestamp at beginning of string
                  If LocSunaProb <> 0 Then 'A "[" was found, indicating SUNA issue
                    LocSunaProb = InStr(1,SunaBurstIn,"Cannot process to few",2)
                    If LocSunaProb <> 0 Then
                      LampWarn = True 'Set a flag
                      LFrame = False
                      DFrame = False
                      MemWarn = False
                      SunaWarning = SunaBurstIn 'Record the String's Text in a warning variable
                    EndIf
                    LocSunaProb = InStr (1,SunaBurstIn,"Frame not written to file",2)
                    LampWarn = False
                    LFrame = False
                    DFrame = False
                    MemWarn = True
                    SunaWarning = SunaBurstIn 'Record string's text into warning variable
                  Else
                    LampWarn = False 'No Lamp failure warning
                    LFrame = False
                    DFrame = False
                    MemWarn = False
                    SunaWarning = "" 'Leave "SunaWarning" blank
                  EndIf
                  SunaMissedCnt = SunaMissedCnt + 1 'we missed data <- this gets reset every loop attempt to get a new string
                EndIf 'if < 1000 bytes came through
                If SunaMissedCnt >= 3 OR LampWarn = True OR MemWarn = True Then 'if we miss data for 6 consecutive seconds (based on SerialIn TimeOut)
                  SunaMissed = True 'set a flag
                Else
                  SunaMissed = False 'otherwise, don't set flag
                EndIf 'if suna missed = true
              Loop Until LFrame = True OR DFrame = True OR SunaMissed = True 'OR TestMiss = True 'continue looping until we find a LightFrame or we've missed the data/no data are coming in
              Delay (1,200,mSec) 'delay 0.2 sec
              If SunaMissed = True Then 'if we actually didn't get data (less than 1000 bytes OR "D" or "L" are not in byte 5 of the string
                If LFrame = True AND LampWarn = True Then 'if it's a "light frame" but had a -1 appear, the lamp is bad
                  SplitStr(RawSunaArray(oCount,1),SunaBurstIn,&H0D0A,282,0) 'split raw data into raw array
                  SplitStr(RawHeader(oCount),SunaBurstIn,"",1,1) 'record header
                  If RawSunaArray(oCount,1) < 1000 Then
                    RawHeader(oCount) = RawHeader(oCount) + "0" 'add leading 0 to serial numbers  less than 1000
                  Else
                    RawHeader(oCount) = RawHeader(oCount)
                  EndIf
                  BadSunaVals = BadSunaVals + 1 'increase bad value counter
                Else
                  RawSunaArray(oCount,-1)() = BadDataIndicator 'if it wasn't a "light frame", force all values to NANs
                  RawHeader(oCount) = BadDataIndicator 'force header to NAN
                  BadSunaVals = BadSunaVals + 1 'increase bad value counter
                EndIf
              ElseIf LFrame = True AND LampWarn = False Then 'if its a good light frame and we didn't find a -1
                LFrameCnt = LFrameCnt + 1
                SplitStr(GoodSunaArray(LFrameCnt,1),SunaBurstIn,&H0D0A,282,0) 'we have data, let's split the string into the good data multi-dimensioned array based on the counter
                'Start at oCount (seconds), at the first parameter. continue to parse for 282 repetitions
                SplitStr(RawSunaArray(oCount,1),SunaBurstIn,&H0D0A,282,0) 'parse the good data into the raw array
                SplitStr(RawHeader(oCount),SunaBurstIn,"",1,1)
                SplitStr(LFHeader(LFrameCnt),SunaBurstIn,"",1,1)
                If GoodSunaArray(LFrameCnt,1) < 1000 Then 'if serial number is <1000
                  LFHeader(LFrameCnt) = LFHeader(LFrameCnt) + "0" 'add leading 0
                  RawHeader(oCount) = RawHeader(oCount) + "0"
                Else
                  LFHeader(oCount) = LFHeader(oCount)
                  RawHeader(oCount) = RawHeader(oCount)
                EndIf 'serial number check
              ElseIf DFrame = True 'if it's a dark frame
                DFrameCnt = DFrameCnt + 1
                SplitStr(RawSunaArray(oCount,1),SunaBurstIn,&H0D0A,282,0)
                SplitStr(RawHeader(oCount),SunaBurstIn,"",1,1)
                If RawSunaArray(oCount,1) < 1000 Then
                  RawHeader(oCount) = RawHeader(oCount) + "0"
                Else
                  RawHeader(oCount) = RawHeader(oCount)
                EndIf 'serial number check
              EndIf 'if suna wasn't missed
              Erase(SunaBurstIn) 'erase the string
              SerialFlush(SunaPort) 'flush the port
              Delay (1,200,mSec) 'delay another 0.2sec
            Loop Until LFrameCnt >= LFrameThreshold
            Delay (1,100,mSec) 'delay 0.1sec
            SerialClose(SunaPort) 'close the port
            PortSet (SunaSwitch,0) 'turn off the Suna
            SunaTimer = Timer(SunaSampleTimer,mSec,4) 'read the timer for how long the Suna was powered
            SunaOnTime = SunaTimer/1000 'convert timer from mSec to Sec
            SunaProcessStart = Timer(DebugTimer,mSec,4) 'read a timer for the start of the processing
            SunaProcessStart = SunaProcessStart/1000 'convert from mSec to Sec
            If LFrameCnt >= 10 Then 'if we have at least 10 good values
              For mCount = 1 To LFrameCnt 'start For/Next loop to parse data, mCount loop is for number of values
                For nCount = 1 To 282 'start loop for number of columns
                  SunaBurstData(nCount) = GoodSunaArray(mCount,nCount) 'parse columns into the Burst Data array from the multi-dimensioned array built above
                Next nCount
                If SunaBurstData(1) <> "NAN" Then 'if first value in array isn't NAN, we have data
                  If SunaBurstData(1) < 255 Then 'if SUNA SN is less than 255
                    SSN = 1 'set locations for parameters
                    SST = 2
                    SNuM = 3
                    SNmgL = 4
                    SFR = 5
                    STL = 6
                    STS = 7
                    SLT = 8
                    SH = 9
                    SSA = 13
                    SDA = 14
                    SVL = 10
                    SVM = 12
                    SA254 = BadDataIndicator 'leave these as NAN, Current versions of BGC's V1 SUNAs don't output A254 or A350
                    SA350 = BadDataIndicator
                  Else  'otherwise, it's a SUNAV2
                    SSN = 1 'set locations for parameters
                    SST = 3
                    SNuM = 4
                    SNmgL = 5
                    SFR = 281
                    STL = 270
                    STS = 269
                    SLT = 271
                    SH = 272 'Check this- value is 0.137 and doesnt look right!
                    SSA = 9
                    SDA = 10
                    SVL = 274
                    SVM = 273
                    SA254 = 6
                    SA350 = 7
                  EndIf 'parse based on Suna Serial Number
                EndIf 'if first value isn't NAN
                SunaSN = SunaBurstData(SSN) 'parse data into appropriate columns
                SunaSampleTime = SunaBurstData(SST)'ASCII FLOAT 5..11
                SunaNitrateuM = SunaBurstData(SNuM)'AF 4..9
                SunaNitratemgL = SunaBurstData(SNmgL)'AF 6..11
                SunaFittingResult = SunaBurstData(SFR)
                TLamp = SunaBurstData(STL)
                TSpec = SunaBurstData(STS)
                SunaLampTime = SunaBurstData(SLT)
                SunaHumid = SunaBurstData(SH)'AF 3..5 Case Is
                SunaSpecAve = SunaBurstData(SSA) 'AI 1..5
                SunaDarkAve = SunaBurstData(SDA)'ASCII INTEGER 1.3
                SunaVoltLamp = SunaBurstData(SVL) 'AI 1..5
                SunaVoltMain = SunaBurstData(SVM)'ASCII INTEGER 1.3ta(),256,SunaBurstData(12),256)
                A254 = SunaBurstData(SA254)
                A350 = SunaBurstData(SA350)
                If mCount >= LFrameCnt Then 'if we've reached our total number of Light Frames
                  RecSunaData = True 'set the table trigger flag to true
                Else
                  RecSunaData = False 'otherwise, we aren't ready to record the table
                EndIf 'check to see if we're ready to calculate stats
                SunaHeader = LFHeader(mCount)
                Move (SpectrumData(),256,SunaBurstData(12),256) 'parse Spectrum data from burst array
                CallTable SunaLFData 'store raw Light Frame Data
                CallTable SunaStats 'store values into stats table, then record them when we've reached our count threshold
              Next mCount
            EndIf 'if we had at least 10 light frames
            For mCount = 1 To oCount  'start For/Next loop to parse all RAW data, oCount is total number of times the Do...Loop occured
              For nCount = 1 To 282 'start loop for number of columns
                SunaBurstData(nCount) = RawSunaArray(mCount,nCount) 'parse columns into the Burst Data array from the multi-dimensioned array built above
              Next nCount
              If mCount >= oCount AND LFrameCnt < 10 Then 'if we've reached our sampling total time and we didn't trigger the table earlier
                RecSunaData = True 'set the table trigger flag to true
              Else
                RecSunaData = False 'otherwise, we aren't ready to record the table
              EndIf 'check whether we completed the total number of samples, and if light count was less than 10
              SunaHeader = RawHeader(mCount)
              CallTable RawSunaData 'store raw 1 second data
              If LFrameCnt < 10 Then 'we want to store something in the stats table so we don't skip a record
                Call ResetSunaStats 'If LightFrame threshold wasn't met, Force all values to NANs
                CallTable SunaStats 'store NAN values into stats table, then record them when we've reached our count threshold so we don't skip records if LightFrame threshold isn't met
              EndIf 'store in stats table if Lframecnt < 10
            Next mCount
          EndIf 'if Suna is ready based on warmup timer
          CallTable SunaLength
          SunaBurstData() = BadDataIndicator 'reset all arrays to NANs, so they don't populate duplicate values if no data are present next time
          RawSunaArray() = BadDataIndicator
          GoodSunaArray() = BadDataIndicator
          SpectrumData() = BadDataIndicator
          Call CopySunaStats 'copy the stats from the "SunaStats" table to new variables to be sampled by the AQ table
          SunaProcessEnd = Timer(DebugTimer,mSec,4) 'store the end time
          SunaProcessEnd = SunaProcessEnd/1000 'convert from mSec to Sec
          SunaProcessTotTime = SunaProcessEnd-SunaProcessStart 'calculate total time it took to process data
        EndIf
      #EndIf 'has suna
      #If WqSonde = "WQ_SERIAL_BURST" Then
        If Mod15Minutes = 0 Then 'only do the loop if 15th minute
          Do 'start Do...Loop
            SampleTime = Timer(DebugTimer,mSec,4)
            SampleTime = SampleTime/1000
            Delay(1,250,mSec)
          Loop Until SampleTime > 50 'Allow for at least 35s of sampling for Sondes to ensure we have 30 data points in buffer
        EndIf
      #EndIf
      #If WqSonde <> "NONE" Then
        #If WqSonde = "WQ_SERIAL_BURST" Then
          If GetBurst = True Then
            Call FillWqBurstArray
            Call SortBurst
            Call CopyMedBurstVals
          EndIf
          GetBurst = False
        #EndIf
        If SetEXOTimeFlg = True Then
          Call SetEXOTime
          SetEXOTimeFlg = False
        EndIf
        Call CycleWqPower
      #EndIf
      #If HasSuna = True Then
        If WipeSuna = True Then
          Do
            WipeStart = Timer(SunaWipeTimer,mSec,4)
            WipeStart = WipeStart/1000
            If WipeStart >= 55 Then
              StartWipe = True
              ExitDo
            Else
              StartWipe = False
            EndIf
            Delay(1,100,mSec) 'delay 0.1s between loops
          Loop
          If StartWipe = True Then
            PortSet(SunaWipeSwitch,1) 'send signal to wiper relay
            Delay(1,250,mSec) 'delay 0.25s
            PortSet(SunaWipeSwitch,0) 'turn wiper signal off (relay only needs 0.1s signal to trigger)
            StartWipe = False
            WipeEnd = Timer(SunaWipeTimer,mSec,4)
            WipeEnd = WipeEnd/1000
            SunaWipeTotTime = WipeEnd - WipeStart
            SunaWipeTime = Status.Timestamp(1,0)
          EndIf 'start wipe = true
        EndIf 'wipe suna = true
      #EndIf 'has suna
      DataTabsStart = Timer(DebugTimer,mSec,4)
      DataTabsStart = DataTabsStart/1000
      AQTabStart = Timer(DebugTimer,msec,4) 'read timer for start time of the AQ table
      AQTabStart = AQTabStart/1000 'convert
      CallTable Aquarius
      AQTabEnd = Timer (DebugTimer,msec,4) 'end time of AQ table
      AQTabEnd = AQTabEnd/1000 'convert
      AQTabTotTime = AQTabEnd - AQTabStart   'total time to write to AQ
      CallTable DataOut
      #If HasVM = True Then
        CallBmChkStart = Timer(DebugTimer,msec,4)
        CallBmChkStart = CallBmChkStart/1000
        CallTable BeamCheck
        CallBmChkEnd = Timer(DebugTimer,msec,4)
        CallBmChkEnd = CallBmChkEnd/1000
        CallBmChkTotTime = CallBmChkEnd-CallBmChkStart
        #If IsSpecStudy = True Then
          CallTable VelData
        #EndIf
        #If VMHasVertical = True Then
          CallTable VerticalVelocities
          CallTable Vertical1MinVel
        #EndIf
        #If VMHasBottomTrack = True Then
          CallTable BottomTrack
          CallTable BtmTrack1Min
        #EndIf
      #EndIf 'If we have VM
      CallTable QAQCInfo
      CallTable Data1m
      CallTable SVMaq
      If Tech <> "" OR VisitReason <> "" Then SiteVisTrig = True
      #If HasVM = True Then
        If TrueUpBeamStg <> NAN OR TrueVMPressStg <> NAN OR TruePS1Stg <> NAN OR TruePS2Stg <> NAN Then
          ErrorEvent = "Tech Visit"
          SiteVisTrig = True
        EndIf
      #EndIf
      #If WqSonde <> "NONE" Then 'if sonde is present, need to check if SondeStg = NAN
        #If HasVM = True Then
        If TrueSondeStg <> NAN Then 'if it's not NAN
          ErrorEvent = "Tech Visit"
          SiteVisTrig = True
        EndIf 'end sonde stg check
        #EndIf
      #EndIf
      CallTable SiteVisit 'Call sitevisit
      Tech = "" 'set tech back to null value
      VisitReason = ""
      #If HasVM = True Then
        'now set TrueStg values back to BadDataIndicator
        TrueUpBeamStg = BadDataIndicator
        TrueVMPressStg = BadDataIndicator
        TruePS1Stg = BadDataIndicator
        TruePS2Stg = BadDataIndicator
      #EndIf
      #If WqSonde <> "NONE" Then
        #If HasVM = True Then
        TrueSondeStg = BadDataIndicator
        #EndIf
      #EndIf 'if sonde present
      'Now set Visit Variables back to False
      DataTabsEnd = Timer(DebugTimer,mSec,4)
      DataTabsEnd = DataTabsEnd/1000
      DataTabsTotTime = DataTabsEnd - DataTabsStart
      #If WqSonde = "WQ_SERIAL_BURST" Then
        If Rec15MinFlag = True Then
          Call ResetMedBurstVars
        EndIf
      #EndIf
      #If HasSuna = True Then
        If Rec15MinFlag = True Then
          Call ResetSunaStats 'reset suna variables after they've been recorded
        EndIf
      #EndIf
      If Rec24HrFlag = True Then
        Call ZeroErrCounters 'Zero our counters after we call QAQC table at midnight
      EndIf
     #If HasVM = True Then
      If Rec15MinFlag = True Then
        StgOutOfBndCnt = 0
        Stg2OutOfBndCnt = 0
        BadStgCount = 0
        BadStg2Cnt = 0
        BadPS1Cnt = 0
        BadPS2Cnt = 0
        BadUpbeamCnt = 0
        BadVMPressCnt = 0
      EndIf
      #EndIf
      Call GetLastScan 'produce timestamp of last completed scan
      ScanNum = ScanNum + 1 'Keep at end of scan, so we know X scans have been completed
      ScanEnd = Timer(DebugTimer,mSec,4) 'read timer for end of scan
      ScanEnd = ScanEnd/1000 'convert
      ProcessTime = ScanEnd - ScanStart 'calculate total time
      Call ModemCheck
      #If RadioNetwork = True Then 'only compile if it's in a radio network
        If ReadRadSettings = True Then 'if user wants to store radio settings
          Call ReadRF 'read in settings
          Call StoreRadSettings 'store in USR drive
        EndIf
        #If IsMaster = True Then 'if it's the master
          Call CheckLinks 'call the subroutine that checks multiple links
          If SetRadSettings = True OR ResetMaster = True AND ResetTryOK = True Then 'If link failed and enough time has passed to try reset again or user wants a manual reset
            Call ResetRadDefault 'first, let's set radio back to factory defaults
            Call ReadRF 'read in the settings after setting to default to make sure it did what it's supposed to
            Delay (1,1,Sec) 'delay, so user can see the change (maybe call/store a 1 record table here to minimize processing delay?)
            Call SetRadSetting 'set radio settings to the what's stored on USR
            Call ReadRF 'read in the new settings
            Call StoreRadSettings 'store the new settings
            ResetTried = True 'flag to indicate a reset was tried
            NextTryCnt = 0 'reset the counter to zero so we can wait X amount of time before retrying
            RadResetAttempts = RadResetAttempts + 1 'count how many attempts has been made (will reset if a link is re-established)
          EndIf
          If ResetMaster = True AND ResetTried = False Then 'if the reset master flag is still set and we didn't try to reset on this scan
            NextTryCnt = NextTryCnt + 1 'increase NextTryCnt
          EndIf
          If NextTryCnt >= MaxNextTryCnt Then 'If NextTryCnt is greater that threshold
            ResetTryOK = True 'it's ok to try the reset
          Else
            ResetTryOK = False 'otherwise, not enough time has passed since previous attempt
          EndIf
        #Else 'if it's a slave
          Call CheckSlaveLink 'only check the single link to the master
          If SetRadSettings = True OR ResetSlave = True AND ResetTryOK = True Then 'if link failed and enough time has passed to try again or user wants manual reset
            Call ResetRadDefault 'reset radio to defaults
            Call ReadRF 'read in settings to verify it did it correctly
            Delay (1,1,Sec) 'delay, so user has opportunity to see that it worked
            Call SetRadSetting 'set radio to settings stored in USR
            Call ReadRF 'read in the new settings
            Call StoreRadSettings 'store the new radio settings
            ResetTried = True 'a reset was attempted
            NextTryCnt = 0 'reset counter to 0
            RadResetAttempts = RadResetAttempts + 1 'count how many attempts has been made (will reset if a link is re-established)
          EndIf
          If ResetSlave = True AND ResetTried = False Then 'if the ResetSlave flag is still set and we didn't try a reset on this scan
            NextTryCnt = NextTryCnt + 1 'increase counter
          EndIf
          If NextTryCnt >= MaxNextTryCnt Then 'if counter is greater than threshold
            ResetTryOK = True 'then enough time has passed since previous attempt, it is ok to try the reset again
          Else
            ResetTryOK = False 'not enough time has passed, let's wait to try again.
          EndIf
        #EndIf
        If SetRadToDefault = True Then 'if user wants to set radio to defaults/turn off radio
          Call ResetRadDefault 'reset to default
          Call ReadRF 'read in new settings, but don't store settings to USR because these settings are established as Constants and don't need to be stored.
          SetRadToDefault = False 'reset flag to false
        EndIf
        ResetTried = False 'set flag to false to start counter (if necessary)
        CallTable RadioStatus
      #EndIf
      #If HasVM = True OR WqSonde <> "NONE" Then
        If StoreVariablesFlg = True OR ModDay = 0 Then
          Call StoreVariables
        EndIf
      #EndIf
      #If HasIridium Then
        Call IridiumDataOut
        If IridiumManualCycle = False Then
          PortSet(IridiumSwitchPort,0)'this assume normally closed setting for relay
        ElseIf IridiumManualCycle = True Then
          Call CycleIridiumPower
        EndIf
      #EndIf
      #If HasHMS = True Then
        HMS_24hrcount = HMS_24hrcount + 1
        Call HMS
      #EndIf
      CallTable Debugger
      Call ZeroTimers
    NextScan

    #If HasIridium = True Then
      'slow sequence will run in the background and allow the DCP to act as an SDI12 sensor. To be used to send Aquarius table data to the Iridium Radio
      SlowSequence
      Do
        SDI12SensorSetup (IridiumVars,IridiumCom,0,5)'turns selected port into an SDI12 port. Use setting to adjust port and address. Number of repetions should match IridiumOutArray count. Test on address 1 and had issues. Address 0 seems to work fine.
        Delay (1,5,sec) 'delay to make sure value are present
        SDI12SensorResponse(IridiumOutArray)'sensor will respond with entire array when Iridium Radio queries DCP
      Loop
    #EndIf

  EndProg
